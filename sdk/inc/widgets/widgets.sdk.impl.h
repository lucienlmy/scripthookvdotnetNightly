	int64 /*var-non-null*/ Duration::microsecondsPerMillisecond() {
		auto m = ManagedCall("Duration", "microsecondsPerMillisecond");
		int64 result;
		m.check(m.call(result));
		return result;
	}

	int64 /*var-non-null*/ Duration::millisecondsPerSecond() {
		auto m = ManagedCall("Duration", "millisecondsPerSecond");
		int64 result;
		m.check(m.call(result));
		return result;
	}

	int64 /*var-non-null*/ Duration::secondsPerMinute() {
		auto m = ManagedCall("Duration", "secondsPerMinute");
		int64 result;
		m.check(m.call(result));
		return result;
	}

	int64 /*var-non-null*/ Duration::minutesPerHour() {
		auto m = ManagedCall("Duration", "minutesPerHour");
		int64 result;
		m.check(m.call(result));
		return result;
	}

	int64 /*var-non-null*/ Duration::hoursPerDay() {
		auto m = ManagedCall("Duration", "hoursPerDay");
		int64 result;
		m.check(m.call(result));
		return result;
	}

	int64 /*var-non-null*/ Duration::microsecondsPerSecond() {
		auto m = ManagedCall("Duration", "microsecondsPerSecond");
		int64 result;
		m.check(m.call(result));
		return result;
	}

	int64 /*var-non-null*/ Duration::microsecondsPerMinute() {
		auto m = ManagedCall("Duration", "microsecondsPerMinute");
		int64 result;
		m.check(m.call(result));
		return result;
	}

	int64 /*var-non-null*/ Duration::microsecondsPerHour() {
		auto m = ManagedCall("Duration", "microsecondsPerHour");
		int64 result;
		m.check(m.call(result));
		return result;
	}

	int64 /*var-non-null*/ Duration::microsecondsPerDay() {
		auto m = ManagedCall("Duration", "microsecondsPerDay");
		int64 result;
		m.check(m.call(result));
		return result;
	}

	int64 /*var-non-null*/ Duration::millisecondsPerMinute() {
		auto m = ManagedCall("Duration", "millisecondsPerMinute");
		int64 result;
		m.check(m.call(result));
		return result;
	}

	int64 /*var-non-null*/ Duration::millisecondsPerHour() {
		auto m = ManagedCall("Duration", "millisecondsPerHour");
		int64 result;
		m.check(m.call(result));
		return result;
	}

	int64 /*var-non-null*/ Duration::millisecondsPerDay() {
		auto m = ManagedCall("Duration", "millisecondsPerDay");
		int64 result;
		m.check(m.call(result));
		return result;
	}

	int64 /*var-non-null*/ Duration::secondsPerHour() {
		auto m = ManagedCall("Duration", "secondsPerHour");
		int64 result;
		m.check(m.call(result));
		return result;
	}

	int64 /*var-non-null*/ Duration::secondsPerDay() {
		auto m = ManagedCall("Duration", "secondsPerDay");
		int64 result;
		m.check(m.call(result));
		return result;
	}

	int64 /*var-non-null*/ Duration::minutesPerDay() {
		auto m = ManagedCall("Duration", "minutesPerDay");
		int64 result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Duration> /*var-non-null*/ Duration::zero() {
		auto m = ManagedCall("Duration", "zero");
		shptr<class Duration> result;
		m.check(m.call(result));
		return result;
	}

	int64 /*get-non-null*/ Duration::inDays() {
		auto m = ManagedCall("Duration", "inDays");
		m.put("this", this);
		int64 result;
		m.check(m.call(result));
		return result;
	}

	int64 /*get-non-null*/ Duration::inHours() {
		auto m = ManagedCall("Duration", "inHours");
		m.put("this", this);
		int64 result;
		m.check(m.call(result));
		return result;
	}

	int64 /*get-non-null*/ Duration::inMinutes() {
		auto m = ManagedCall("Duration", "inMinutes");
		m.put("this", this);
		int64 result;
		m.check(m.call(result));
		return result;
	}

	int64 /*get-non-null*/ Duration::inSeconds() {
		auto m = ManagedCall("Duration", "inSeconds");
		m.put("this", this);
		int64 result;
		m.check(m.call(result));
		return result;
	}

	int64 /*get-non-null*/ Duration::inMilliseconds() {
		auto m = ManagedCall("Duration", "inMilliseconds");
		m.put("this", this);
		int64 result;
		m.check(m.call(result));
		return result;
	}

	int64 /*get-non-null*/ Duration::inMicroseconds() {
		auto m = ManagedCall("Duration", "inMicroseconds");
		m.put("this", this);
		int64 result;
		m.check(m.call(result));
		return result;
	}

	bool /*get-non-null*/ Duration::isNegative() {
		auto m = ManagedCall("Duration", "isNegative");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Duration> /*non-null*/ Duration::plus(/*non-null*/ shptr<class Duration> other) {
		auto m = ManagedCall("Duration", "+");
		m.put("this", this);
		m.put("other", other, true);
		shptr<class Duration> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Duration> /*non-null*/ Duration::minus(/*non-null*/ shptr<class Duration> other) {
		auto m = ManagedCall("Duration", "-");
		m.put("this", this);
		m.put("other", other, true);
		shptr<class Duration> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Duration> /*non-null*/ Duration::mul(/*non-null*/ shptr<class num> factor) {
		auto m = ManagedCall("Duration", "*");
		m.put("this", this);
		m.put("factor", factor, true);
		shptr<class Duration> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Duration> /*non-null*/ Duration::idiv(/*non-null*/ int64 quotient) {
		auto m = ManagedCall("Duration", "~/");
		m.put("this", this);
		m.put("quotient", quotient);
		shptr<class Duration> result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ Duration::less(/*non-null*/ shptr<class Duration> other) {
		auto m = ManagedCall("Duration", "<");
		m.put("this", this);
		m.put("other", other, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ Duration::greater(/*non-null*/ shptr<class Duration> other) {
		auto m = ManagedCall("Duration", ">");
		m.put("this", this);
		m.put("other", other, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ Duration::lessEqual(/*non-null*/ shptr<class Duration> other) {
		auto m = ManagedCall("Duration", "<=");
		m.put("this", this);
		m.put("other", other, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ Duration::greaterEqual(/*non-null*/ shptr<class Duration> other) {
		auto m = ManagedCall("Duration", ">=");
		m.put("this", this);
		m.put("other", other, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ Duration::equals(/*non-null*/ shptr<class ObjBase> other) {
		auto m = ManagedCall("Duration", "==");
		m.put("this", this);
		m.put("other", other, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	int64 /*non-null*/ Duration::compareTo(/*non-null*/ shptr<class Duration> other) {
		auto m = ManagedCall("Duration", "compareTo");
		m.put("this", this);
		m.put("other", other, true);
		int64 result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Duration> /*non-null*/ Duration::abs() {
		auto m = ManagedCall("Duration", "abs");
		m.put("this", this);
		shptr<class Duration> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Duration> /*non-null*/ Duration::neg() {
		auto m = ManagedCall("Duration", "unary-");
		m.put("this", this);
		shptr<class Duration> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Duration> /*non-null*/ Duration::ctorMain(_ctorMain p) {
		auto m = ManagedCall("Duration", "Duration");
		m.put("days", p.days);
		m.put("hours", p.hours);
		m.put("minutes", p.minutes);
		m.put("seconds", p.seconds);
		m.put("milliseconds", p.milliseconds);
		m.put("microseconds", p.microseconds);
		shptr<class Duration> result;
		m.check(m.call(result, true));
		return result;
	}

	int64 /*var-non-null*/ TimeOfDay::hoursPerDay() {
		auto m = ManagedCall("TimeOfDay", "hoursPerDay");
		int64 result;
		m.check(m.call(result));
		return result;
	}

	int64 /*var-non-null*/ TimeOfDay::hoursPerPeriod() {
		auto m = ManagedCall("TimeOfDay", "hoursPerPeriod");
		int64 result;
		m.check(m.call(result));
		return result;
	}

	int64 /*var-non-null*/ TimeOfDay::minutesPerHour() {
		auto m = ManagedCall("TimeOfDay", "minutesPerHour");
		int64 result;
		m.check(m.call(result));
		return result;
	}

	int64 /*var-non-null*/ TimeOfDay::hour() {
		auto m = ManagedCall("TimeOfDay", "hour");
		m.put("this", this);
		int64 result;
		m.check(m.call(result));
		return result;
	}

	int64 /*var-non-null*/ TimeOfDay::minute() {
		auto m = ManagedCall("TimeOfDay", "minute");
		m.put("this", this);
		int64 result;
		m.check(m.call(result));
		return result;
	}

	DayPeriod /*get-non-null*/ TimeOfDay::period() {
		auto m = ManagedCall("TimeOfDay", "period");
		m.put("this", this);
		DayPeriod result;
		m.check(m.call(result));
		return result;
	}

	int64 /*get-non-null*/ TimeOfDay::hourOfPeriod() {
		auto m = ManagedCall("TimeOfDay", "hourOfPeriod");
		m.put("this", this);
		int64 result;
		m.check(m.call(result));
		return result;
	}

	int64 /*get-non-null*/ TimeOfDay::periodOffset() {
		auto m = ManagedCall("TimeOfDay", "periodOffset");
		m.put("this", this);
		int64 result;
		m.check(m.call(result));
		return result;
	}

	shptr<class TimeOfDay> /*non-null*/ TimeOfDay::replacing(_replacing p) {
		auto m = ManagedCall("TimeOfDay", "replacing");
		m.put("this", this);
		m.put("hour", p.hour);
		m.put("minute", p.minute);
		shptr<class TimeOfDay> result;
		m.check(m.call(result));
		return result;
	}

	stdstr /*non-null*/ TimeOfDay::format(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("TimeOfDay", "format");
		m.put("this", this);
		m.put("context", context, true);
		stdstr result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ TimeOfDay::equals(/*non-null*/ shptr<class ObjBase> other) {
		auto m = ManagedCall("TimeOfDay", "==");
		m.put("this", this);
		m.put("other", other, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class TimeOfDay> /*non-null*/ TimeOfDay::ctorMain(_ctorMain p) {
		auto m = ManagedCall("TimeOfDay", "TimeOfDay");
		m.put("hour", p.hour);
		m.put("minute", p.minute);
		shptr<class TimeOfDay> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class TimeOfDay> /*non-null*/ TimeOfDay::fromDateTime(/*non-null*/ shptr<class DateTime> time) {
		auto m = ManagedCall("TimeOfDay", "fromDateTime");
		m.put("time", time, true);
		shptr<class TimeOfDay> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class TimeOfDay> /*non-null*/ TimeOfDay::now() {
		auto m = ManagedCall("TimeOfDay", "now");
		shptr<class TimeOfDay> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Offset> /*var-non-null*/ Offset::zero() {
		auto m = ManagedCall("Offset", "zero");
		shptr<class Offset> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Offset> /*var-non-null*/ Offset::infinite() {
		auto m = ManagedCall("Offset", "infinite");
		shptr<class Offset> result;
		m.check(m.call(result));
		return result;
	}

	double /*get-non-null*/ Offset::dx() {
		auto m = ManagedCall("Offset", "dx");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	double /*get-non-null*/ Offset::dy() {
		auto m = ManagedCall("Offset", "dy");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	double /*get-non-null*/ Offset::distance() {
		auto m = ManagedCall("Offset", "distance");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	double /*get-non-null*/ Offset::distanceSquared() {
		auto m = ManagedCall("Offset", "distanceSquared");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	double /*get-non-null*/ Offset::direction() {
		auto m = ManagedCall("Offset", "direction");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Offset> /*non-null*/ Offset::scale(/*non-null*/ double scaleX, /*non-null*/ double scaleY) {
		auto m = ManagedCall("Offset", "scale");
		m.put("this", this);
		m.put("scaleX", scaleX);
		m.put("scaleY", scaleY);
		shptr<class Offset> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Offset> /*non-null*/ Offset::translate(/*non-null*/ double translateX, /*non-null*/ double translateY) {
		auto m = ManagedCall("Offset", "translate");
		m.put("this", this);
		m.put("translateX", translateX);
		m.put("translateY", translateY);
		shptr<class Offset> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Offset> /*non-null*/ Offset::neg() {
		auto m = ManagedCall("Offset", "unary-");
		m.put("this", this);
		shptr<class Offset> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Offset> /*non-null*/ Offset::minus(/*non-null*/ shptr<class Offset> other) {
		auto m = ManagedCall("Offset", "-");
		m.put("this", this);
		m.put("other", other, true);
		shptr<class Offset> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Offset> /*non-null*/ Offset::plus(/*non-null*/ shptr<class Offset> other) {
		auto m = ManagedCall("Offset", "+");
		m.put("this", this);
		m.put("other", other, true);
		shptr<class Offset> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Offset> /*non-null*/ Offset::mul(/*non-null*/ double operand) {
		auto m = ManagedCall("Offset", "*");
		m.put("this", this);
		m.put("operand", operand);
		shptr<class Offset> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Offset> /*non-null*/ Offset::div(/*non-null*/ double operand) {
		auto m = ManagedCall("Offset", "/");
		m.put("this", this);
		m.put("operand", operand);
		shptr<class Offset> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Offset> /*non-null*/ Offset::idiv(/*non-null*/ double operand) {
		auto m = ManagedCall("Offset", "~/");
		m.put("this", this);
		m.put("operand", operand);
		shptr<class Offset> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Offset> /*non-null*/ Offset::mod(/*non-null*/ double operand) {
		auto m = ManagedCall("Offset", "%");
		m.put("this", this);
		m.put("operand", operand);
		shptr<class Offset> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Rect> /*non-null*/ Offset::bitop(/*non-null*/ shptr<class Size> other) {
		auto m = ManagedCall("Offset", "&");
		m.put("this", this);
		m.put("other", other, true);
		shptr<class Rect> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Offset> /*nullable*/ Offset::lerp(/*nullable*/ shptr<class Offset> a, /*nullable*/ shptr<class Offset> b, /*non-null*/ double t) {
		auto m = ManagedCall("Offset", "lerp");
		m.put("a", a);
		m.put("b", b);
		m.put("t", t);
		shptr<class Offset> result;
		m.call(result);
		return result;
	}

	bool /*non-null*/ Offset::equals(/*non-null*/ shptr<class ObjBase> other) {
		auto m = ManagedCall("Offset", "==");
		m.put("this", this);
		m.put("other", other, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Offset> /*non-null*/ Offset::ctorMain(/*non-null*/ double dx, /*non-null*/ double dy) {
		auto m = ManagedCall("Offset", "Offset");
		m.put("dx", dx);
		m.put("dy", dy);
		shptr<class Offset> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Offset> /*non-null*/ Offset::fromDirection(/*non-null*/ double direction, /*non-null*/ double distance) {
		auto m = ManagedCall("Offset", "fromDirection");
		m.put("direction", direction);
		m.put("distance", distance);
		shptr<class Offset> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Velocity> /*var-non-null*/ Velocity::zero() {
		auto m = ManagedCall("Velocity", "zero");
		shptr<class Velocity> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Offset> /*var-non-null*/ Velocity::pixelsPerSecond() {
		auto m = ManagedCall("Velocity", "pixelsPerSecond");
		m.put("this", this);
		shptr<class Offset> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Velocity> /*non-null*/ Velocity::neg() {
		auto m = ManagedCall("Velocity", "unary-");
		m.put("this", this);
		shptr<class Velocity> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Velocity> /*non-null*/ Velocity::minus(/*non-null*/ shptr<class Velocity> other) {
		auto m = ManagedCall("Velocity", "-");
		m.put("this", this);
		m.put("other", other, true);
		shptr<class Velocity> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Velocity> /*non-null*/ Velocity::plus(/*non-null*/ shptr<class Velocity> other) {
		auto m = ManagedCall("Velocity", "+");
		m.put("this", this);
		m.put("other", other, true);
		shptr<class Velocity> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Velocity> /*non-null*/ Velocity::clampMagnitude(/*non-null*/ double minValue, /*non-null*/ double maxValue) {
		auto m = ManagedCall("Velocity", "clampMagnitude");
		m.put("this", this);
		m.put("minValue", minValue);
		m.put("maxValue", maxValue);
		shptr<class Velocity> result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ Velocity::equals(/*non-null*/ shptr<class ObjBase> other) {
		auto m = ManagedCall("Velocity", "==");
		m.put("this", this);
		m.put("other", other, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Velocity> /*non-null*/ Velocity::ctorMain(_ctorMain p) {
		auto m = ManagedCall("Velocity", "Velocity");
		m.put("pixelsPerSecond", p.pixelsPerSecond, true);
		shptr<class Velocity> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Size> /*var-non-null*/ Size::zero() {
		auto m = ManagedCall("Size", "zero");
		shptr<class Size> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Size> /*var-non-null*/ Size::infinite() {
		auto m = ManagedCall("Size", "infinite");
		shptr<class Size> result;
		m.check(m.call(result));
		return result;
	}

	double /*get-non-null*/ Size::width() {
		auto m = ManagedCall("Size", "width");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	double /*get-non-null*/ Size::height() {
		auto m = ManagedCall("Size", "height");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	double /*get-non-null*/ Size::aspectRatio() {
		auto m = ManagedCall("Size", "aspectRatio");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	bool /*get-non-null*/ Size::isEmpty() {
		auto m = ManagedCall("Size", "isEmpty");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	double /*get-non-null*/ Size::shortestSide() {
		auto m = ManagedCall("Size", "shortestSide");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	double /*get-non-null*/ Size::longestSide() {
		auto m = ManagedCall("Size", "longestSide");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Size> /*get-non-null*/ Size::flipped() {
		auto m = ManagedCall("Size", "flipped");
		m.put("this", this);
		shptr<class Size> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class OffsetBase> /*non-null*/ Size::minus(/*non-null*/ shptr<class OffsetBase> other) {
		auto m = ManagedCall("Size", "-");
		m.put("this", this);
		m.put("other", other, true);
		shptr<class OffsetBase> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Size> /*non-null*/ Size::plus(/*non-null*/ shptr<class Offset> other) {
		auto m = ManagedCall("Size", "+");
		m.put("this", this);
		m.put("other", other, true);
		shptr<class Size> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Size> /*non-null*/ Size::mul(/*non-null*/ double operand) {
		auto m = ManagedCall("Size", "*");
		m.put("this", this);
		m.put("operand", operand);
		shptr<class Size> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Size> /*non-null*/ Size::div(/*non-null*/ double operand) {
		auto m = ManagedCall("Size", "/");
		m.put("this", this);
		m.put("operand", operand);
		shptr<class Size> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Size> /*non-null*/ Size::idiv(/*non-null*/ double operand) {
		auto m = ManagedCall("Size", "~/");
		m.put("this", this);
		m.put("operand", operand);
		shptr<class Size> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Size> /*non-null*/ Size::mod(/*non-null*/ double operand) {
		auto m = ManagedCall("Size", "%");
		m.put("this", this);
		m.put("operand", operand);
		shptr<class Size> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Offset> /*non-null*/ Size::topLeft(/*non-null*/ shptr<class Offset> origin) {
		auto m = ManagedCall("Size", "topLeft");
		m.put("this", this);
		m.put("origin", origin, true);
		shptr<class Offset> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Offset> /*non-null*/ Size::topCenter(/*non-null*/ shptr<class Offset> origin) {
		auto m = ManagedCall("Size", "topCenter");
		m.put("this", this);
		m.put("origin", origin, true);
		shptr<class Offset> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Offset> /*non-null*/ Size::topRight(/*non-null*/ shptr<class Offset> origin) {
		auto m = ManagedCall("Size", "topRight");
		m.put("this", this);
		m.put("origin", origin, true);
		shptr<class Offset> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Offset> /*non-null*/ Size::centerLeft(/*non-null*/ shptr<class Offset> origin) {
		auto m = ManagedCall("Size", "centerLeft");
		m.put("this", this);
		m.put("origin", origin, true);
		shptr<class Offset> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Offset> /*non-null*/ Size::center(/*non-null*/ shptr<class Offset> origin) {
		auto m = ManagedCall("Size", "center");
		m.put("this", this);
		m.put("origin", origin, true);
		shptr<class Offset> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Offset> /*non-null*/ Size::centerRight(/*non-null*/ shptr<class Offset> origin) {
		auto m = ManagedCall("Size", "centerRight");
		m.put("this", this);
		m.put("origin", origin, true);
		shptr<class Offset> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Offset> /*non-null*/ Size::bottomLeft(/*non-null*/ shptr<class Offset> origin) {
		auto m = ManagedCall("Size", "bottomLeft");
		m.put("this", this);
		m.put("origin", origin, true);
		shptr<class Offset> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Offset> /*non-null*/ Size::bottomCenter(/*non-null*/ shptr<class Offset> origin) {
		auto m = ManagedCall("Size", "bottomCenter");
		m.put("this", this);
		m.put("origin", origin, true);
		shptr<class Offset> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Offset> /*non-null*/ Size::bottomRight(/*non-null*/ shptr<class Offset> origin) {
		auto m = ManagedCall("Size", "bottomRight");
		m.put("this", this);
		m.put("origin", origin, true);
		shptr<class Offset> result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ Size::contains(/*non-null*/ shptr<class Offset> offset) {
		auto m = ManagedCall("Size", "contains");
		m.put("this", this);
		m.put("offset", offset, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Size> /*nullable*/ Size::lerp(/*nullable*/ shptr<class Size> a, /*nullable*/ shptr<class Size> b, /*non-null*/ double t) {
		auto m = ManagedCall("Size", "lerp");
		m.put("a", a);
		m.put("b", b);
		m.put("t", t);
		shptr<class Size> result;
		m.call(result);
		return result;
	}

	bool /*non-null*/ Size::equals(/*non-null*/ shptr<class ObjBase> other) {
		auto m = ManagedCall("Size", "==");
		m.put("this", this);
		m.put("other", other, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Size> /*non-null*/ Size::ctorMain(/*non-null*/ double width, /*non-null*/ double height) {
		auto m = ManagedCall("Size", "Size");
		m.put("width", width);
		m.put("height", height);
		shptr<class Size> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Size> /*non-null*/ Size::copy(/*non-null*/ shptr<class Size> source) {
		auto m = ManagedCall("Size", "copy");
		m.put("source", source, true);
		shptr<class Size> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Size> /*non-null*/ Size::square(/*non-null*/ double dimension) {
		auto m = ManagedCall("Size", "square");
		m.put("dimension", dimension);
		shptr<class Size> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Size> /*non-null*/ Size::fromWidth(/*non-null*/ double width) {
		auto m = ManagedCall("Size", "fromWidth");
		m.put("width", width);
		shptr<class Size> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Size> /*non-null*/ Size::fromHeight(/*non-null*/ double height) {
		auto m = ManagedCall("Size", "fromHeight");
		m.put("height", height);
		shptr<class Size> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Size> /*non-null*/ Size::fromRadius(/*non-null*/ double radius) {
		auto m = ManagedCall("Size", "fromRadius");
		m.put("radius", radius);
		shptr<class Size> result;
		m.check(m.call(result, true));
		return result;
	}

	double /*var-non-null*/ Rect::left() {
		auto m = ManagedCall("Rect", "left");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	double /*var-non-null*/ Rect::top() {
		auto m = ManagedCall("Rect", "top");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	double /*var-non-null*/ Rect::right() {
		auto m = ManagedCall("Rect", "right");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	double /*var-non-null*/ Rect::bottom() {
		auto m = ManagedCall("Rect", "bottom");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Rect> /*var-non-null*/ Rect::zero() {
		auto m = ManagedCall("Rect", "zero");
		shptr<class Rect> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Rect> /*var-non-null*/ Rect::largest() {
		auto m = ManagedCall("Rect", "largest");
		shptr<class Rect> result;
		m.check(m.call(result));
		return result;
	}

	double /*get-non-null*/ Rect::width() {
		auto m = ManagedCall("Rect", "width");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	double /*get-non-null*/ Rect::height() {
		auto m = ManagedCall("Rect", "height");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Size> /*get-non-null*/ Rect::size() {
		auto m = ManagedCall("Rect", "size");
		m.put("this", this);
		shptr<class Size> result;
		m.check(m.call(result));
		return result;
	}

	bool /*get-non-null*/ Rect::hasNaN() {
		auto m = ManagedCall("Rect", "hasNaN");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	bool /*get-non-null*/ Rect::isInfinite() {
		auto m = ManagedCall("Rect", "isInfinite");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	bool /*get-non-null*/ Rect::isFinite() {
		auto m = ManagedCall("Rect", "isFinite");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	bool /*get-non-null*/ Rect::isEmpty() {
		auto m = ManagedCall("Rect", "isEmpty");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	double /*get-non-null*/ Rect::shortestSide() {
		auto m = ManagedCall("Rect", "shortestSide");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	double /*get-non-null*/ Rect::longestSide() {
		auto m = ManagedCall("Rect", "longestSide");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Offset> /*get-non-null*/ Rect::topLeft() {
		auto m = ManagedCall("Rect", "topLeft");
		m.put("this", this);
		shptr<class Offset> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Offset> /*get-non-null*/ Rect::topCenter() {
		auto m = ManagedCall("Rect", "topCenter");
		m.put("this", this);
		shptr<class Offset> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Offset> /*get-non-null*/ Rect::topRight() {
		auto m = ManagedCall("Rect", "topRight");
		m.put("this", this);
		shptr<class Offset> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Offset> /*get-non-null*/ Rect::centerLeft() {
		auto m = ManagedCall("Rect", "centerLeft");
		m.put("this", this);
		shptr<class Offset> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Offset> /*get-non-null*/ Rect::center() {
		auto m = ManagedCall("Rect", "center");
		m.put("this", this);
		shptr<class Offset> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Offset> /*get-non-null*/ Rect::centerRight() {
		auto m = ManagedCall("Rect", "centerRight");
		m.put("this", this);
		shptr<class Offset> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Offset> /*get-non-null*/ Rect::bottomLeft() {
		auto m = ManagedCall("Rect", "bottomLeft");
		m.put("this", this);
		shptr<class Offset> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Offset> /*get-non-null*/ Rect::bottomCenter() {
		auto m = ManagedCall("Rect", "bottomCenter");
		m.put("this", this);
		shptr<class Offset> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Offset> /*get-non-null*/ Rect::bottomRight() {
		auto m = ManagedCall("Rect", "bottomRight");
		m.put("this", this);
		shptr<class Offset> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Rect> /*non-null*/ Rect::shift(/*non-null*/ shptr<class Offset> offset) {
		auto m = ManagedCall("Rect", "shift");
		m.put("this", this);
		m.put("offset", offset, true);
		shptr<class Rect> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Rect> /*non-null*/ Rect::translate(/*non-null*/ double translateX, /*non-null*/ double translateY) {
		auto m = ManagedCall("Rect", "translate");
		m.put("this", this);
		m.put("translateX", translateX);
		m.put("translateY", translateY);
		shptr<class Rect> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Rect> /*non-null*/ Rect::inflate(/*non-null*/ double delta) {
		auto m = ManagedCall("Rect", "inflate");
		m.put("this", this);
		m.put("delta", delta);
		shptr<class Rect> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Rect> /*non-null*/ Rect::deflate(/*non-null*/ double delta) {
		auto m = ManagedCall("Rect", "deflate");
		m.put("this", this);
		m.put("delta", delta);
		shptr<class Rect> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Rect> /*non-null*/ Rect::intersect(/*non-null*/ shptr<class Rect> other) {
		auto m = ManagedCall("Rect", "intersect");
		m.put("this", this);
		m.put("other", other, true);
		shptr<class Rect> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Rect> /*non-null*/ Rect::expandToInclude(/*non-null*/ shptr<class Rect> other) {
		auto m = ManagedCall("Rect", "expandToInclude");
		m.put("this", this);
		m.put("other", other, true);
		shptr<class Rect> result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ Rect::overlaps(/*non-null*/ shptr<class Rect> other) {
		auto m = ManagedCall("Rect", "overlaps");
		m.put("this", this);
		m.put("other", other, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ Rect::contains(/*non-null*/ shptr<class Offset> offset) {
		auto m = ManagedCall("Rect", "contains");
		m.put("this", this);
		m.put("offset", offset, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Rect> /*nullable*/ Rect::lerp(/*nullable*/ shptr<class Rect> a, /*nullable*/ shptr<class Rect> b, /*non-null*/ double t) {
		auto m = ManagedCall("Rect", "lerp");
		m.put("a", a);
		m.put("b", b);
		m.put("t", t);
		shptr<class Rect> result;
		m.call(result);
		return result;
	}

	bool /*non-null*/ Rect::equals(/*non-null*/ shptr<class ObjBase> other) {
		auto m = ManagedCall("Rect", "==");
		m.put("this", this);
		m.put("other", other, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Rect> /*non-null*/ Rect::fromLTRB(/*non-null*/ double left, /*non-null*/ double top, /*non-null*/ double right, /*non-null*/ double bottom) {
		auto m = ManagedCall("Rect", "fromLTRB");
		m.put("left", left);
		m.put("top", top);
		m.put("right", right);
		m.put("bottom", bottom);
		shptr<class Rect> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Rect> /*non-null*/ Rect::fromLTWH(/*non-null*/ double left, /*non-null*/ double top, /*non-null*/ double width, /*non-null*/ double height) {
		auto m = ManagedCall("Rect", "fromLTWH");
		m.put("left", left);
		m.put("top", top);
		m.put("width", width);
		m.put("height", height);
		shptr<class Rect> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Rect> /*non-null*/ Rect::fromCircle(_fromCircle p) {
		auto m = ManagedCall("Rect", "fromCircle");
		m.put("center", p.center, true);
		m.put("radius", p.radius);
		shptr<class Rect> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Rect> /*non-null*/ Rect::fromCenter(_fromCenter p) {
		auto m = ManagedCall("Rect", "fromCenter");
		m.put("center", p.center, true);
		m.put("width", p.width);
		m.put("height", p.height);
		shptr<class Rect> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Rect> /*non-null*/ Rect::fromPoints(/*non-null*/ shptr<class Offset> a, /*non-null*/ shptr<class Offset> b) {
		auto m = ManagedCall("Rect", "fromPoints");
		m.put("a", a, true);
		m.put("b", b, true);
		shptr<class Rect> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Uint8List> /*non-null*/ Uint8List::ctorMain(/*non-null*/ void *address, /*non-null*/ size_t size) {
		auto m = ManagedCall("Uint8List", "Uint8List");
		m.put("address", address);
		m.put("size", (int64)size);
		shptr<class Uint8List> result;
		m.check(m.call(result, true));
		return result;
	}

	int64 /*var-non-null*/ Color::value() {
		auto m = ManagedCall("Color", "value");
		m.put("this", this);
		int64 result;
		m.check(m.call(result));
		return result;
	}

	int64 /*get-non-null*/ Color::alpha() {
		auto m = ManagedCall("Color", "alpha");
		m.put("this", this);
		int64 result;
		m.check(m.call(result));
		return result;
	}

	double /*get-non-null*/ Color::opacity() {
		auto m = ManagedCall("Color", "opacity");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	int64 /*get-non-null*/ Color::red() {
		auto m = ManagedCall("Color", "red");
		m.put("this", this);
		int64 result;
		m.check(m.call(result));
		return result;
	}

	int64 /*get-non-null*/ Color::green() {
		auto m = ManagedCall("Color", "green");
		m.put("this", this);
		int64 result;
		m.check(m.call(result));
		return result;
	}

	int64 /*get-non-null*/ Color::blue() {
		auto m = ManagedCall("Color", "blue");
		m.put("this", this);
		int64 result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*non-null*/ Color::withAlpha(/*non-null*/ int64 a) {
		auto m = ManagedCall("Color", "withAlpha");
		m.put("this", this);
		m.put("a", a);
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*non-null*/ Color::withOpacity(/*non-null*/ double opacity) {
		auto m = ManagedCall("Color", "withOpacity");
		m.put("this", this);
		m.put("opacity", opacity);
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*non-null*/ Color::withRed(/*non-null*/ int64 r) {
		auto m = ManagedCall("Color", "withRed");
		m.put("this", this);
		m.put("r", r);
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*non-null*/ Color::withGreen(/*non-null*/ int64 g) {
		auto m = ManagedCall("Color", "withGreen");
		m.put("this", this);
		m.put("g", g);
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*non-null*/ Color::withBlue(/*non-null*/ int64 b) {
		auto m = ManagedCall("Color", "withBlue");
		m.put("this", this);
		m.put("b", b);
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	double /*non-null*/ Color::computeLuminance() {
		auto m = ManagedCall("Color", "computeLuminance");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*nullable*/ Color::lerp(/*nullable*/ shptr<class Color> a, /*nullable*/ shptr<class Color> b, /*non-null*/ double t) {
		auto m = ManagedCall("Color", "lerp");
		m.put("a", a);
		m.put("b", b);
		m.put("t", t);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*non-null*/ Color::alphaBlend(/*non-null*/ shptr<class Color> foreground, /*non-null*/ shptr<class Color> background) {
		auto m = ManagedCall("Color", "alphaBlend");
		m.put("foreground", foreground, true);
		m.put("background", background, true);
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	int64 /*non-null*/ Color::getAlphaFromOpacity(/*non-null*/ double opacity) {
		auto m = ManagedCall("Color", "getAlphaFromOpacity");
		m.put("opacity", opacity);
		int64 result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ Color::equals(/*non-null*/ shptr<class ObjBase> other) {
		auto m = ManagedCall("Color", "==");
		m.put("this", this);
		m.put("other", other, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*non-null*/ Color::ctorMain(/*non-null*/ int64 value) {
		auto m = ManagedCall("Color", "Color");
		m.put("value", value);
		shptr<class Color> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Color> /*non-null*/ Color::fromARGB(/*non-null*/ int64 a, /*non-null*/ int64 r, /*non-null*/ int64 g, /*non-null*/ int64 b) {
		auto m = ManagedCall("Color", "fromARGB");
		m.put("a", a);
		m.put("r", r);
		m.put("g", g);
		m.put("b", b);
		shptr<class Color> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Color> /*non-null*/ Color::fromRGBO(/*non-null*/ int64 r, /*non-null*/ int64 g, /*non-null*/ int64 b, /*non-null*/ double opacity) {
		auto m = ManagedCall("Color", "fromRGBO");
		m.put("r", r);
		m.put("g", g);
		m.put("b", b);
		m.put("opacity", opacity);
		shptr<class Color> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Color> /*get-non-null*/ MaterialColor::shade50() {
		auto m = ManagedCall("MaterialColor", "shade50");
		m.put("this", this);
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*get-non-null*/ MaterialColor::shade100() {
		auto m = ManagedCall("MaterialColor", "shade100");
		m.put("this", this);
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*get-non-null*/ MaterialColor::shade200() {
		auto m = ManagedCall("MaterialColor", "shade200");
		m.put("this", this);
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*get-non-null*/ MaterialColor::shade300() {
		auto m = ManagedCall("MaterialColor", "shade300");
		m.put("this", this);
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*get-non-null*/ MaterialColor::shade400() {
		auto m = ManagedCall("MaterialColor", "shade400");
		m.put("this", this);
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*get-non-null*/ MaterialColor::shade500() {
		auto m = ManagedCall("MaterialColor", "shade500");
		m.put("this", this);
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*get-non-null*/ MaterialColor::shade600() {
		auto m = ManagedCall("MaterialColor", "shade600");
		m.put("this", this);
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*get-non-null*/ MaterialColor::shade700() {
		auto m = ManagedCall("MaterialColor", "shade700");
		m.put("this", this);
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*get-non-null*/ MaterialColor::shade800() {
		auto m = ManagedCall("MaterialColor", "shade800");
		m.put("this", this);
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*get-non-null*/ MaterialColor::shade900() {
		auto m = ManagedCall("MaterialColor", "shade900");
		m.put("this", this);
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*get-non-null*/ MaterialAccentColor::shade100() {
		auto m = ManagedCall("MaterialAccentColor", "shade100");
		m.put("this", this);
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*get-non-null*/ MaterialAccentColor::shade200() {
		auto m = ManagedCall("MaterialAccentColor", "shade200");
		m.put("this", this);
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*get-non-null*/ MaterialAccentColor::shade400() {
		auto m = ManagedCall("MaterialAccentColor", "shade400");
		m.put("this", this);
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*get-non-null*/ MaterialAccentColor::shade700() {
		auto m = ManagedCall("MaterialAccentColor", "shade700");
		m.put("this", this);
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*var-non-null*/ Colors::transparent() {
		auto m = ManagedCall("Colors", "transparent");
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*var-non-null*/ Colors::black() {
		auto m = ManagedCall("Colors", "black");
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*var-non-null*/ Colors::black87() {
		auto m = ManagedCall("Colors", "black87");
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*var-non-null*/ Colors::black54() {
		auto m = ManagedCall("Colors", "black54");
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*var-non-null*/ Colors::black45() {
		auto m = ManagedCall("Colors", "black45");
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*var-non-null*/ Colors::black38() {
		auto m = ManagedCall("Colors", "black38");
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*var-non-null*/ Colors::black26() {
		auto m = ManagedCall("Colors", "black26");
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*var-non-null*/ Colors::black12() {
		auto m = ManagedCall("Colors", "black12");
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*var-non-null*/ Colors::white() {
		auto m = ManagedCall("Colors", "white");
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*var-non-null*/ Colors::white70() {
		auto m = ManagedCall("Colors", "white70");
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*var-non-null*/ Colors::white60() {
		auto m = ManagedCall("Colors", "white60");
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*var-non-null*/ Colors::white54() {
		auto m = ManagedCall("Colors", "white54");
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*var-non-null*/ Colors::white38() {
		auto m = ManagedCall("Colors", "white38");
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*var-non-null*/ Colors::white30() {
		auto m = ManagedCall("Colors", "white30");
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*var-non-null*/ Colors::white24() {
		auto m = ManagedCall("Colors", "white24");
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*var-non-null*/ Colors::white12() {
		auto m = ManagedCall("Colors", "white12");
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*var-non-null*/ Colors::white10() {
		auto m = ManagedCall("Colors", "white10");
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class MaterialColor> /*var-non-null*/ Colors::red() {
		auto m = ManagedCall("Colors", "red");
		shptr<class MaterialColor> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class MaterialAccentColor> /*var-non-null*/ Colors::redAccent() {
		auto m = ManagedCall("Colors", "redAccent");
		shptr<class MaterialAccentColor> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class MaterialColor> /*var-non-null*/ Colors::pink() {
		auto m = ManagedCall("Colors", "pink");
		shptr<class MaterialColor> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class MaterialAccentColor> /*var-non-null*/ Colors::pinkAccent() {
		auto m = ManagedCall("Colors", "pinkAccent");
		shptr<class MaterialAccentColor> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class MaterialColor> /*var-non-null*/ Colors::purple() {
		auto m = ManagedCall("Colors", "purple");
		shptr<class MaterialColor> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class MaterialAccentColor> /*var-non-null*/ Colors::purpleAccent() {
		auto m = ManagedCall("Colors", "purpleAccent");
		shptr<class MaterialAccentColor> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class MaterialColor> /*var-non-null*/ Colors::deepPurple() {
		auto m = ManagedCall("Colors", "deepPurple");
		shptr<class MaterialColor> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class MaterialAccentColor> /*var-non-null*/ Colors::deepPurpleAccent() {
		auto m = ManagedCall("Colors", "deepPurpleAccent");
		shptr<class MaterialAccentColor> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class MaterialColor> /*var-non-null*/ Colors::indigo() {
		auto m = ManagedCall("Colors", "indigo");
		shptr<class MaterialColor> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class MaterialAccentColor> /*var-non-null*/ Colors::indigoAccent() {
		auto m = ManagedCall("Colors", "indigoAccent");
		shptr<class MaterialAccentColor> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class MaterialColor> /*var-non-null*/ Colors::blue() {
		auto m = ManagedCall("Colors", "blue");
		shptr<class MaterialColor> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class MaterialAccentColor> /*var-non-null*/ Colors::blueAccent() {
		auto m = ManagedCall("Colors", "blueAccent");
		shptr<class MaterialAccentColor> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class MaterialColor> /*var-non-null*/ Colors::lightBlue() {
		auto m = ManagedCall("Colors", "lightBlue");
		shptr<class MaterialColor> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class MaterialAccentColor> /*var-non-null*/ Colors::lightBlueAccent() {
		auto m = ManagedCall("Colors", "lightBlueAccent");
		shptr<class MaterialAccentColor> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class MaterialColor> /*var-non-null*/ Colors::cyan() {
		auto m = ManagedCall("Colors", "cyan");
		shptr<class MaterialColor> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class MaterialAccentColor> /*var-non-null*/ Colors::cyanAccent() {
		auto m = ManagedCall("Colors", "cyanAccent");
		shptr<class MaterialAccentColor> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class MaterialColor> /*var-non-null*/ Colors::teal() {
		auto m = ManagedCall("Colors", "teal");
		shptr<class MaterialColor> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class MaterialAccentColor> /*var-non-null*/ Colors::tealAccent() {
		auto m = ManagedCall("Colors", "tealAccent");
		shptr<class MaterialAccentColor> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class MaterialColor> /*var-non-null*/ Colors::green() {
		auto m = ManagedCall("Colors", "green");
		shptr<class MaterialColor> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class MaterialAccentColor> /*var-non-null*/ Colors::greenAccent() {
		auto m = ManagedCall("Colors", "greenAccent");
		shptr<class MaterialAccentColor> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class MaterialColor> /*var-non-null*/ Colors::lightGreen() {
		auto m = ManagedCall("Colors", "lightGreen");
		shptr<class MaterialColor> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class MaterialAccentColor> /*var-non-null*/ Colors::lightGreenAccent() {
		auto m = ManagedCall("Colors", "lightGreenAccent");
		shptr<class MaterialAccentColor> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class MaterialColor> /*var-non-null*/ Colors::lime() {
		auto m = ManagedCall("Colors", "lime");
		shptr<class MaterialColor> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class MaterialAccentColor> /*var-non-null*/ Colors::limeAccent() {
		auto m = ManagedCall("Colors", "limeAccent");
		shptr<class MaterialAccentColor> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class MaterialColor> /*var-non-null*/ Colors::yellow() {
		auto m = ManagedCall("Colors", "yellow");
		shptr<class MaterialColor> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class MaterialAccentColor> /*var-non-null*/ Colors::yellowAccent() {
		auto m = ManagedCall("Colors", "yellowAccent");
		shptr<class MaterialAccentColor> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class MaterialColor> /*var-non-null*/ Colors::amber() {
		auto m = ManagedCall("Colors", "amber");
		shptr<class MaterialColor> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class MaterialAccentColor> /*var-non-null*/ Colors::amberAccent() {
		auto m = ManagedCall("Colors", "amberAccent");
		shptr<class MaterialAccentColor> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class MaterialColor> /*var-non-null*/ Colors::orange() {
		auto m = ManagedCall("Colors", "orange");
		shptr<class MaterialColor> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class MaterialAccentColor> /*var-non-null*/ Colors::orangeAccent() {
		auto m = ManagedCall("Colors", "orangeAccent");
		shptr<class MaterialAccentColor> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class MaterialColor> /*var-non-null*/ Colors::deepOrange() {
		auto m = ManagedCall("Colors", "deepOrange");
		shptr<class MaterialColor> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class MaterialAccentColor> /*var-non-null*/ Colors::deepOrangeAccent() {
		auto m = ManagedCall("Colors", "deepOrangeAccent");
		shptr<class MaterialAccentColor> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class MaterialColor> /*var-non-null*/ Colors::brown() {
		auto m = ManagedCall("Colors", "brown");
		shptr<class MaterialColor> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class MaterialColor> /*var-non-null*/ Colors::grey() {
		auto m = ManagedCall("Colors", "grey");
		shptr<class MaterialColor> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class MaterialColor> /*var-non-null*/ Colors::blueGrey() {
		auto m = ManagedCall("Colors", "blueGrey");
		shptr<class MaterialColor> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*var-non-null*/ CupertinoDynamicColor::color() {
		auto m = ManagedCall("CupertinoDynamicColor", "color");
		m.put("this", this);
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*var-non-null*/ CupertinoDynamicColor::darkColor() {
		auto m = ManagedCall("CupertinoDynamicColor", "darkColor");
		m.put("this", this);
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*var-non-null*/ CupertinoDynamicColor::highContrastColor() {
		auto m = ManagedCall("CupertinoDynamicColor", "highContrastColor");
		m.put("this", this);
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*var-non-null*/ CupertinoDynamicColor::darkHighContrastColor() {
		auto m = ManagedCall("CupertinoDynamicColor", "darkHighContrastColor");
		m.put("this", this);
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*var-non-null*/ CupertinoDynamicColor::elevatedColor() {
		auto m = ManagedCall("CupertinoDynamicColor", "elevatedColor");
		m.put("this", this);
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*var-non-null*/ CupertinoDynamicColor::darkElevatedColor() {
		auto m = ManagedCall("CupertinoDynamicColor", "darkElevatedColor");
		m.put("this", this);
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*var-non-null*/ CupertinoDynamicColor::highContrastElevatedColor() {
		auto m = ManagedCall("CupertinoDynamicColor", "highContrastElevatedColor");
		m.put("this", this);
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*var-non-null*/ CupertinoDynamicColor::darkHighContrastElevatedColor() {
		auto m = ManagedCall("CupertinoDynamicColor", "darkHighContrastElevatedColor");
		m.put("this", this);
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	int64 /*get-non-null*/ CupertinoDynamicColor::value() {
		auto m = ManagedCall("CupertinoDynamicColor", "value");
		m.put("this", this);
		int64 result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*non-null*/ CupertinoDynamicColor::resolve(/*non-null*/ shptr<class Color> resolvable, /*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("CupertinoDynamicColor", "resolve");
		m.put("resolvable", resolvable, true);
		m.put("context", context, true);
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*nullable*/ CupertinoDynamicColor::maybeResolve(/*nullable*/ shptr<class Color> resolvable, /*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("CupertinoDynamicColor", "maybeResolve");
		m.put("resolvable", resolvable);
		m.put("context", context, true);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class CupertinoDynamicColor> /*non-null*/ CupertinoDynamicColor::resolveFrom(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("CupertinoDynamicColor", "resolveFrom");
		m.put("this", this);
		m.put("context", context, true);
		shptr<class CupertinoDynamicColor> result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ CupertinoDynamicColor::equals(/*non-null*/ shptr<class ObjBase> other) {
		auto m = ManagedCall("CupertinoDynamicColor", "==");
		m.put("this", this);
		m.put("other", other, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class CupertinoDynamicColor> /*non-null*/ CupertinoDynamicColor::ctorMain(_ctorMain p) {
		auto m = ManagedCall("CupertinoDynamicColor", "CupertinoDynamicColor");
		m.put("debugLabel", p.debugLabel);
		m.put("color", p.color, true);
		m.put("darkColor", p.darkColor, true);
		m.put("highContrastColor", p.highContrastColor, true);
		m.put("darkHighContrastColor", p.darkHighContrastColor, true);
		m.put("elevatedColor", p.elevatedColor, true);
		m.put("darkElevatedColor", p.darkElevatedColor, true);
		m.put("highContrastElevatedColor", p.highContrastElevatedColor, true);
		m.put("darkHighContrastElevatedColor", p.darkHighContrastElevatedColor, true);
		shptr<class CupertinoDynamicColor> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class CupertinoDynamicColor> /*non-null*/ CupertinoDynamicColor::withBrightnessAndContrast(_withBrightnessAndContrast p) {
		auto m = ManagedCall("CupertinoDynamicColor", "withBrightnessAndContrast");
		m.put("debugLabel", p.debugLabel);
		m.put("color", p.color, true);
		m.put("darkColor", p.darkColor, true);
		m.put("highContrastColor", p.highContrastColor, true);
		m.put("darkHighContrastColor", p.darkHighContrastColor, true);
		shptr<class CupertinoDynamicColor> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class CupertinoDynamicColor> /*non-null*/ CupertinoDynamicColor::withBrightness(_withBrightness p) {
		auto m = ManagedCall("CupertinoDynamicColor", "withBrightness");
		m.put("debugLabel", p.debugLabel);
		m.put("color", p.color, true);
		m.put("darkColor", p.darkColor, true);
		shptr<class CupertinoDynamicColor> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class CupertinoDynamicColor> /*var-non-null*/ CupertinoColors::activeBlue() {
		auto m = ManagedCall("CupertinoColors", "activeBlue");
		shptr<class CupertinoDynamicColor> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class CupertinoDynamicColor> /*var-non-null*/ CupertinoColors::activeGreen() {
		auto m = ManagedCall("CupertinoColors", "activeGreen");
		shptr<class CupertinoDynamicColor> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class CupertinoDynamicColor> /*var-non-null*/ CupertinoColors::activeOrange() {
		auto m = ManagedCall("CupertinoColors", "activeOrange");
		shptr<class CupertinoDynamicColor> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*var-non-null*/ CupertinoColors::white() {
		auto m = ManagedCall("CupertinoColors", "white");
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*var-non-null*/ CupertinoColors::black() {
		auto m = ManagedCall("CupertinoColors", "black");
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*var-non-null*/ CupertinoColors::lightBackgroundGray() {
		auto m = ManagedCall("CupertinoColors", "lightBackgroundGray");
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*var-non-null*/ CupertinoColors::extraLightBackgroundGray() {
		auto m = ManagedCall("CupertinoColors", "extraLightBackgroundGray");
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*var-non-null*/ CupertinoColors::darkBackgroundGray() {
		auto m = ManagedCall("CupertinoColors", "darkBackgroundGray");
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class CupertinoDynamicColor> /*var-non-null*/ CupertinoColors::inactiveGray() {
		auto m = ManagedCall("CupertinoColors", "inactiveGray");
		shptr<class CupertinoDynamicColor> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*var-non-null*/ CupertinoColors::destructiveRed() {
		auto m = ManagedCall("CupertinoColors", "destructiveRed");
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class CupertinoDynamicColor> /*var-non-null*/ CupertinoColors::systemBlue() {
		auto m = ManagedCall("CupertinoColors", "systemBlue");
		shptr<class CupertinoDynamicColor> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class CupertinoDynamicColor> /*var-non-null*/ CupertinoColors::systemGreen() {
		auto m = ManagedCall("CupertinoColors", "systemGreen");
		shptr<class CupertinoDynamicColor> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class CupertinoDynamicColor> /*var-non-null*/ CupertinoColors::systemMint() {
		auto m = ManagedCall("CupertinoColors", "systemMint");
		shptr<class CupertinoDynamicColor> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class CupertinoDynamicColor> /*var-non-null*/ CupertinoColors::systemIndigo() {
		auto m = ManagedCall("CupertinoColors", "systemIndigo");
		shptr<class CupertinoDynamicColor> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class CupertinoDynamicColor> /*var-non-null*/ CupertinoColors::systemOrange() {
		auto m = ManagedCall("CupertinoColors", "systemOrange");
		shptr<class CupertinoDynamicColor> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class CupertinoDynamicColor> /*var-non-null*/ CupertinoColors::systemPink() {
		auto m = ManagedCall("CupertinoColors", "systemPink");
		shptr<class CupertinoDynamicColor> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class CupertinoDynamicColor> /*var-non-null*/ CupertinoColors::systemBrown() {
		auto m = ManagedCall("CupertinoColors", "systemBrown");
		shptr<class CupertinoDynamicColor> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class CupertinoDynamicColor> /*var-non-null*/ CupertinoColors::systemPurple() {
		auto m = ManagedCall("CupertinoColors", "systemPurple");
		shptr<class CupertinoDynamicColor> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class CupertinoDynamicColor> /*var-non-null*/ CupertinoColors::systemRed() {
		auto m = ManagedCall("CupertinoColors", "systemRed");
		shptr<class CupertinoDynamicColor> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class CupertinoDynamicColor> /*var-non-null*/ CupertinoColors::systemTeal() {
		auto m = ManagedCall("CupertinoColors", "systemTeal");
		shptr<class CupertinoDynamicColor> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class CupertinoDynamicColor> /*var-non-null*/ CupertinoColors::systemCyan() {
		auto m = ManagedCall("CupertinoColors", "systemCyan");
		shptr<class CupertinoDynamicColor> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class CupertinoDynamicColor> /*var-non-null*/ CupertinoColors::systemYellow() {
		auto m = ManagedCall("CupertinoColors", "systemYellow");
		shptr<class CupertinoDynamicColor> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class CupertinoDynamicColor> /*var-non-null*/ CupertinoColors::systemGrey() {
		auto m = ManagedCall("CupertinoColors", "systemGrey");
		shptr<class CupertinoDynamicColor> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class CupertinoDynamicColor> /*var-non-null*/ CupertinoColors::systemGrey2() {
		auto m = ManagedCall("CupertinoColors", "systemGrey2");
		shptr<class CupertinoDynamicColor> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class CupertinoDynamicColor> /*var-non-null*/ CupertinoColors::systemGrey3() {
		auto m = ManagedCall("CupertinoColors", "systemGrey3");
		shptr<class CupertinoDynamicColor> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class CupertinoDynamicColor> /*var-non-null*/ CupertinoColors::systemGrey4() {
		auto m = ManagedCall("CupertinoColors", "systemGrey4");
		shptr<class CupertinoDynamicColor> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class CupertinoDynamicColor> /*var-non-null*/ CupertinoColors::systemGrey5() {
		auto m = ManagedCall("CupertinoColors", "systemGrey5");
		shptr<class CupertinoDynamicColor> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class CupertinoDynamicColor> /*var-non-null*/ CupertinoColors::systemGrey6() {
		auto m = ManagedCall("CupertinoColors", "systemGrey6");
		shptr<class CupertinoDynamicColor> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class CupertinoDynamicColor> /*var-non-null*/ CupertinoColors::label() {
		auto m = ManagedCall("CupertinoColors", "label");
		shptr<class CupertinoDynamicColor> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class CupertinoDynamicColor> /*var-non-null*/ CupertinoColors::secondaryLabel() {
		auto m = ManagedCall("CupertinoColors", "secondaryLabel");
		shptr<class CupertinoDynamicColor> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class CupertinoDynamicColor> /*var-non-null*/ CupertinoColors::tertiaryLabel() {
		auto m = ManagedCall("CupertinoColors", "tertiaryLabel");
		shptr<class CupertinoDynamicColor> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class CupertinoDynamicColor> /*var-non-null*/ CupertinoColors::quaternaryLabel() {
		auto m = ManagedCall("CupertinoColors", "quaternaryLabel");
		shptr<class CupertinoDynamicColor> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class CupertinoDynamicColor> /*var-non-null*/ CupertinoColors::systemFill() {
		auto m = ManagedCall("CupertinoColors", "systemFill");
		shptr<class CupertinoDynamicColor> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class CupertinoDynamicColor> /*var-non-null*/ CupertinoColors::secondarySystemFill() {
		auto m = ManagedCall("CupertinoColors", "secondarySystemFill");
		shptr<class CupertinoDynamicColor> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class CupertinoDynamicColor> /*var-non-null*/ CupertinoColors::tertiarySystemFill() {
		auto m = ManagedCall("CupertinoColors", "tertiarySystemFill");
		shptr<class CupertinoDynamicColor> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class CupertinoDynamicColor> /*var-non-null*/ CupertinoColors::quaternarySystemFill() {
		auto m = ManagedCall("CupertinoColors", "quaternarySystemFill");
		shptr<class CupertinoDynamicColor> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class CupertinoDynamicColor> /*var-non-null*/ CupertinoColors::placeholderText() {
		auto m = ManagedCall("CupertinoColors", "placeholderText");
		shptr<class CupertinoDynamicColor> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class CupertinoDynamicColor> /*var-non-null*/ CupertinoColors::systemBackground() {
		auto m = ManagedCall("CupertinoColors", "systemBackground");
		shptr<class CupertinoDynamicColor> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class CupertinoDynamicColor> /*var-non-null*/ CupertinoColors::secondarySystemBackground() {
		auto m = ManagedCall("CupertinoColors", "secondarySystemBackground");
		shptr<class CupertinoDynamicColor> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class CupertinoDynamicColor> /*var-non-null*/ CupertinoColors::tertiarySystemBackground() {
		auto m = ManagedCall("CupertinoColors", "tertiarySystemBackground");
		shptr<class CupertinoDynamicColor> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class CupertinoDynamicColor> /*var-non-null*/ CupertinoColors::systemGroupedBackground() {
		auto m = ManagedCall("CupertinoColors", "systemGroupedBackground");
		shptr<class CupertinoDynamicColor> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class CupertinoDynamicColor> /*var-non-null*/ CupertinoColors::secondarySystemGroupedBackground() {
		auto m = ManagedCall("CupertinoColors", "secondarySystemGroupedBackground");
		shptr<class CupertinoDynamicColor> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class CupertinoDynamicColor> /*var-non-null*/ CupertinoColors::tertiarySystemGroupedBackground() {
		auto m = ManagedCall("CupertinoColors", "tertiarySystemGroupedBackground");
		shptr<class CupertinoDynamicColor> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class CupertinoDynamicColor> /*var-non-null*/ CupertinoColors::separator() {
		auto m = ManagedCall("CupertinoColors", "separator");
		shptr<class CupertinoDynamicColor> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class CupertinoDynamicColor> /*var-non-null*/ CupertinoColors::opaqueSeparator() {
		auto m = ManagedCall("CupertinoColors", "opaqueSeparator");
		shptr<class CupertinoDynamicColor> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class CupertinoDynamicColor> /*var-non-null*/ CupertinoColors::link() {
		auto m = ManagedCall("CupertinoColors", "link");
		shptr<class CupertinoDynamicColor> result;
		m.check(m.call(result));
		return result;
	}

	Brightness /*var-non-null*/ ColorScheme::brightness() {
		auto m = ManagedCall("ColorScheme", "brightness");
		m.put("this", this);
		Brightness result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*var-non-null*/ ColorScheme::primary() {
		auto m = ManagedCall("ColorScheme", "primary");
		m.put("this", this);
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*var-non-null*/ ColorScheme::onPrimary() {
		auto m = ManagedCall("ColorScheme", "onPrimary");
		m.put("this", this);
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*var-non-null*/ ColorScheme::secondary() {
		auto m = ManagedCall("ColorScheme", "secondary");
		m.put("this", this);
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*var-non-null*/ ColorScheme::onSecondary() {
		auto m = ManagedCall("ColorScheme", "onSecondary");
		m.put("this", this);
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*var-non-null*/ ColorScheme::error() {
		auto m = ManagedCall("ColorScheme", "error");
		m.put("this", this);
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*var-non-null*/ ColorScheme::onError() {
		auto m = ManagedCall("ColorScheme", "onError");
		m.put("this", this);
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*var-non-null*/ ColorScheme::background() {
		auto m = ManagedCall("ColorScheme", "background");
		m.put("this", this);
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*var-non-null*/ ColorScheme::onBackground() {
		auto m = ManagedCall("ColorScheme", "onBackground");
		m.put("this", this);
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*var-non-null*/ ColorScheme::surface() {
		auto m = ManagedCall("ColorScheme", "surface");
		m.put("this", this);
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*var-non-null*/ ColorScheme::onSurface() {
		auto m = ManagedCall("ColorScheme", "onSurface");
		m.put("this", this);
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*get-non-null*/ ColorScheme::primaryContainer() {
		auto m = ManagedCall("ColorScheme", "primaryContainer");
		m.put("this", this);
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*get-non-null*/ ColorScheme::onPrimaryContainer() {
		auto m = ManagedCall("ColorScheme", "onPrimaryContainer");
		m.put("this", this);
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*get-non-null*/ ColorScheme::secondaryContainer() {
		auto m = ManagedCall("ColorScheme", "secondaryContainer");
		m.put("this", this);
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*get-non-null*/ ColorScheme::onSecondaryContainer() {
		auto m = ManagedCall("ColorScheme", "onSecondaryContainer");
		m.put("this", this);
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*get-non-null*/ ColorScheme::tertiary() {
		auto m = ManagedCall("ColorScheme", "tertiary");
		m.put("this", this);
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*get-non-null*/ ColorScheme::onTertiary() {
		auto m = ManagedCall("ColorScheme", "onTertiary");
		m.put("this", this);
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*get-non-null*/ ColorScheme::tertiaryContainer() {
		auto m = ManagedCall("ColorScheme", "tertiaryContainer");
		m.put("this", this);
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*get-non-null*/ ColorScheme::onTertiaryContainer() {
		auto m = ManagedCall("ColorScheme", "onTertiaryContainer");
		m.put("this", this);
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*get-non-null*/ ColorScheme::errorContainer() {
		auto m = ManagedCall("ColorScheme", "errorContainer");
		m.put("this", this);
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*get-non-null*/ ColorScheme::onErrorContainer() {
		auto m = ManagedCall("ColorScheme", "onErrorContainer");
		m.put("this", this);
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*get-non-null*/ ColorScheme::surfaceVariant() {
		auto m = ManagedCall("ColorScheme", "surfaceVariant");
		m.put("this", this);
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*get-non-null*/ ColorScheme::onSurfaceVariant() {
		auto m = ManagedCall("ColorScheme", "onSurfaceVariant");
		m.put("this", this);
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*get-non-null*/ ColorScheme::outline() {
		auto m = ManagedCall("ColorScheme", "outline");
		m.put("this", this);
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*get-non-null*/ ColorScheme::outlineVariant() {
		auto m = ManagedCall("ColorScheme", "outlineVariant");
		m.put("this", this);
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*get-non-null*/ ColorScheme::shadow() {
		auto m = ManagedCall("ColorScheme", "shadow");
		m.put("this", this);
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*get-non-null*/ ColorScheme::scrim() {
		auto m = ManagedCall("ColorScheme", "scrim");
		m.put("this", this);
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*get-non-null*/ ColorScheme::inverseSurface() {
		auto m = ManagedCall("ColorScheme", "inverseSurface");
		m.put("this", this);
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*get-non-null*/ ColorScheme::onInverseSurface() {
		auto m = ManagedCall("ColorScheme", "onInverseSurface");
		m.put("this", this);
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*get-non-null*/ ColorScheme::inversePrimary() {
		auto m = ManagedCall("ColorScheme", "inversePrimary");
		m.put("this", this);
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*get-non-null*/ ColorScheme::surfaceTint() {
		auto m = ManagedCall("ColorScheme", "surfaceTint");
		m.put("this", this);
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ColorScheme> /*non-null*/ ColorScheme::copyWith(_copyWith p) {
		auto m = ManagedCall("ColorScheme", "copyWith");
		m.put("this", this);
		m.put("brightness", p.brightness);
		m.put("primary", p.primary);
		m.put("onPrimary", p.onPrimary);
		m.put("primaryContainer", p.primaryContainer);
		m.put("onPrimaryContainer", p.onPrimaryContainer);
		m.put("secondary", p.secondary);
		m.put("onSecondary", p.onSecondary);
		m.put("secondaryContainer", p.secondaryContainer);
		m.put("onSecondaryContainer", p.onSecondaryContainer);
		m.put("tertiary", p.tertiary);
		m.put("onTertiary", p.onTertiary);
		m.put("tertiaryContainer", p.tertiaryContainer);
		m.put("onTertiaryContainer", p.onTertiaryContainer);
		m.put("error", p.error);
		m.put("onError", p.onError);
		m.put("errorContainer", p.errorContainer);
		m.put("onErrorContainer", p.onErrorContainer);
		m.put("background", p.background);
		m.put("onBackground", p.onBackground);
		m.put("surface", p.surface);
		m.put("onSurface", p.onSurface);
		m.put("surfaceVariant", p.surfaceVariant);
		m.put("onSurfaceVariant", p.onSurfaceVariant);
		m.put("outline", p.outline);
		m.put("outlineVariant", p.outlineVariant);
		m.put("shadow", p.shadow);
		m.put("scrim", p.scrim);
		m.put("inverseSurface", p.inverseSurface);
		m.put("onInverseSurface", p.onInverseSurface);
		m.put("inversePrimary", p.inversePrimary);
		m.put("surfaceTint", p.surfaceTint);
		shptr<class ColorScheme> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ColorScheme> /*non-null*/ ColorScheme::lerp(/*non-null*/ shptr<class ColorScheme> a, /*non-null*/ shptr<class ColorScheme> b, /*non-null*/ double t) {
		auto m = ManagedCall("ColorScheme", "lerp");
		m.put("a", a, true);
		m.put("b", b, true);
		m.put("t", t);
		shptr<class ColorScheme> result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ ColorScheme::equals(/*non-null*/ shptr<class ObjBase> other) {
		auto m = ManagedCall("ColorScheme", "==");
		m.put("this", this);
		m.put("other", other, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ColorScheme> /*non-null*/ ColorScheme::ctorMain(_ctorMain p) {
		auto m = ManagedCall("ColorScheme", "ColorScheme");
		m.put("brightness", p.brightness);
		m.put("primary", p.primary, true);
		m.put("onPrimary", p.onPrimary, true);
		m.put("primaryContainer", p.primaryContainer);
		m.put("onPrimaryContainer", p.onPrimaryContainer);
		m.put("secondary", p.secondary, true);
		m.put("onSecondary", p.onSecondary, true);
		m.put("secondaryContainer", p.secondaryContainer);
		m.put("onSecondaryContainer", p.onSecondaryContainer);
		m.put("tertiary", p.tertiary);
		m.put("onTertiary", p.onTertiary);
		m.put("tertiaryContainer", p.tertiaryContainer);
		m.put("onTertiaryContainer", p.onTertiaryContainer);
		m.put("error", p.error, true);
		m.put("onError", p.onError, true);
		m.put("errorContainer", p.errorContainer);
		m.put("onErrorContainer", p.onErrorContainer);
		m.put("background", p.background, true);
		m.put("onBackground", p.onBackground, true);
		m.put("surface", p.surface, true);
		m.put("onSurface", p.onSurface, true);
		m.put("surfaceVariant", p.surfaceVariant);
		m.put("onSurfaceVariant", p.onSurfaceVariant);
		m.put("outline", p.outline);
		m.put("outlineVariant", p.outlineVariant);
		m.put("shadow", p.shadow);
		m.put("scrim", p.scrim);
		m.put("inverseSurface", p.inverseSurface);
		m.put("onInverseSurface", p.onInverseSurface);
		m.put("inversePrimary", p.inversePrimary);
		m.put("surfaceTint", p.surfaceTint);
		shptr<class ColorScheme> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class ColorScheme> /*non-null*/ ColorScheme::light(_light p) {
		auto m = ManagedCall("ColorScheme", "light");
		m.put("brightness", p.brightness);
		m.put("primary", p.primary, true);
		m.put("onPrimary", p.onPrimary, true);
		m.put("primaryContainer", p.primaryContainer);
		m.put("onPrimaryContainer", p.onPrimaryContainer);
		m.put("secondary", p.secondary, true);
		m.put("onSecondary", p.onSecondary, true);
		m.put("secondaryContainer", p.secondaryContainer);
		m.put("onSecondaryContainer", p.onSecondaryContainer);
		m.put("tertiary", p.tertiary);
		m.put("onTertiary", p.onTertiary);
		m.put("tertiaryContainer", p.tertiaryContainer);
		m.put("onTertiaryContainer", p.onTertiaryContainer);
		m.put("error", p.error, true);
		m.put("onError", p.onError, true);
		m.put("errorContainer", p.errorContainer);
		m.put("onErrorContainer", p.onErrorContainer);
		m.put("background", p.background, true);
		m.put("onBackground", p.onBackground, true);
		m.put("surface", p.surface, true);
		m.put("onSurface", p.onSurface, true);
		m.put("surfaceVariant", p.surfaceVariant);
		m.put("onSurfaceVariant", p.onSurfaceVariant);
		m.put("outline", p.outline);
		m.put("outlineVariant", p.outlineVariant);
		m.put("shadow", p.shadow);
		m.put("scrim", p.scrim);
		m.put("inverseSurface", p.inverseSurface);
		m.put("onInverseSurface", p.onInverseSurface);
		m.put("inversePrimary", p.inversePrimary);
		m.put("surfaceTint", p.surfaceTint);
		shptr<class ColorScheme> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class ColorScheme> /*non-null*/ ColorScheme::dark(_dark p) {
		auto m = ManagedCall("ColorScheme", "dark");
		m.put("brightness", p.brightness);
		m.put("primary", p.primary, true);
		m.put("onPrimary", p.onPrimary, true);
		m.put("primaryContainer", p.primaryContainer);
		m.put("onPrimaryContainer", p.onPrimaryContainer);
		m.put("secondary", p.secondary, true);
		m.put("onSecondary", p.onSecondary, true);
		m.put("secondaryContainer", p.secondaryContainer);
		m.put("onSecondaryContainer", p.onSecondaryContainer);
		m.put("tertiary", p.tertiary);
		m.put("onTertiary", p.onTertiary);
		m.put("tertiaryContainer", p.tertiaryContainer);
		m.put("onTertiaryContainer", p.onTertiaryContainer);
		m.put("error", p.error, true);
		m.put("onError", p.onError, true);
		m.put("errorContainer", p.errorContainer);
		m.put("onErrorContainer", p.onErrorContainer);
		m.put("background", p.background, true);
		m.put("onBackground", p.onBackground, true);
		m.put("surface", p.surface, true);
		m.put("onSurface", p.onSurface, true);
		m.put("surfaceVariant", p.surfaceVariant);
		m.put("onSurfaceVariant", p.onSurfaceVariant);
		m.put("outline", p.outline);
		m.put("outlineVariant", p.outlineVariant);
		m.put("shadow", p.shadow);
		m.put("scrim", p.scrim);
		m.put("inverseSurface", p.inverseSurface);
		m.put("onInverseSurface", p.onInverseSurface);
		m.put("inversePrimary", p.inversePrimary);
		m.put("surfaceTint", p.surfaceTint);
		shptr<class ColorScheme> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class ColorScheme> /*non-null*/ ColorScheme::highContrastLight(_highContrastLight p) {
		auto m = ManagedCall("ColorScheme", "highContrastLight");
		m.put("brightness", p.brightness);
		m.put("primary", p.primary, true);
		m.put("onPrimary", p.onPrimary, true);
		m.put("primaryContainer", p.primaryContainer);
		m.put("onPrimaryContainer", p.onPrimaryContainer);
		m.put("secondary", p.secondary, true);
		m.put("onSecondary", p.onSecondary, true);
		m.put("secondaryContainer", p.secondaryContainer);
		m.put("onSecondaryContainer", p.onSecondaryContainer);
		m.put("tertiary", p.tertiary);
		m.put("onTertiary", p.onTertiary);
		m.put("tertiaryContainer", p.tertiaryContainer);
		m.put("onTertiaryContainer", p.onTertiaryContainer);
		m.put("error", p.error, true);
		m.put("onError", p.onError, true);
		m.put("errorContainer", p.errorContainer);
		m.put("onErrorContainer", p.onErrorContainer);
		m.put("background", p.background, true);
		m.put("onBackground", p.onBackground, true);
		m.put("surface", p.surface, true);
		m.put("onSurface", p.onSurface, true);
		m.put("surfaceVariant", p.surfaceVariant);
		m.put("onSurfaceVariant", p.onSurfaceVariant);
		m.put("outline", p.outline);
		m.put("outlineVariant", p.outlineVariant);
		m.put("shadow", p.shadow);
		m.put("scrim", p.scrim);
		m.put("inverseSurface", p.inverseSurface);
		m.put("onInverseSurface", p.onInverseSurface);
		m.put("inversePrimary", p.inversePrimary);
		m.put("surfaceTint", p.surfaceTint);
		shptr<class ColorScheme> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class ColorScheme> /*non-null*/ ColorScheme::highContrastDark(_highContrastDark p) {
		auto m = ManagedCall("ColorScheme", "highContrastDark");
		m.put("brightness", p.brightness);
		m.put("primary", p.primary, true);
		m.put("onPrimary", p.onPrimary, true);
		m.put("primaryContainer", p.primaryContainer);
		m.put("onPrimaryContainer", p.onPrimaryContainer);
		m.put("secondary", p.secondary, true);
		m.put("onSecondary", p.onSecondary, true);
		m.put("secondaryContainer", p.secondaryContainer);
		m.put("onSecondaryContainer", p.onSecondaryContainer);
		m.put("tertiary", p.tertiary);
		m.put("onTertiary", p.onTertiary);
		m.put("tertiaryContainer", p.tertiaryContainer);
		m.put("onTertiaryContainer", p.onTertiaryContainer);
		m.put("error", p.error, true);
		m.put("onError", p.onError, true);
		m.put("errorContainer", p.errorContainer);
		m.put("onErrorContainer", p.onErrorContainer);
		m.put("background", p.background, true);
		m.put("onBackground", p.onBackground, true);
		m.put("surface", p.surface, true);
		m.put("onSurface", p.onSurface, true);
		m.put("surfaceVariant", p.surfaceVariant);
		m.put("onSurfaceVariant", p.onSurfaceVariant);
		m.put("outline", p.outline);
		m.put("outlineVariant", p.outlineVariant);
		m.put("shadow", p.shadow);
		m.put("scrim", p.scrim);
		m.put("inverseSurface", p.inverseSurface);
		m.put("onInverseSurface", p.onInverseSurface);
		m.put("inversePrimary", p.inversePrimary);
		m.put("surfaceTint", p.surfaceTint);
		shptr<class ColorScheme> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class ColorScheme> /*non-null*/ ColorScheme::fromSeed(_fromSeed p) {
		auto m = ManagedCall("ColorScheme", "fromSeed");
		m.put("seedColor", p.seedColor, true);
		m.put("brightness", p.brightness);
		m.put("primary", p.primary);
		m.put("onPrimary", p.onPrimary);
		m.put("primaryContainer", p.primaryContainer);
		m.put("onPrimaryContainer", p.onPrimaryContainer);
		m.put("secondary", p.secondary);
		m.put("onSecondary", p.onSecondary);
		m.put("secondaryContainer", p.secondaryContainer);
		m.put("onSecondaryContainer", p.onSecondaryContainer);
		m.put("tertiary", p.tertiary);
		m.put("onTertiary", p.onTertiary);
		m.put("tertiaryContainer", p.tertiaryContainer);
		m.put("onTertiaryContainer", p.onTertiaryContainer);
		m.put("error", p.error);
		m.put("onError", p.onError);
		m.put("errorContainer", p.errorContainer);
		m.put("onErrorContainer", p.onErrorContainer);
		m.put("outline", p.outline);
		m.put("outlineVariant", p.outlineVariant);
		m.put("background", p.background);
		m.put("onBackground", p.onBackground);
		m.put("surface", p.surface);
		m.put("onSurface", p.onSurface);
		m.put("surfaceVariant", p.surfaceVariant);
		m.put("onSurfaceVariant", p.onSurfaceVariant);
		m.put("inverseSurface", p.inverseSurface);
		m.put("onInverseSurface", p.onInverseSurface);
		m.put("inversePrimary", p.inversePrimary);
		m.put("shadow", p.shadow);
		m.put("scrim", p.scrim);
		m.put("surfaceTint", p.surfaceTint);
		shptr<class ColorScheme> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class ColorScheme> /*non-null*/ ColorScheme::fromSwatch(_fromSwatch p) {
		auto m = ManagedCall("ColorScheme", "fromSwatch");
		m.put("primarySwatch", p.primarySwatch, true);
		m.put("accentColor", p.accentColor);
		m.put("cardColor", p.cardColor);
		m.put("backgroundColor", p.backgroundColor);
		m.put("errorColor", p.errorColor);
		m.put("brightness", p.brightness);
		shptr<class ColorScheme> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Curve> /*var-non-null*/ Curves::linear() {
		auto m = ManagedCall("Curves", "linear");
		shptr<class Curve> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Curve> /*var-non-null*/ Curves::decelerate() {
		auto m = ManagedCall("Curves", "decelerate");
		shptr<class Curve> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Cubic> /*var-non-null*/ Curves::fastLinearToSlowEaseIn() {
		auto m = ManagedCall("Curves", "fastLinearToSlowEaseIn");
		shptr<class Cubic> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ThreePointCubic> /*var-non-null*/ Curves::fastEaseInToSlowEaseOut() {
		auto m = ManagedCall("Curves", "fastEaseInToSlowEaseOut");
		shptr<class ThreePointCubic> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Cubic> /*var-non-null*/ Curves::ease() {
		auto m = ManagedCall("Curves", "ease");
		shptr<class Cubic> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Cubic> /*var-non-null*/ Curves::easeIn() {
		auto m = ManagedCall("Curves", "easeIn");
		shptr<class Cubic> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Cubic> /*var-non-null*/ Curves::easeInToLinear() {
		auto m = ManagedCall("Curves", "easeInToLinear");
		shptr<class Cubic> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Cubic> /*var-non-null*/ Curves::easeInSine() {
		auto m = ManagedCall("Curves", "easeInSine");
		shptr<class Cubic> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Cubic> /*var-non-null*/ Curves::easeInQuad() {
		auto m = ManagedCall("Curves", "easeInQuad");
		shptr<class Cubic> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Cubic> /*var-non-null*/ Curves::easeInCubic() {
		auto m = ManagedCall("Curves", "easeInCubic");
		shptr<class Cubic> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Cubic> /*var-non-null*/ Curves::easeInQuart() {
		auto m = ManagedCall("Curves", "easeInQuart");
		shptr<class Cubic> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Cubic> /*var-non-null*/ Curves::easeInQuint() {
		auto m = ManagedCall("Curves", "easeInQuint");
		shptr<class Cubic> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Cubic> /*var-non-null*/ Curves::easeInExpo() {
		auto m = ManagedCall("Curves", "easeInExpo");
		shptr<class Cubic> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Cubic> /*var-non-null*/ Curves::easeInCirc() {
		auto m = ManagedCall("Curves", "easeInCirc");
		shptr<class Cubic> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Cubic> /*var-non-null*/ Curves::easeInBack() {
		auto m = ManagedCall("Curves", "easeInBack");
		shptr<class Cubic> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Cubic> /*var-non-null*/ Curves::easeOut() {
		auto m = ManagedCall("Curves", "easeOut");
		shptr<class Cubic> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Cubic> /*var-non-null*/ Curves::linearToEaseOut() {
		auto m = ManagedCall("Curves", "linearToEaseOut");
		shptr<class Cubic> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Cubic> /*var-non-null*/ Curves::easeOutSine() {
		auto m = ManagedCall("Curves", "easeOutSine");
		shptr<class Cubic> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Cubic> /*var-non-null*/ Curves::easeOutQuad() {
		auto m = ManagedCall("Curves", "easeOutQuad");
		shptr<class Cubic> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Cubic> /*var-non-null*/ Curves::easeOutCubic() {
		auto m = ManagedCall("Curves", "easeOutCubic");
		shptr<class Cubic> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Cubic> /*var-non-null*/ Curves::easeOutQuart() {
		auto m = ManagedCall("Curves", "easeOutQuart");
		shptr<class Cubic> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Cubic> /*var-non-null*/ Curves::easeOutQuint() {
		auto m = ManagedCall("Curves", "easeOutQuint");
		shptr<class Cubic> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Cubic> /*var-non-null*/ Curves::easeOutExpo() {
		auto m = ManagedCall("Curves", "easeOutExpo");
		shptr<class Cubic> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Cubic> /*var-non-null*/ Curves::easeOutCirc() {
		auto m = ManagedCall("Curves", "easeOutCirc");
		shptr<class Cubic> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Cubic> /*var-non-null*/ Curves::easeOutBack() {
		auto m = ManagedCall("Curves", "easeOutBack");
		shptr<class Cubic> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Cubic> /*var-non-null*/ Curves::easeInOut() {
		auto m = ManagedCall("Curves", "easeInOut");
		shptr<class Cubic> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Cubic> /*var-non-null*/ Curves::easeInOutSine() {
		auto m = ManagedCall("Curves", "easeInOutSine");
		shptr<class Cubic> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Cubic> /*var-non-null*/ Curves::easeInOutQuad() {
		auto m = ManagedCall("Curves", "easeInOutQuad");
		shptr<class Cubic> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Cubic> /*var-non-null*/ Curves::easeInOutCubic() {
		auto m = ManagedCall("Curves", "easeInOutCubic");
		shptr<class Cubic> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ThreePointCubic> /*var-non-null*/ Curves::easeInOutCubicEmphasized() {
		auto m = ManagedCall("Curves", "easeInOutCubicEmphasized");
		shptr<class ThreePointCubic> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Cubic> /*var-non-null*/ Curves::easeInOutQuart() {
		auto m = ManagedCall("Curves", "easeInOutQuart");
		shptr<class Cubic> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Cubic> /*var-non-null*/ Curves::easeInOutQuint() {
		auto m = ManagedCall("Curves", "easeInOutQuint");
		shptr<class Cubic> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Cubic> /*var-non-null*/ Curves::easeInOutExpo() {
		auto m = ManagedCall("Curves", "easeInOutExpo");
		shptr<class Cubic> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Cubic> /*var-non-null*/ Curves::easeInOutCirc() {
		auto m = ManagedCall("Curves", "easeInOutCirc");
		shptr<class Cubic> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Cubic> /*var-non-null*/ Curves::easeInOutBack() {
		auto m = ManagedCall("Curves", "easeInOutBack");
		shptr<class Cubic> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Cubic> /*var-non-null*/ Curves::fastOutSlowIn() {
		auto m = ManagedCall("Curves", "fastOutSlowIn");
		shptr<class Cubic> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Cubic> /*var-non-null*/ Curves::slowMiddle() {
		auto m = ManagedCall("Curves", "slowMiddle");
		shptr<class Cubic> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Curve> /*var-non-null*/ Curves::bounceIn() {
		auto m = ManagedCall("Curves", "bounceIn");
		shptr<class Curve> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Curve> /*var-non-null*/ Curves::bounceOut() {
		auto m = ManagedCall("Curves", "bounceOut");
		shptr<class Curve> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Curve> /*var-non-null*/ Curves::bounceInOut() {
		auto m = ManagedCall("Curves", "bounceInOut");
		shptr<class Curve> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ElasticInCurve> /*var-non-null*/ Curves::elasticIn() {
		auto m = ManagedCall("Curves", "elasticIn");
		shptr<class ElasticInCurve> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ElasticOutCurve> /*var-non-null*/ Curves::elasticOut() {
		auto m = ManagedCall("Curves", "elasticOut");
		shptr<class ElasticOutCurve> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ElasticInOutCurve> /*var-non-null*/ Curves::elasticInOut() {
		auto m = ManagedCall("Curves", "elasticInOut");
		shptr<class ElasticInOutCurve> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class AlignmentGeometry> /*non-null*/ AlignmentGeometry::add(/*non-null*/ shptr<class AlignmentGeometry> other) {
		auto m = ManagedCall("AlignmentGeometry", "add");
		m.put("this", this);
		m.put("other", other, true);
		shptr<class AlignmentGeometry> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class AlignmentGeometry> /*non-null*/ AlignmentGeometry::neg() {
		auto m = ManagedCall("AlignmentGeometry", "unary-");
		m.put("this", this);
		shptr<class AlignmentGeometry> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class AlignmentGeometry> /*non-null*/ AlignmentGeometry::mul(/*non-null*/ double other) {
		auto m = ManagedCall("AlignmentGeometry", "*");
		m.put("this", this);
		m.put("other", other);
		shptr<class AlignmentGeometry> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class AlignmentGeometry> /*non-null*/ AlignmentGeometry::div(/*non-null*/ double other) {
		auto m = ManagedCall("AlignmentGeometry", "/");
		m.put("this", this);
		m.put("other", other);
		shptr<class AlignmentGeometry> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class AlignmentGeometry> /*non-null*/ AlignmentGeometry::idiv(/*non-null*/ double other) {
		auto m = ManagedCall("AlignmentGeometry", "~/");
		m.put("this", this);
		m.put("other", other);
		shptr<class AlignmentGeometry> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class AlignmentGeometry> /*non-null*/ AlignmentGeometry::mod(/*non-null*/ double other) {
		auto m = ManagedCall("AlignmentGeometry", "%");
		m.put("this", this);
		m.put("other", other);
		shptr<class AlignmentGeometry> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class AlignmentGeometry> /*nullable*/ AlignmentGeometry::lerp(/*nullable*/ shptr<class AlignmentGeometry> a, /*nullable*/ shptr<class AlignmentGeometry> b, /*non-null*/ double t) {
		auto m = ManagedCall("AlignmentGeometry", "lerp");
		m.put("a", a);
		m.put("b", b);
		m.put("t", t);
		shptr<class AlignmentGeometry> result;
		m.call(result);
		return result;
	}

	shptr<class Alignment> /*non-null*/ AlignmentGeometry::resolve(/*nullable*/ stdop<TextDirection> direction) {
		auto m = ManagedCall("AlignmentGeometry", "resolve");
		m.put("this", this);
		m.put("direction", direction);
		shptr<class Alignment> result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ AlignmentGeometry::equals(/*non-null*/ shptr<class ObjBase> other) {
		auto m = ManagedCall("AlignmentGeometry", "==");
		m.put("this", this);
		m.put("other", other, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	double /*var-non-null*/ Alignment::x() {
		auto m = ManagedCall("Alignment", "x");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	double /*var-non-null*/ Alignment::y() {
		auto m = ManagedCall("Alignment", "y");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Alignment> /*var-non-null*/ Alignment::topLeft() {
		auto m = ManagedCall("Alignment", "topLeft");
		shptr<class Alignment> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Alignment> /*var-non-null*/ Alignment::topCenter() {
		auto m = ManagedCall("Alignment", "topCenter");
		shptr<class Alignment> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Alignment> /*var-non-null*/ Alignment::topRight() {
		auto m = ManagedCall("Alignment", "topRight");
		shptr<class Alignment> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Alignment> /*var-non-null*/ Alignment::centerLeft() {
		auto m = ManagedCall("Alignment", "centerLeft");
		shptr<class Alignment> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Alignment> /*var-non-null*/ Alignment::center() {
		auto m = ManagedCall("Alignment", "center");
		shptr<class Alignment> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Alignment> /*var-non-null*/ Alignment::centerRight() {
		auto m = ManagedCall("Alignment", "centerRight");
		shptr<class Alignment> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Alignment> /*var-non-null*/ Alignment::bottomLeft() {
		auto m = ManagedCall("Alignment", "bottomLeft");
		shptr<class Alignment> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Alignment> /*var-non-null*/ Alignment::bottomCenter() {
		auto m = ManagedCall("Alignment", "bottomCenter");
		shptr<class Alignment> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Alignment> /*var-non-null*/ Alignment::bottomRight() {
		auto m = ManagedCall("Alignment", "bottomRight");
		shptr<class Alignment> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class AlignmentGeometry> /*non-null*/ Alignment::add(/*non-null*/ shptr<class AlignmentGeometry> other) {
		auto m = ManagedCall("Alignment", "add");
		m.put("this", this);
		m.put("other", other, true);
		shptr<class AlignmentGeometry> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Alignment> /*non-null*/ Alignment::minus(/*non-null*/ shptr<class Alignment> other) {
		auto m = ManagedCall("Alignment", "-");
		m.put("this", this);
		m.put("other", other, true);
		shptr<class Alignment> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Alignment> /*non-null*/ Alignment::plus(/*non-null*/ shptr<class Alignment> other) {
		auto m = ManagedCall("Alignment", "+");
		m.put("this", this);
		m.put("other", other, true);
		shptr<class Alignment> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Alignment> /*non-null*/ Alignment::neg() {
		auto m = ManagedCall("Alignment", "unary-");
		m.put("this", this);
		shptr<class Alignment> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Alignment> /*non-null*/ Alignment::mul(/*non-null*/ double other) {
		auto m = ManagedCall("Alignment", "*");
		m.put("this", this);
		m.put("other", other);
		shptr<class Alignment> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Alignment> /*non-null*/ Alignment::div(/*non-null*/ double other) {
		auto m = ManagedCall("Alignment", "/");
		m.put("this", this);
		m.put("other", other);
		shptr<class Alignment> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Alignment> /*non-null*/ Alignment::idiv(/*non-null*/ double other) {
		auto m = ManagedCall("Alignment", "~/");
		m.put("this", this);
		m.put("other", other);
		shptr<class Alignment> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Alignment> /*non-null*/ Alignment::mod(/*non-null*/ double other) {
		auto m = ManagedCall("Alignment", "%");
		m.put("this", this);
		m.put("other", other);
		shptr<class Alignment> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Offset> /*non-null*/ Alignment::alongOffset(/*non-null*/ shptr<class Offset> other) {
		auto m = ManagedCall("Alignment", "alongOffset");
		m.put("this", this);
		m.put("other", other, true);
		shptr<class Offset> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Offset> /*non-null*/ Alignment::alongSize(/*non-null*/ shptr<class Size> other) {
		auto m = ManagedCall("Alignment", "alongSize");
		m.put("this", this);
		m.put("other", other, true);
		shptr<class Offset> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Offset> /*non-null*/ Alignment::withinRect(/*non-null*/ shptr<class Rect> rect) {
		auto m = ManagedCall("Alignment", "withinRect");
		m.put("this", this);
		m.put("rect", rect, true);
		shptr<class Offset> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Rect> /*non-null*/ Alignment::inscribe(/*non-null*/ shptr<class Size> size, /*non-null*/ shptr<class Rect> rect) {
		auto m = ManagedCall("Alignment", "inscribe");
		m.put("this", this);
		m.put("size", size, true);
		m.put("rect", rect, true);
		shptr<class Rect> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Alignment> /*nullable*/ Alignment::lerp(/*nullable*/ shptr<class Alignment> a, /*nullable*/ shptr<class Alignment> b, /*non-null*/ double t) {
		auto m = ManagedCall("Alignment", "lerp");
		m.put("a", a);
		m.put("b", b);
		m.put("t", t);
		shptr<class Alignment> result;
		m.call(result);
		return result;
	}

	shptr<class Alignment> /*non-null*/ Alignment::resolve(/*nullable*/ stdop<TextDirection> direction) {
		auto m = ManagedCall("Alignment", "resolve");
		m.put("this", this);
		m.put("direction", direction);
		shptr<class Alignment> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Alignment> /*non-null*/ Alignment::ctorMain(/*non-null*/ double x, /*non-null*/ double y) {
		auto m = ManagedCall("Alignment", "Alignment");
		m.put("x", x);
		m.put("y", y);
		shptr<class Alignment> result;
		m.check(m.call(result, true));
		return result;
	}

	double /*var-non-null*/ AlignmentDirectional::start() {
		auto m = ManagedCall("AlignmentDirectional", "start");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	double /*var-non-null*/ AlignmentDirectional::y() {
		auto m = ManagedCall("AlignmentDirectional", "y");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	shptr<class AlignmentDirectional> /*var-non-null*/ AlignmentDirectional::topStart() {
		auto m = ManagedCall("AlignmentDirectional", "topStart");
		shptr<class AlignmentDirectional> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class AlignmentDirectional> /*var-non-null*/ AlignmentDirectional::topCenter() {
		auto m = ManagedCall("AlignmentDirectional", "topCenter");
		shptr<class AlignmentDirectional> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class AlignmentDirectional> /*var-non-null*/ AlignmentDirectional::topEnd() {
		auto m = ManagedCall("AlignmentDirectional", "topEnd");
		shptr<class AlignmentDirectional> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class AlignmentDirectional> /*var-non-null*/ AlignmentDirectional::centerStart() {
		auto m = ManagedCall("AlignmentDirectional", "centerStart");
		shptr<class AlignmentDirectional> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class AlignmentDirectional> /*var-non-null*/ AlignmentDirectional::center() {
		auto m = ManagedCall("AlignmentDirectional", "center");
		shptr<class AlignmentDirectional> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class AlignmentDirectional> /*var-non-null*/ AlignmentDirectional::centerEnd() {
		auto m = ManagedCall("AlignmentDirectional", "centerEnd");
		shptr<class AlignmentDirectional> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class AlignmentDirectional> /*var-non-null*/ AlignmentDirectional::bottomStart() {
		auto m = ManagedCall("AlignmentDirectional", "bottomStart");
		shptr<class AlignmentDirectional> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class AlignmentDirectional> /*var-non-null*/ AlignmentDirectional::bottomCenter() {
		auto m = ManagedCall("AlignmentDirectional", "bottomCenter");
		shptr<class AlignmentDirectional> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class AlignmentDirectional> /*var-non-null*/ AlignmentDirectional::bottomEnd() {
		auto m = ManagedCall("AlignmentDirectional", "bottomEnd");
		shptr<class AlignmentDirectional> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class AlignmentGeometry> /*non-null*/ AlignmentDirectional::add(/*non-null*/ shptr<class AlignmentGeometry> other) {
		auto m = ManagedCall("AlignmentDirectional", "add");
		m.put("this", this);
		m.put("other", other, true);
		shptr<class AlignmentGeometry> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class AlignmentDirectional> /*non-null*/ AlignmentDirectional::minus(/*non-null*/ shptr<class AlignmentDirectional> other) {
		auto m = ManagedCall("AlignmentDirectional", "-");
		m.put("this", this);
		m.put("other", other, true);
		shptr<class AlignmentDirectional> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class AlignmentDirectional> /*non-null*/ AlignmentDirectional::plus(/*non-null*/ shptr<class AlignmentDirectional> other) {
		auto m = ManagedCall("AlignmentDirectional", "+");
		m.put("this", this);
		m.put("other", other, true);
		shptr<class AlignmentDirectional> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class AlignmentDirectional> /*non-null*/ AlignmentDirectional::neg() {
		auto m = ManagedCall("AlignmentDirectional", "unary-");
		m.put("this", this);
		shptr<class AlignmentDirectional> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class AlignmentDirectional> /*non-null*/ AlignmentDirectional::mul(/*non-null*/ double other) {
		auto m = ManagedCall("AlignmentDirectional", "*");
		m.put("this", this);
		m.put("other", other);
		shptr<class AlignmentDirectional> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class AlignmentDirectional> /*non-null*/ AlignmentDirectional::div(/*non-null*/ double other) {
		auto m = ManagedCall("AlignmentDirectional", "/");
		m.put("this", this);
		m.put("other", other);
		shptr<class AlignmentDirectional> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class AlignmentDirectional> /*non-null*/ AlignmentDirectional::idiv(/*non-null*/ double other) {
		auto m = ManagedCall("AlignmentDirectional", "~/");
		m.put("this", this);
		m.put("other", other);
		shptr<class AlignmentDirectional> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class AlignmentDirectional> /*non-null*/ AlignmentDirectional::mod(/*non-null*/ double other) {
		auto m = ManagedCall("AlignmentDirectional", "%");
		m.put("this", this);
		m.put("other", other);
		shptr<class AlignmentDirectional> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class AlignmentDirectional> /*nullable*/ AlignmentDirectional::lerp(/*nullable*/ shptr<class AlignmentDirectional> a, /*nullable*/ shptr<class AlignmentDirectional> b, /*non-null*/ double t) {
		auto m = ManagedCall("AlignmentDirectional", "lerp");
		m.put("a", a);
		m.put("b", b);
		m.put("t", t);
		shptr<class AlignmentDirectional> result;
		m.call(result);
		return result;
	}

	shptr<class Alignment> /*non-null*/ AlignmentDirectional::resolve(/*nullable*/ stdop<TextDirection> direction) {
		auto m = ManagedCall("AlignmentDirectional", "resolve");
		m.put("this", this);
		m.put("direction", direction);
		shptr<class Alignment> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class AlignmentDirectional> /*non-null*/ AlignmentDirectional::ctorMain(/*non-null*/ double start, /*non-null*/ double y) {
		auto m = ManagedCall("AlignmentDirectional", "AlignmentDirectional");
		m.put("start", start);
		m.put("y", y);
		shptr<class AlignmentDirectional> result;
		m.check(m.call(result, true));
		return result;
	}

	double /*var-non-null*/ Radius::x() {
		auto m = ManagedCall("Radius", "x");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	double /*var-non-null*/ Radius::y() {
		auto m = ManagedCall("Radius", "y");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Radius> /*var-non-null*/ Radius::zero() {
		auto m = ManagedCall("Radius", "zero");
		shptr<class Radius> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Radius> /*non-null*/ Radius::clamp(_clamp p) {
		auto m = ManagedCall("Radius", "clamp");
		m.put("this", this);
		m.put("minimum", p.minimum);
		m.put("maximum", p.maximum);
		shptr<class Radius> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Radius> /*non-null*/ Radius::clampValues(_clampValues p) {
		auto m = ManagedCall("Radius", "clampValues");
		m.put("this", this);
		m.put("minimumX", p.minimumX);
		m.put("minimumY", p.minimumY);
		m.put("maximumX", p.maximumX);
		m.put("maximumY", p.maximumY);
		shptr<class Radius> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Radius> /*non-null*/ Radius::neg() {
		auto m = ManagedCall("Radius", "unary-");
		m.put("this", this);
		shptr<class Radius> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Radius> /*non-null*/ Radius::minus(/*non-null*/ shptr<class Radius> other) {
		auto m = ManagedCall("Radius", "-");
		m.put("this", this);
		m.put("other", other, true);
		shptr<class Radius> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Radius> /*non-null*/ Radius::plus(/*non-null*/ shptr<class Radius> other) {
		auto m = ManagedCall("Radius", "+");
		m.put("this", this);
		m.put("other", other, true);
		shptr<class Radius> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Radius> /*non-null*/ Radius::mul(/*non-null*/ double operand) {
		auto m = ManagedCall("Radius", "*");
		m.put("this", this);
		m.put("operand", operand);
		shptr<class Radius> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Radius> /*non-null*/ Radius::div(/*non-null*/ double operand) {
		auto m = ManagedCall("Radius", "/");
		m.put("this", this);
		m.put("operand", operand);
		shptr<class Radius> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Radius> /*non-null*/ Radius::idiv(/*non-null*/ double operand) {
		auto m = ManagedCall("Radius", "~/");
		m.put("this", this);
		m.put("operand", operand);
		shptr<class Radius> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Radius> /*non-null*/ Radius::mod(/*non-null*/ double operand) {
		auto m = ManagedCall("Radius", "%");
		m.put("this", this);
		m.put("operand", operand);
		shptr<class Radius> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Radius> /*nullable*/ Radius::lerp(/*nullable*/ shptr<class Radius> a, /*nullable*/ shptr<class Radius> b, /*non-null*/ double t) {
		auto m = ManagedCall("Radius", "lerp");
		m.put("a", a);
		m.put("b", b);
		m.put("t", t);
		shptr<class Radius> result;
		m.call(result);
		return result;
	}

	bool /*non-null*/ Radius::equals(/*non-null*/ shptr<class ObjBase> other) {
		auto m = ManagedCall("Radius", "==");
		m.put("this", this);
		m.put("other", other, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Radius> /*non-null*/ Radius::circular(/*non-null*/ double radius) {
		auto m = ManagedCall("Radius", "circular");
		m.put("radius", radius);
		shptr<class Radius> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Radius> /*non-null*/ Radius::elliptical(/*non-null*/ double x, /*non-null*/ double y) {
		auto m = ManagedCall("Radius", "elliptical");
		m.put("x", x);
		m.put("y", y);
		shptr<class Radius> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class BorderRadius> /*var-non-null*/ BorderRadius::zero() {
		auto m = ManagedCall("BorderRadius", "zero");
		shptr<class BorderRadius> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Radius> /*var-non-null*/ BorderRadius::topLeft() {
		auto m = ManagedCall("BorderRadius", "topLeft");
		m.put("this", this);
		shptr<class Radius> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Radius> /*var-non-null*/ BorderRadius::topRight() {
		auto m = ManagedCall("BorderRadius", "topRight");
		m.put("this", this);
		shptr<class Radius> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Radius> /*var-non-null*/ BorderRadius::bottomLeft() {
		auto m = ManagedCall("BorderRadius", "bottomLeft");
		m.put("this", this);
		shptr<class Radius> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Radius> /*var-non-null*/ BorderRadius::bottomRight() {
		auto m = ManagedCall("BorderRadius", "bottomRight");
		m.put("this", this);
		shptr<class Radius> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class BorderRadius> /*non-null*/ BorderRadius::copyWith(_copyWith p) {
		auto m = ManagedCall("BorderRadius", "copyWith");
		m.put("this", this);
		m.put("topLeft", p.topLeft);
		m.put("topRight", p.topRight);
		m.put("bottomLeft", p.bottomLeft);
		m.put("bottomRight", p.bottomRight);
		shptr<class BorderRadius> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class RRect> /*non-null*/ BorderRadius::toRRect(/*non-null*/ shptr<class Rect> rect) {
		auto m = ManagedCall("BorderRadius", "toRRect");
		m.put("this", this);
		m.put("rect", rect, true);
		shptr<class RRect> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class BorderRadiusGeometry> /*non-null*/ BorderRadius::subtract(/*non-null*/ shptr<class BorderRadiusGeometry> other) {
		auto m = ManagedCall("BorderRadius", "subtract");
		m.put("this", this);
		m.put("other", other, true);
		shptr<class BorderRadiusGeometry> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class BorderRadiusGeometry> /*non-null*/ BorderRadius::add(/*non-null*/ shptr<class BorderRadiusGeometry> other) {
		auto m = ManagedCall("BorderRadius", "add");
		m.put("this", this);
		m.put("other", other, true);
		shptr<class BorderRadiusGeometry> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class BorderRadius> /*non-null*/ BorderRadius::minus(/*non-null*/ shptr<class BorderRadius> other) {
		auto m = ManagedCall("BorderRadius", "-");
		m.put("this", this);
		m.put("other", other, true);
		shptr<class BorderRadius> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class BorderRadius> /*non-null*/ BorderRadius::plus(/*non-null*/ shptr<class BorderRadius> other) {
		auto m = ManagedCall("BorderRadius", "+");
		m.put("this", this);
		m.put("other", other, true);
		shptr<class BorderRadius> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class BorderRadius> /*non-null*/ BorderRadius::neg() {
		auto m = ManagedCall("BorderRadius", "unary-");
		m.put("this", this);
		shptr<class BorderRadius> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class BorderRadius> /*non-null*/ BorderRadius::mul(/*non-null*/ double other) {
		auto m = ManagedCall("BorderRadius", "*");
		m.put("this", this);
		m.put("other", other);
		shptr<class BorderRadius> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class BorderRadius> /*non-null*/ BorderRadius::div(/*non-null*/ double other) {
		auto m = ManagedCall("BorderRadius", "/");
		m.put("this", this);
		m.put("other", other);
		shptr<class BorderRadius> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class BorderRadius> /*non-null*/ BorderRadius::idiv(/*non-null*/ double other) {
		auto m = ManagedCall("BorderRadius", "~/");
		m.put("this", this);
		m.put("other", other);
		shptr<class BorderRadius> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class BorderRadius> /*non-null*/ BorderRadius::mod(/*non-null*/ double other) {
		auto m = ManagedCall("BorderRadius", "%");
		m.put("this", this);
		m.put("other", other);
		shptr<class BorderRadius> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class BorderRadius> /*nullable*/ BorderRadius::lerp(/*nullable*/ shptr<class BorderRadius> a, /*nullable*/ shptr<class BorderRadius> b, /*non-null*/ double t) {
		auto m = ManagedCall("BorderRadius", "lerp");
		m.put("a", a);
		m.put("b", b);
		m.put("t", t);
		shptr<class BorderRadius> result;
		m.call(result);
		return result;
	}

	shptr<class BorderRadius> /*non-null*/ BorderRadius::resolve(/*nullable*/ stdop<TextDirection> direction) {
		auto m = ManagedCall("BorderRadius", "resolve");
		m.put("this", this);
		m.put("direction", direction);
		shptr<class BorderRadius> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class BorderRadius> /*non-null*/ BorderRadius::all(/*non-null*/ shptr<class Radius> radius) {
		auto m = ManagedCall("BorderRadius", "all");
		m.put("radius", radius, true);
		shptr<class BorderRadius> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class BorderRadius> /*non-null*/ BorderRadius::circular(/*non-null*/ double radius) {
		auto m = ManagedCall("BorderRadius", "circular");
		m.put("radius", radius);
		shptr<class BorderRadius> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class BorderRadius> /*non-null*/ BorderRadius::vertical(_vertical p) {
		auto m = ManagedCall("BorderRadius", "vertical");
		m.put("top", p.top, true);
		m.put("bottom", p.bottom, true);
		shptr<class BorderRadius> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class BorderRadius> /*non-null*/ BorderRadius::horizontal(_horizontal p) {
		auto m = ManagedCall("BorderRadius", "horizontal");
		m.put("left", p.left, true);
		m.put("right", p.right, true);
		shptr<class BorderRadius> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class BorderRadius> /*non-null*/ BorderRadius::only(_only p) {
		auto m = ManagedCall("BorderRadius", "only");
		m.put("topLeft", p.topLeft, true);
		m.put("topRight", p.topRight, true);
		m.put("bottomLeft", p.bottomLeft, true);
		m.put("bottomRight", p.bottomRight, true);
		shptr<class BorderRadius> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Color> /*var-non-null*/ BorderSide::color() {
		auto m = ManagedCall("BorderSide", "color");
		m.put("this", this);
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	double /*var-non-null*/ BorderSide::width() {
		auto m = ManagedCall("BorderSide", "width");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	BorderStyle /*var-non-null*/ BorderSide::style() {
		auto m = ManagedCall("BorderSide", "style");
		m.put("this", this);
		BorderStyle result;
		m.check(m.call(result));
		return result;
	}

	shptr<class BorderSide> /*var-non-null*/ BorderSide::none() {
		auto m = ManagedCall("BorderSide", "none");
		shptr<class BorderSide> result;
		m.check(m.call(result));
		return result;
	}

	double /*var-non-null*/ BorderSide::strokeAlign() {
		auto m = ManagedCall("BorderSide", "strokeAlign");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	double /*var-non-null*/ BorderSide::strokeAlignInside() {
		auto m = ManagedCall("BorderSide", "strokeAlignInside");
		double result;
		m.check(m.call(result));
		return result;
	}

	double /*var-non-null*/ BorderSide::strokeAlignCenter() {
		auto m = ManagedCall("BorderSide", "strokeAlignCenter");
		double result;
		m.check(m.call(result));
		return result;
	}

	double /*var-non-null*/ BorderSide::strokeAlignOutside() {
		auto m = ManagedCall("BorderSide", "strokeAlignOutside");
		double result;
		m.check(m.call(result));
		return result;
	}

	double /*get-non-null*/ BorderSide::strokeInset() {
		auto m = ManagedCall("BorderSide", "strokeInset");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	double /*get-non-null*/ BorderSide::strokeOutset() {
		auto m = ManagedCall("BorderSide", "strokeOutset");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	double /*get-non-null*/ BorderSide::strokeOffset() {
		auto m = ManagedCall("BorderSide", "strokeOffset");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	shptr<class BorderSide> /*non-null*/ BorderSide::merge(/*non-null*/ shptr<class BorderSide> a, /*non-null*/ shptr<class BorderSide> b) {
		auto m = ManagedCall("BorderSide", "merge");
		m.put("a", a, true);
		m.put("b", b, true);
		shptr<class BorderSide> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class BorderSide> /*non-null*/ BorderSide::copyWith(_copyWith p) {
		auto m = ManagedCall("BorderSide", "copyWith");
		m.put("this", this);
		m.put("color", p.color);
		m.put("width", p.width);
		m.put("style", p.style);
		m.put("strokeAlign", p.strokeAlign);
		shptr<class BorderSide> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class BorderSide> /*non-null*/ BorderSide::scale(/*non-null*/ double t) {
		auto m = ManagedCall("BorderSide", "scale");
		m.put("this", this);
		m.put("t", t);
		shptr<class BorderSide> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Paint> /*non-null*/ BorderSide::toPaint() {
		auto m = ManagedCall("BorderSide", "toPaint");
		m.put("this", this);
		shptr<class Paint> result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ BorderSide::canMerge(/*non-null*/ shptr<class BorderSide> a, /*non-null*/ shptr<class BorderSide> b) {
		auto m = ManagedCall("BorderSide", "canMerge");
		m.put("a", a, true);
		m.put("b", b, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class BorderSide> /*non-null*/ BorderSide::lerp(/*non-null*/ shptr<class BorderSide> a, /*non-null*/ shptr<class BorderSide> b, /*non-null*/ double t) {
		auto m = ManagedCall("BorderSide", "lerp");
		m.put("a", a, true);
		m.put("b", b, true);
		m.put("t", t);
		shptr<class BorderSide> result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ BorderSide::equals(/*non-null*/ shptr<class ObjBase> other) {
		auto m = ManagedCall("BorderSide", "==");
		m.put("this", this);
		m.put("other", other, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	stdstr /*non-null*/ BorderSide::toStringShort() {
		auto m = ManagedCall("BorderSide", "toStringShort");
		m.put("this", this);
		stdstr result;
		m.check(m.call(result));
		return result;
	}

	shptr<class BorderSide> /*non-null*/ BorderSide::ctorMain(_ctorMain p) {
		auto m = ManagedCall("BorderSide", "BorderSide");
		m.put("color", p.color, true);
		m.put("width", p.width);
		m.put("style", p.style);
		m.put("strokeAlign", p.strokeAlign);
		shptr<class BorderSide> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class EdgeInsets> /*var-non-null*/ EdgeInsets::zero() {
		auto m = ManagedCall("EdgeInsets", "zero");
		shptr<class EdgeInsets> result;
		m.check(m.call(result));
		return result;
	}

	double /*var-non-null*/ EdgeInsets::left() {
		auto m = ManagedCall("EdgeInsets", "left");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	double /*var-non-null*/ EdgeInsets::top() {
		auto m = ManagedCall("EdgeInsets", "top");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	double /*var-non-null*/ EdgeInsets::right() {
		auto m = ManagedCall("EdgeInsets", "right");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	double /*var-non-null*/ EdgeInsets::bottom() {
		auto m = ManagedCall("EdgeInsets", "bottom");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Offset> /*get-non-null*/ EdgeInsets::topLeft() {
		auto m = ManagedCall("EdgeInsets", "topLeft");
		m.put("this", this);
		shptr<class Offset> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Offset> /*get-non-null*/ EdgeInsets::topRight() {
		auto m = ManagedCall("EdgeInsets", "topRight");
		m.put("this", this);
		shptr<class Offset> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Offset> /*get-non-null*/ EdgeInsets::bottomLeft() {
		auto m = ManagedCall("EdgeInsets", "bottomLeft");
		m.put("this", this);
		shptr<class Offset> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Offset> /*get-non-null*/ EdgeInsets::bottomRight() {
		auto m = ManagedCall("EdgeInsets", "bottomRight");
		m.put("this", this);
		shptr<class Offset> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class EdgeInsets> /*get-non-null*/ EdgeInsets::flipped() {
		auto m = ManagedCall("EdgeInsets", "flipped");
		m.put("this", this);
		shptr<class EdgeInsets> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Rect> /*non-null*/ EdgeInsets::inflateRect(/*non-null*/ shptr<class Rect> rect) {
		auto m = ManagedCall("EdgeInsets", "inflateRect");
		m.put("this", this);
		m.put("rect", rect, true);
		shptr<class Rect> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Rect> /*non-null*/ EdgeInsets::deflateRect(/*non-null*/ shptr<class Rect> rect) {
		auto m = ManagedCall("EdgeInsets", "deflateRect");
		m.put("this", this);
		m.put("rect", rect, true);
		shptr<class Rect> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class EdgeInsetsGeometry> /*non-null*/ EdgeInsets::subtract(/*non-null*/ shptr<class EdgeInsetsGeometry> other) {
		auto m = ManagedCall("EdgeInsets", "subtract");
		m.put("this", this);
		m.put("other", other, true);
		shptr<class EdgeInsetsGeometry> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class EdgeInsetsGeometry> /*non-null*/ EdgeInsets::add(/*non-null*/ shptr<class EdgeInsetsGeometry> other) {
		auto m = ManagedCall("EdgeInsets", "add");
		m.put("this", this);
		m.put("other", other, true);
		shptr<class EdgeInsetsGeometry> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class EdgeInsetsGeometry> /*non-null*/ EdgeInsets::clamp(/*non-null*/ shptr<class EdgeInsetsGeometry> min, /*non-null*/ shptr<class EdgeInsetsGeometry> max) {
		auto m = ManagedCall("EdgeInsets", "clamp");
		m.put("this", this);
		m.put("min", min, true);
		m.put("max", max, true);
		shptr<class EdgeInsetsGeometry> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class EdgeInsets> /*non-null*/ EdgeInsets::minus(/*non-null*/ shptr<class EdgeInsets> other) {
		auto m = ManagedCall("EdgeInsets", "-");
		m.put("this", this);
		m.put("other", other, true);
		shptr<class EdgeInsets> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class EdgeInsets> /*non-null*/ EdgeInsets::plus(/*non-null*/ shptr<class EdgeInsets> other) {
		auto m = ManagedCall("EdgeInsets", "+");
		m.put("this", this);
		m.put("other", other, true);
		shptr<class EdgeInsets> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class EdgeInsets> /*non-null*/ EdgeInsets::neg() {
		auto m = ManagedCall("EdgeInsets", "unary-");
		m.put("this", this);
		shptr<class EdgeInsets> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class EdgeInsets> /*non-null*/ EdgeInsets::mul(/*non-null*/ double other) {
		auto m = ManagedCall("EdgeInsets", "*");
		m.put("this", this);
		m.put("other", other);
		shptr<class EdgeInsets> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class EdgeInsets> /*non-null*/ EdgeInsets::div(/*non-null*/ double other) {
		auto m = ManagedCall("EdgeInsets", "/");
		m.put("this", this);
		m.put("other", other);
		shptr<class EdgeInsets> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class EdgeInsets> /*non-null*/ EdgeInsets::idiv(/*non-null*/ double other) {
		auto m = ManagedCall("EdgeInsets", "~/");
		m.put("this", this);
		m.put("other", other);
		shptr<class EdgeInsets> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class EdgeInsets> /*non-null*/ EdgeInsets::mod(/*non-null*/ double other) {
		auto m = ManagedCall("EdgeInsets", "%");
		m.put("this", this);
		m.put("other", other);
		shptr<class EdgeInsets> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class EdgeInsets> /*nullable*/ EdgeInsets::lerp(/*nullable*/ shptr<class EdgeInsets> a, /*nullable*/ shptr<class EdgeInsets> b, /*non-null*/ double t) {
		auto m = ManagedCall("EdgeInsets", "lerp");
		m.put("a", a);
		m.put("b", b);
		m.put("t", t);
		shptr<class EdgeInsets> result;
		m.call(result);
		return result;
	}

	shptr<class EdgeInsets> /*non-null*/ EdgeInsets::resolve(/*nullable*/ stdop<TextDirection> direction) {
		auto m = ManagedCall("EdgeInsets", "resolve");
		m.put("this", this);
		m.put("direction", direction);
		shptr<class EdgeInsets> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class EdgeInsets> /*non-null*/ EdgeInsets::copyWith(_copyWith p) {
		auto m = ManagedCall("EdgeInsets", "copyWith");
		m.put("this", this);
		m.put("left", p.left);
		m.put("top", p.top);
		m.put("right", p.right);
		m.put("bottom", p.bottom);
		shptr<class EdgeInsets> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class EdgeInsets> /*non-null*/ EdgeInsets::fromLTRB(/*non-null*/ double left, /*non-null*/ double top, /*non-null*/ double right, /*non-null*/ double bottom) {
		auto m = ManagedCall("EdgeInsets", "fromLTRB");
		m.put("left", left);
		m.put("top", top);
		m.put("right", right);
		m.put("bottom", bottom);
		shptr<class EdgeInsets> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class EdgeInsets> /*non-null*/ EdgeInsets::all(/*non-null*/ double value) {
		auto m = ManagedCall("EdgeInsets", "all");
		m.put("value", value);
		shptr<class EdgeInsets> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class EdgeInsets> /*non-null*/ EdgeInsets::only(_only p) {
		auto m = ManagedCall("EdgeInsets", "only");
		m.put("left", p.left);
		m.put("top", p.top);
		m.put("right", p.right);
		m.put("bottom", p.bottom);
		shptr<class EdgeInsets> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class EdgeInsets> /*non-null*/ EdgeInsets::symmetric(_symmetric p) {
		auto m = ManagedCall("EdgeInsets", "symmetric");
		m.put("vertical", p.vertical);
		m.put("horizontal", p.horizontal);
		shptr<class EdgeInsets> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class EdgeInsets> /*non-null*/ EdgeInsets::fromViewPadding(/*non-null*/ shptr<class ViewPadding> padding, /*non-null*/ double devicePixelRatio) {
		auto m = ManagedCall("EdgeInsets", "fromViewPadding");
		m.put("padding", padding, true);
		m.put("devicePixelRatio", devicePixelRatio);
		shptr<class EdgeInsets> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class EdgeInsets> /*non-null*/ EdgeInsets::fromWindowPadding(/*non-null*/ shptr<class ViewPadding> padding, /*non-null*/ double devicePixelRatio) {
		auto m = ManagedCall("EdgeInsets", "fromWindowPadding");
		m.put("padding", padding, true);
		m.put("devicePixelRatio", devicePixelRatio);
		shptr<class EdgeInsets> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Color> /*var-nullable*/ BoxDecoration::color() {
		auto m = ManagedCall("BoxDecoration", "color");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class DecorationImage> /*var-nullable*/ BoxDecoration::image() {
		auto m = ManagedCall("BoxDecoration", "image");
		m.put("this", this);
		shptr<class DecorationImage> result;
		m.call(result);
		return result;
	}

	shptr<class BoxBorder> /*var-nullable*/ BoxDecoration::border() {
		auto m = ManagedCall("BoxDecoration", "border");
		m.put("this", this);
		shptr<class BoxBorder> result;
		m.call(result);
		return result;
	}

	shptr<class BorderRadiusGeometry> /*var-nullable*/ BoxDecoration::borderRadius() {
		auto m = ManagedCall("BoxDecoration", "borderRadius");
		m.put("this", this);
		shptr<class BorderRadiusGeometry> result;
		m.call(result);
		return result;
	}

	shptr<class Gradient> /*var-nullable*/ BoxDecoration::gradient() {
		auto m = ManagedCall("BoxDecoration", "gradient");
		m.put("this", this);
		shptr<class Gradient> result;
		m.call(result);
		return result;
	}

	stdop<BlendMode> /*var-nullable*/ BoxDecoration::backgroundBlendMode() {
		auto m = ManagedCall("BoxDecoration", "backgroundBlendMode");
		m.put("this", this);
		stdop<BlendMode> result;
		m.call(result);
		return result;
	}

	BoxShape /*var-non-null*/ BoxDecoration::shape() {
		auto m = ManagedCall("BoxDecoration", "shape");
		m.put("this", this);
		BoxShape result;
		m.check(m.call(result));
		return result;
	}

	shptr<class EdgeInsetsGeometry> /*get-non-null*/ BoxDecoration::padding() {
		auto m = ManagedCall("BoxDecoration", "padding");
		m.put("this", this);
		shptr<class EdgeInsetsGeometry> result;
		m.check(m.call(result));
		return result;
	}

	bool /*get-non-null*/ BoxDecoration::isComplex() {
		auto m = ManagedCall("BoxDecoration", "isComplex");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class BoxDecoration> /*non-null*/ BoxDecoration::copyWith(_copyWith p) {
		auto m = ManagedCall("BoxDecoration", "copyWith");
		m.put("this", this);
		m.put("color", p.color);
		m.put("image", p.image);
		m.put("border", p.border);
		m.put("borderRadius", p.borderRadius);
		m.put("boxShadow", p.boxShadow);
		m.put("gradient", p.gradient);
		m.put("backgroundBlendMode", p.backgroundBlendMode);
		m.put("shape", p.shape);
		shptr<class BoxDecoration> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Path> /*non-null*/ BoxDecoration::getClipPath(/*non-null*/ shptr<class Rect> rect, /*non-null*/ TextDirection textDirection) {
		auto m = ManagedCall("BoxDecoration", "getClipPath");
		m.put("this", this);
		m.put("rect", rect, true);
		m.put("textDirection", textDirection);
		shptr<class Path> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class BoxDecoration> /*non-null*/ BoxDecoration::scale(/*non-null*/ double factor) {
		auto m = ManagedCall("BoxDecoration", "scale");
		m.put("this", this);
		m.put("factor", factor);
		shptr<class BoxDecoration> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class BoxDecoration> /*nullable*/ BoxDecoration::lerpFrom(/*nullable*/ shptr<class Decoration> a, /*non-null*/ double t) {
		auto m = ManagedCall("BoxDecoration", "lerpFrom");
		m.put("this", this);
		m.put("a", a);
		m.put("t", t);
		shptr<class BoxDecoration> result;
		m.call(result);
		return result;
	}

	shptr<class BoxDecoration> /*nullable*/ BoxDecoration::lerpTo(/*nullable*/ shptr<class Decoration> b, /*non-null*/ double t) {
		auto m = ManagedCall("BoxDecoration", "lerpTo");
		m.put("this", this);
		m.put("b", b);
		m.put("t", t);
		shptr<class BoxDecoration> result;
		m.call(result);
		return result;
	}

	shptr<class BoxDecoration> /*nullable*/ BoxDecoration::lerp(/*nullable*/ shptr<class BoxDecoration> a, /*nullable*/ shptr<class BoxDecoration> b, /*non-null*/ double t) {
		auto m = ManagedCall("BoxDecoration", "lerp");
		m.put("a", a);
		m.put("b", b);
		m.put("t", t);
		shptr<class BoxDecoration> result;
		m.call(result);
		return result;
	}

	bool /*non-null*/ BoxDecoration::equals(/*non-null*/ shptr<class ObjBase> other) {
		auto m = ManagedCall("BoxDecoration", "==");
		m.put("this", this);
		m.put("other", other, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class BoxDecoration> /*non-null*/ BoxDecoration::ctorMain(_ctorMain p) {
		auto m = ManagedCall("BoxDecoration", "BoxDecoration");
		m.put("color", p.color);
		m.put("image", p.image);
		m.put("border", p.border);
		m.put("borderRadius", p.borderRadius);
		m.put("boxShadow", p.boxShadow);
		m.put("gradient", p.gradient);
		m.put("backgroundBlendMode", p.backgroundBlendMode);
		m.put("shape", p.shape);
		shptr<class BoxDecoration> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Color> /*var-non-null*/ Shadow::color() {
		auto m = ManagedCall("Shadow", "color");
		m.put("this", this);
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Offset> /*var-non-null*/ Shadow::offset() {
		auto m = ManagedCall("Shadow", "offset");
		m.put("this", this);
		shptr<class Offset> result;
		m.check(m.call(result));
		return result;
	}

	double /*var-non-null*/ Shadow::blurRadius() {
		auto m = ManagedCall("Shadow", "blurRadius");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	double /*get-non-null*/ Shadow::blurSigma() {
		auto m = ManagedCall("Shadow", "blurSigma");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	double /*non-null*/ Shadow::convertRadiusToSigma(/*non-null*/ double radius) {
		auto m = ManagedCall("Shadow", "convertRadiusToSigma");
		m.put("radius", radius);
		double result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Shadow> /*non-null*/ Shadow::scale(/*non-null*/ double factor) {
		auto m = ManagedCall("Shadow", "scale");
		m.put("this", this);
		m.put("factor", factor);
		shptr<class Shadow> result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ Shadow::equals(/*non-null*/ shptr<class ObjBase> other) {
		auto m = ManagedCall("Shadow", "==");
		m.put("this", this);
		m.put("other", other, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Shadow> /*non-null*/ Shadow::ctorMain(_ctorMain p) {
		auto m = ManagedCall("Shadow", "Shadow");
		m.put("color", p.color, true);
		m.put("offset", p.offset, true);
		m.put("blurRadius", p.blurRadius);
		shptr<class Shadow> result;
		m.check(m.call(result, true));
		return result;
	}

	double /*var-non-null*/ BoxShadow::spreadRadius() {
		auto m = ManagedCall("BoxShadow", "spreadRadius");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	BlurStyle /*var-non-null*/ BoxShadow::blurStyle() {
		auto m = ManagedCall("BoxShadow", "blurStyle");
		m.put("this", this);
		BlurStyle result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Paint> /*non-null*/ BoxShadow::toPaint() {
		auto m = ManagedCall("BoxShadow", "toPaint");
		m.put("this", this);
		shptr<class Paint> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class BoxShadow> /*non-null*/ BoxShadow::scale(/*non-null*/ double factor) {
		auto m = ManagedCall("BoxShadow", "scale");
		m.put("this", this);
		m.put("factor", factor);
		shptr<class BoxShadow> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class BoxShadow> /*nullable*/ BoxShadow::lerp(/*nullable*/ shptr<class BoxShadow> a, /*nullable*/ shptr<class BoxShadow> b, /*non-null*/ double t) {
		auto m = ManagedCall("BoxShadow", "lerp");
		m.put("a", a);
		m.put("b", b);
		m.put("t", t);
		shptr<class BoxShadow> result;
		m.call(result);
		return result;
	}

	bool /*non-null*/ BoxShadow::equals(/*non-null*/ shptr<class ObjBase> other) {
		auto m = ManagedCall("BoxShadow", "==");
		m.put("this", this);
		m.put("other", other, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class BoxShadow> /*non-null*/ BoxShadow::ctorMain(_ctorMain p) {
		auto m = ManagedCall("BoxShadow", "BoxShadow");
		m.put("color", p.color, true);
		m.put("offset", p.offset, true);
		m.put("blurRadius", p.blurRadius);
		m.put("spreadRadius", p.spreadRadius);
		m.put("blurStyle", p.blurStyle);
		shptr<class BoxShadow> result;
		m.check(m.call(result, true));
		return result;
	}

	double /*var-non-null*/ GradientRotation::radians() {
		auto m = ManagedCall("GradientRotation", "radians");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Matrix4> /*non-null*/ GradientRotation::transform(/*non-null*/ shptr<class Rect> bounds, _transform p) {
		auto m = ManagedCall("GradientRotation", "transform");
		m.put("this", this);
		m.put("bounds", bounds, true);
		m.put("textDirection", p.textDirection);
		shptr<class Matrix4> result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ GradientRotation::equals(/*non-null*/ shptr<class ObjBase> other) {
		auto m = ManagedCall("GradientRotation", "==");
		m.put("this", this);
		m.put("other", other, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class GradientRotation> /*non-null*/ GradientRotation::ctorMain(/*non-null*/ double radians) {
		auto m = ManagedCall("GradientRotation", "GradientRotation");
		m.put("radians", radians);
		shptr<class GradientRotation> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class GradientTransform> /*var-nullable*/ Gradient::transform() {
		auto m = ManagedCall("Gradient", "transform");
		m.put("this", this);
		shptr<class GradientTransform> result;
		m.call(result);
		return result;
	}

	shptr<class Shader> /*non-null*/ Gradient::createShader(/*non-null*/ shptr<class Rect> rect, _createShader p) {
		auto m = ManagedCall("Gradient", "createShader");
		m.put("this", this);
		m.put("rect", rect, true);
		m.put("textDirection", p.textDirection);
		shptr<class Shader> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Gradient> /*non-null*/ Gradient::scale(/*non-null*/ double factor) {
		auto m = ManagedCall("Gradient", "scale");
		m.put("this", this);
		m.put("factor", factor);
		shptr<class Gradient> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Gradient> /*nullable*/ Gradient::lerp(/*nullable*/ shptr<class Gradient> a, /*nullable*/ shptr<class Gradient> b, /*non-null*/ double t) {
		auto m = ManagedCall("Gradient", "lerp");
		m.put("a", a);
		m.put("b", b);
		m.put("t", t);
		shptr<class Gradient> result;
		m.call(result);
		return result;
	}

	shptr<class AlignmentGeometry> /*var-non-null*/ LinearGradient::begin() {
		auto m = ManagedCall("LinearGradient", "begin");
		m.put("this", this);
		shptr<class AlignmentGeometry> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class AlignmentGeometry> /*var-non-null*/ LinearGradient::end() {
		auto m = ManagedCall("LinearGradient", "end");
		m.put("this", this);
		shptr<class AlignmentGeometry> result;
		m.check(m.call(result));
		return result;
	}

	TileMode /*var-non-null*/ LinearGradient::tileMode() {
		auto m = ManagedCall("LinearGradient", "tileMode");
		m.put("this", this);
		TileMode result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Shader> /*non-null*/ LinearGradient::createShader(/*non-null*/ shptr<class Rect> rect, _createShader p) {
		auto m = ManagedCall("LinearGradient", "createShader");
		m.put("this", this);
		m.put("rect", rect, true);
		m.put("textDirection", p.textDirection);
		shptr<class Shader> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class LinearGradient> /*non-null*/ LinearGradient::scale(/*non-null*/ double factor) {
		auto m = ManagedCall("LinearGradient", "scale");
		m.put("this", this);
		m.put("factor", factor);
		shptr<class LinearGradient> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Gradient> /*nullable*/ LinearGradient::lerpFrom(/*nullable*/ shptr<class Gradient> a, /*non-null*/ double t) {
		auto m = ManagedCall("LinearGradient", "lerpFrom");
		m.put("this", this);
		m.put("a", a);
		m.put("t", t);
		shptr<class Gradient> result;
		m.call(result);
		return result;
	}

	shptr<class Gradient> /*nullable*/ LinearGradient::lerpTo(/*nullable*/ shptr<class Gradient> b, /*non-null*/ double t) {
		auto m = ManagedCall("LinearGradient", "lerpTo");
		m.put("this", this);
		m.put("b", b);
		m.put("t", t);
		shptr<class Gradient> result;
		m.call(result);
		return result;
	}

	shptr<class LinearGradient> /*nullable*/ LinearGradient::lerp(/*nullable*/ shptr<class LinearGradient> a, /*nullable*/ shptr<class LinearGradient> b, /*non-null*/ double t) {
		auto m = ManagedCall("LinearGradient", "lerp");
		m.put("a", a);
		m.put("b", b);
		m.put("t", t);
		shptr<class LinearGradient> result;
		m.call(result);
		return result;
	}

	bool /*non-null*/ LinearGradient::equals(/*non-null*/ shptr<class ObjBase> other) {
		auto m = ManagedCall("LinearGradient", "==");
		m.put("this", this);
		m.put("other", other, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class LinearGradient> /*non-null*/ LinearGradient::ctorMain(_ctorMain p) {
		auto m = ManagedCall("LinearGradient", "LinearGradient");
		m.put("begin", p.begin, true);
		m.put("end", p.end, true);
		m.put("colors", p.colors);
		m.put("stops", p.stops);
		m.put("tileMode", p.tileMode);
		m.put("transform", p.transform);
		shptr<class LinearGradient> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class AlignmentGeometry> /*var-non-null*/ RadialGradient::center() {
		auto m = ManagedCall("RadialGradient", "center");
		m.put("this", this);
		shptr<class AlignmentGeometry> result;
		m.check(m.call(result));
		return result;
	}

	double /*var-non-null*/ RadialGradient::radius() {
		auto m = ManagedCall("RadialGradient", "radius");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	TileMode /*var-non-null*/ RadialGradient::tileMode() {
		auto m = ManagedCall("RadialGradient", "tileMode");
		m.put("this", this);
		TileMode result;
		m.check(m.call(result));
		return result;
	}

	shptr<class AlignmentGeometry> /*var-nullable*/ RadialGradient::focal() {
		auto m = ManagedCall("RadialGradient", "focal");
		m.put("this", this);
		shptr<class AlignmentGeometry> result;
		m.call(result);
		return result;
	}

	double /*var-non-null*/ RadialGradient::focalRadius() {
		auto m = ManagedCall("RadialGradient", "focalRadius");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Shader> /*non-null*/ RadialGradient::createShader(/*non-null*/ shptr<class Rect> rect, _createShader p) {
		auto m = ManagedCall("RadialGradient", "createShader");
		m.put("this", this);
		m.put("rect", rect, true);
		m.put("textDirection", p.textDirection);
		shptr<class Shader> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class RadialGradient> /*non-null*/ RadialGradient::scale(/*non-null*/ double factor) {
		auto m = ManagedCall("RadialGradient", "scale");
		m.put("this", this);
		m.put("factor", factor);
		shptr<class RadialGradient> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Gradient> /*nullable*/ RadialGradient::lerpFrom(/*nullable*/ shptr<class Gradient> a, /*non-null*/ double t) {
		auto m = ManagedCall("RadialGradient", "lerpFrom");
		m.put("this", this);
		m.put("a", a);
		m.put("t", t);
		shptr<class Gradient> result;
		m.call(result);
		return result;
	}

	shptr<class Gradient> /*nullable*/ RadialGradient::lerpTo(/*nullable*/ shptr<class Gradient> b, /*non-null*/ double t) {
		auto m = ManagedCall("RadialGradient", "lerpTo");
		m.put("this", this);
		m.put("b", b);
		m.put("t", t);
		shptr<class Gradient> result;
		m.call(result);
		return result;
	}

	shptr<class RadialGradient> /*nullable*/ RadialGradient::lerp(/*nullable*/ shptr<class RadialGradient> a, /*nullable*/ shptr<class RadialGradient> b, /*non-null*/ double t) {
		auto m = ManagedCall("RadialGradient", "lerp");
		m.put("a", a);
		m.put("b", b);
		m.put("t", t);
		shptr<class RadialGradient> result;
		m.call(result);
		return result;
	}

	bool /*non-null*/ RadialGradient::equals(/*non-null*/ shptr<class ObjBase> other) {
		auto m = ManagedCall("RadialGradient", "==");
		m.put("this", this);
		m.put("other", other, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class RadialGradient> /*non-null*/ RadialGradient::ctorMain(_ctorMain p) {
		auto m = ManagedCall("RadialGradient", "RadialGradient");
		m.put("center", p.center, true);
		m.put("radius", p.radius);
		m.put("colors", p.colors);
		m.put("stops", p.stops);
		m.put("tileMode", p.tileMode);
		m.put("focal", p.focal);
		m.put("focalRadius", p.focalRadius);
		m.put("transform", p.transform);
		shptr<class RadialGradient> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class AlignmentGeometry> /*var-non-null*/ SweepGradient::center() {
		auto m = ManagedCall("SweepGradient", "center");
		m.put("this", this);
		shptr<class AlignmentGeometry> result;
		m.check(m.call(result));
		return result;
	}

	double /*var-non-null*/ SweepGradient::startAngle() {
		auto m = ManagedCall("SweepGradient", "startAngle");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	double /*var-non-null*/ SweepGradient::endAngle() {
		auto m = ManagedCall("SweepGradient", "endAngle");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	TileMode /*var-non-null*/ SweepGradient::tileMode() {
		auto m = ManagedCall("SweepGradient", "tileMode");
		m.put("this", this);
		TileMode result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Shader> /*non-null*/ SweepGradient::createShader(/*non-null*/ shptr<class Rect> rect, _createShader p) {
		auto m = ManagedCall("SweepGradient", "createShader");
		m.put("this", this);
		m.put("rect", rect, true);
		m.put("textDirection", p.textDirection);
		shptr<class Shader> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class SweepGradient> /*non-null*/ SweepGradient::scale(/*non-null*/ double factor) {
		auto m = ManagedCall("SweepGradient", "scale");
		m.put("this", this);
		m.put("factor", factor);
		shptr<class SweepGradient> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Gradient> /*nullable*/ SweepGradient::lerpFrom(/*nullable*/ shptr<class Gradient> a, /*non-null*/ double t) {
		auto m = ManagedCall("SweepGradient", "lerpFrom");
		m.put("this", this);
		m.put("a", a);
		m.put("t", t);
		shptr<class Gradient> result;
		m.call(result);
		return result;
	}

	shptr<class Gradient> /*nullable*/ SweepGradient::lerpTo(/*nullable*/ shptr<class Gradient> b, /*non-null*/ double t) {
		auto m = ManagedCall("SweepGradient", "lerpTo");
		m.put("this", this);
		m.put("b", b);
		m.put("t", t);
		shptr<class Gradient> result;
		m.call(result);
		return result;
	}

	shptr<class SweepGradient> /*nullable*/ SweepGradient::lerp(/*nullable*/ shptr<class SweepGradient> a, /*nullable*/ shptr<class SweepGradient> b, /*non-null*/ double t) {
		auto m = ManagedCall("SweepGradient", "lerp");
		m.put("a", a);
		m.put("b", b);
		m.put("t", t);
		shptr<class SweepGradient> result;
		m.call(result);
		return result;
	}

	bool /*non-null*/ SweepGradient::equals(/*non-null*/ shptr<class ObjBase> other) {
		auto m = ManagedCall("SweepGradient", "==");
		m.put("this", this);
		m.put("other", other, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class SweepGradient> /*non-null*/ SweepGradient::ctorMain(_ctorMain p) {
		auto m = ManagedCall("SweepGradient", "SweepGradient");
		m.put("center", p.center, true);
		m.put("startAngle", p.startAngle);
		m.put("endAngle", p.endAngle);
		m.put("colors", p.colors);
		m.put("stops", p.stops);
		m.put("tileMode", p.tileMode);
		m.put("transform", p.transform);
		shptr<class SweepGradient> result;
		m.check(m.call(result, true));
		return result;
	}

	double /*var-non-null*/ CircleBorder::eccentricity() {
		auto m = ManagedCall("CircleBorder", "eccentricity");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	bool /*get-non-null*/ CircleBorder::preferPaintInterior() {
		auto m = ManagedCall("CircleBorder", "preferPaintInterior");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ShapeBorder> /*non-null*/ CircleBorder::scale(/*non-null*/ double t) {
		auto m = ManagedCall("CircleBorder", "scale");
		m.put("this", this);
		m.put("t", t);
		shptr<class ShapeBorder> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ShapeBorder> /*nullable*/ CircleBorder::lerpFrom(/*nullable*/ shptr<class ShapeBorder> a, /*non-null*/ double t) {
		auto m = ManagedCall("CircleBorder", "lerpFrom");
		m.put("this", this);
		m.put("a", a);
		m.put("t", t);
		shptr<class ShapeBorder> result;
		m.call(result);
		return result;
	}

	shptr<class ShapeBorder> /*nullable*/ CircleBorder::lerpTo(/*nullable*/ shptr<class ShapeBorder> b, /*non-null*/ double t) {
		auto m = ManagedCall("CircleBorder", "lerpTo");
		m.put("this", this);
		m.put("b", b);
		m.put("t", t);
		shptr<class ShapeBorder> result;
		m.call(result);
		return result;
	}

	shptr<class Path> /*non-null*/ CircleBorder::getInnerPath(/*non-null*/ shptr<class Rect> rect, _getInnerPath p) {
		auto m = ManagedCall("CircleBorder", "getInnerPath");
		m.put("this", this);
		m.put("rect", rect, true);
		m.put("textDirection", p.textDirection);
		shptr<class Path> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Path> /*non-null*/ CircleBorder::getOuterPath(/*non-null*/ shptr<class Rect> rect, _getOuterPath p) {
		auto m = ManagedCall("CircleBorder", "getOuterPath");
		m.put("this", this);
		m.put("rect", rect, true);
		m.put("textDirection", p.textDirection);
		shptr<class Path> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class CircleBorder> /*non-null*/ CircleBorder::copyWith(_copyWith p) {
		auto m = ManagedCall("CircleBorder", "copyWith");
		m.put("this", this);
		m.put("side", p.side);
		m.put("eccentricity", p.eccentricity);
		shptr<class CircleBorder> result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ CircleBorder::equals(/*non-null*/ shptr<class ObjBase> other) {
		auto m = ManagedCall("CircleBorder", "==");
		m.put("this", this);
		m.put("other", other, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class CircleBorder> /*non-null*/ CircleBorder::ctorMain(_ctorMain p) {
		auto m = ManagedCall("CircleBorder", "CircleBorder");
		m.put("side", p.side, true);
		m.put("eccentricity", p.eccentricity);
		shptr<class CircleBorder> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class ShapeBorder> /*non-null*/ OvalBorder::scale(/*non-null*/ double t) {
		auto m = ManagedCall("OvalBorder", "scale");
		m.put("this", this);
		m.put("t", t);
		shptr<class ShapeBorder> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class OvalBorder> /*non-null*/ OvalBorder::copyWith(_copyWith p) {
		auto m = ManagedCall("OvalBorder", "copyWith");
		m.put("this", this);
		m.put("side", p.side);
		m.put("eccentricity", p.eccentricity);
		shptr<class OvalBorder> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ShapeBorder> /*nullable*/ OvalBorder::lerpFrom(/*nullable*/ shptr<class ShapeBorder> a, /*non-null*/ double t) {
		auto m = ManagedCall("OvalBorder", "lerpFrom");
		m.put("this", this);
		m.put("a", a);
		m.put("t", t);
		shptr<class ShapeBorder> result;
		m.call(result);
		return result;
	}

	shptr<class ShapeBorder> /*nullable*/ OvalBorder::lerpTo(/*nullable*/ shptr<class ShapeBorder> b, /*non-null*/ double t) {
		auto m = ManagedCall("OvalBorder", "lerpTo");
		m.put("this", this);
		m.put("b", b);
		m.put("t", t);
		shptr<class ShapeBorder> result;
		m.call(result);
		return result;
	}

	shptr<class OvalBorder> /*non-null*/ OvalBorder::ctorMain(_ctorMain p) {
		auto m = ManagedCall("OvalBorder", "OvalBorder");
		m.put("side", p.side, true);
		m.put("eccentricity", p.eccentricity);
		shptr<class OvalBorder> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class BorderRadiusGeometry> /*var-non-null*/ RoundedRectangleBorder::borderRadius() {
		auto m = ManagedCall("RoundedRectangleBorder", "borderRadius");
		m.put("this", this);
		shptr<class BorderRadiusGeometry> result;
		m.check(m.call(result));
		return result;
	}

	bool /*get-non-null*/ RoundedRectangleBorder::preferPaintInterior() {
		auto m = ManagedCall("RoundedRectangleBorder", "preferPaintInterior");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ShapeBorder> /*non-null*/ RoundedRectangleBorder::scale(/*non-null*/ double t) {
		auto m = ManagedCall("RoundedRectangleBorder", "scale");
		m.put("this", this);
		m.put("t", t);
		shptr<class ShapeBorder> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ShapeBorder> /*nullable*/ RoundedRectangleBorder::lerpFrom(/*nullable*/ shptr<class ShapeBorder> a, /*non-null*/ double t) {
		auto m = ManagedCall("RoundedRectangleBorder", "lerpFrom");
		m.put("this", this);
		m.put("a", a);
		m.put("t", t);
		shptr<class ShapeBorder> result;
		m.call(result);
		return result;
	}

	shptr<class ShapeBorder> /*nullable*/ RoundedRectangleBorder::lerpTo(/*nullable*/ shptr<class ShapeBorder> b, /*non-null*/ double t) {
		auto m = ManagedCall("RoundedRectangleBorder", "lerpTo");
		m.put("this", this);
		m.put("b", b);
		m.put("t", t);
		shptr<class ShapeBorder> result;
		m.call(result);
		return result;
	}

	shptr<class RoundedRectangleBorder> /*non-null*/ RoundedRectangleBorder::copyWith(_copyWith p) {
		auto m = ManagedCall("RoundedRectangleBorder", "copyWith");
		m.put("this", this);
		m.put("side", p.side);
		m.put("borderRadius", p.borderRadius);
		shptr<class RoundedRectangleBorder> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Path> /*non-null*/ RoundedRectangleBorder::getInnerPath(/*non-null*/ shptr<class Rect> rect, _getInnerPath p) {
		auto m = ManagedCall("RoundedRectangleBorder", "getInnerPath");
		m.put("this", this);
		m.put("rect", rect, true);
		m.put("textDirection", p.textDirection);
		shptr<class Path> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Path> /*non-null*/ RoundedRectangleBorder::getOuterPath(/*non-null*/ shptr<class Rect> rect, _getOuterPath p) {
		auto m = ManagedCall("RoundedRectangleBorder", "getOuterPath");
		m.put("this", this);
		m.put("rect", rect, true);
		m.put("textDirection", p.textDirection);
		shptr<class Path> result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ RoundedRectangleBorder::equals(/*non-null*/ shptr<class ObjBase> other) {
		auto m = ManagedCall("RoundedRectangleBorder", "==");
		m.put("this", this);
		m.put("other", other, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class RoundedRectangleBorder> /*non-null*/ RoundedRectangleBorder::ctorMain(_ctorMain p) {
		auto m = ManagedCall("RoundedRectangleBorder", "RoundedRectangleBorder");
		m.put("side", p.side, true);
		m.put("borderRadius", p.borderRadius, true);
		shptr<class RoundedRectangleBorder> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class BorderSide> /*var-non-null*/ BorderDirectional::top() {
		auto m = ManagedCall("BorderDirectional", "top");
		m.put("this", this);
		shptr<class BorderSide> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class BorderSide> /*var-non-null*/ BorderDirectional::start() {
		auto m = ManagedCall("BorderDirectional", "start");
		m.put("this", this);
		shptr<class BorderSide> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class BorderSide> /*var-non-null*/ BorderDirectional::end() {
		auto m = ManagedCall("BorderDirectional", "end");
		m.put("this", this);
		shptr<class BorderSide> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class BorderSide> /*var-non-null*/ BorderDirectional::bottom() {
		auto m = ManagedCall("BorderDirectional", "bottom");
		m.put("this", this);
		shptr<class BorderSide> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class EdgeInsetsGeometry> /*get-non-null*/ BorderDirectional::dimensions() {
		auto m = ManagedCall("BorderDirectional", "dimensions");
		m.put("this", this);
		shptr<class EdgeInsetsGeometry> result;
		m.check(m.call(result));
		return result;
	}

	bool /*get-non-null*/ BorderDirectional::isUniform() {
		auto m = ManagedCall("BorderDirectional", "isUniform");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class BorderDirectional> /*non-null*/ BorderDirectional::merge(/*non-null*/ shptr<class BorderDirectional> a, /*non-null*/ shptr<class BorderDirectional> b) {
		auto m = ManagedCall("BorderDirectional", "merge");
		m.put("a", a, true);
		m.put("b", b, true);
		shptr<class BorderDirectional> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class BoxBorder> /*nullable*/ BorderDirectional::add(/*non-null*/ shptr<class ShapeBorder> other, _add p) {
		auto m = ManagedCall("BorderDirectional", "add");
		m.put("this", this);
		m.put("other", other, true);
		m.put("reversed", p.reversed);
		shptr<class BoxBorder> result;
		m.call(result);
		return result;
	}

	shptr<class BorderDirectional> /*non-null*/ BorderDirectional::scale(/*non-null*/ double t) {
		auto m = ManagedCall("BorderDirectional", "scale");
		m.put("this", this);
		m.put("t", t);
		shptr<class BorderDirectional> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ShapeBorder> /*nullable*/ BorderDirectional::lerpFrom(/*nullable*/ shptr<class ShapeBorder> a, /*non-null*/ double t) {
		auto m = ManagedCall("BorderDirectional", "lerpFrom");
		m.put("this", this);
		m.put("a", a);
		m.put("t", t);
		shptr<class ShapeBorder> result;
		m.call(result);
		return result;
	}

	shptr<class ShapeBorder> /*nullable*/ BorderDirectional::lerpTo(/*nullable*/ shptr<class ShapeBorder> b, /*non-null*/ double t) {
		auto m = ManagedCall("BorderDirectional", "lerpTo");
		m.put("this", this);
		m.put("b", b);
		m.put("t", t);
		shptr<class ShapeBorder> result;
		m.call(result);
		return result;
	}

	shptr<class BorderDirectional> /*nullable*/ BorderDirectional::lerp(/*nullable*/ shptr<class BorderDirectional> a, /*nullable*/ shptr<class BorderDirectional> b, /*non-null*/ double t) {
		auto m = ManagedCall("BorderDirectional", "lerp");
		m.put("a", a);
		m.put("b", b);
		m.put("t", t);
		shptr<class BorderDirectional> result;
		m.call(result);
		return result;
	}

	bool /*non-null*/ BorderDirectional::equals(/*non-null*/ shptr<class ObjBase> other) {
		auto m = ManagedCall("BorderDirectional", "==");
		m.put("this", this);
		m.put("other", other, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class BorderDirectional> /*non-null*/ BorderDirectional::ctorMain(_ctorMain p) {
		auto m = ManagedCall("BorderDirectional", "BorderDirectional");
		m.put("top", p.top, true);
		m.put("start", p.start, true);
		m.put("end", p.end, true);
		m.put("bottom", p.bottom, true);
		shptr<class BorderDirectional> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class BorderSide> /*var-non-null*/ Border::top() {
		auto m = ManagedCall("Border", "top");
		m.put("this", this);
		shptr<class BorderSide> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class BorderSide> /*var-non-null*/ Border::right() {
		auto m = ManagedCall("Border", "right");
		m.put("this", this);
		shptr<class BorderSide> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class BorderSide> /*var-non-null*/ Border::bottom() {
		auto m = ManagedCall("Border", "bottom");
		m.put("this", this);
		shptr<class BorderSide> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class BorderSide> /*var-non-null*/ Border::left() {
		auto m = ManagedCall("Border", "left");
		m.put("this", this);
		shptr<class BorderSide> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class EdgeInsetsGeometry> /*get-non-null*/ Border::dimensions() {
		auto m = ManagedCall("Border", "dimensions");
		m.put("this", this);
		shptr<class EdgeInsetsGeometry> result;
		m.check(m.call(result));
		return result;
	}

	bool /*get-non-null*/ Border::isUniform() {
		auto m = ManagedCall("Border", "isUniform");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Border> /*non-null*/ Border::merge(/*non-null*/ shptr<class Border> a, /*non-null*/ shptr<class Border> b) {
		auto m = ManagedCall("Border", "merge");
		m.put("a", a, true);
		m.put("b", b, true);
		shptr<class Border> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Border> /*nullable*/ Border::add(/*non-null*/ shptr<class ShapeBorder> other, _add p) {
		auto m = ManagedCall("Border", "add");
		m.put("this", this);
		m.put("other", other, true);
		m.put("reversed", p.reversed);
		shptr<class Border> result;
		m.call(result);
		return result;
	}

	shptr<class Border> /*non-null*/ Border::scale(/*non-null*/ double t) {
		auto m = ManagedCall("Border", "scale");
		m.put("this", this);
		m.put("t", t);
		shptr<class Border> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ShapeBorder> /*nullable*/ Border::lerpFrom(/*nullable*/ shptr<class ShapeBorder> a, /*non-null*/ double t) {
		auto m = ManagedCall("Border", "lerpFrom");
		m.put("this", this);
		m.put("a", a);
		m.put("t", t);
		shptr<class ShapeBorder> result;
		m.call(result);
		return result;
	}

	shptr<class ShapeBorder> /*nullable*/ Border::lerpTo(/*nullable*/ shptr<class ShapeBorder> b, /*non-null*/ double t) {
		auto m = ManagedCall("Border", "lerpTo");
		m.put("this", this);
		m.put("b", b);
		m.put("t", t);
		shptr<class ShapeBorder> result;
		m.call(result);
		return result;
	}

	shptr<class Border> /*nullable*/ Border::lerp(/*nullable*/ shptr<class Border> a, /*nullable*/ shptr<class Border> b, /*non-null*/ double t) {
		auto m = ManagedCall("Border", "lerp");
		m.put("a", a);
		m.put("b", b);
		m.put("t", t);
		shptr<class Border> result;
		m.call(result);
		return result;
	}

	bool /*non-null*/ Border::equals(/*non-null*/ shptr<class ObjBase> other) {
		auto m = ManagedCall("Border", "==");
		m.put("this", this);
		m.put("other", other, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Border> /*non-null*/ Border::ctorMain(_ctorMain p) {
		auto m = ManagedCall("Border", "Border");
		m.put("top", p.top, true);
		m.put("right", p.right, true);
		m.put("bottom", p.bottom, true);
		m.put("left", p.left, true);
		shptr<class Border> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Border> /*non-null*/ Border::fromBorderSide(/*non-null*/ shptr<class BorderSide> side) {
		auto m = ManagedCall("Border", "fromBorderSide");
		m.put("side", side, true);
		shptr<class Border> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Border> /*non-null*/ Border::symmetric(_symmetric p) {
		auto m = ManagedCall("Border", "symmetric");
		m.put("vertical", p.vertical, true);
		m.put("horizontal", p.horizontal, true);
		shptr<class Border> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Border> /*non-null*/ Border::all(_all p) {
		auto m = ManagedCall("Border", "all");
		m.put("color", p.color, true);
		m.put("width", p.width);
		m.put("style", p.style);
		m.put("strokeAlign", p.strokeAlign);
		shptr<class Border> result;
		m.check(m.call(result, true));
		return result;
	}

	bool /*var-non-null*/ TextStyle::inherit() {
		auto m = ManagedCall("TextStyle", "inherit");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*var-nullable*/ TextStyle::color() {
		auto m = ManagedCall("TextStyle", "color");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ TextStyle::backgroundColor() {
		auto m = ManagedCall("TextStyle", "backgroundColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	stdop<stdstr> /*var-nullable*/ TextStyle::fontFamily() {
		auto m = ManagedCall("TextStyle", "fontFamily");
		m.put("this", this);
		stdop<stdstr> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ TextStyle::fontSize() {
		auto m = ManagedCall("TextStyle", "fontSize");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	shptr<class FontWeight> /*var-nullable*/ TextStyle::fontWeight() {
		auto m = ManagedCall("TextStyle", "fontWeight");
		m.put("this", this);
		shptr<class FontWeight> result;
		m.call(result);
		return result;
	}

	stdop<FontStyle> /*var-nullable*/ TextStyle::fontStyle() {
		auto m = ManagedCall("TextStyle", "fontStyle");
		m.put("this", this);
		stdop<FontStyle> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ TextStyle::letterSpacing() {
		auto m = ManagedCall("TextStyle", "letterSpacing");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ TextStyle::wordSpacing() {
		auto m = ManagedCall("TextStyle", "wordSpacing");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	stdop<TextBaseline> /*var-nullable*/ TextStyle::textBaseline() {
		auto m = ManagedCall("TextStyle", "textBaseline");
		m.put("this", this);
		stdop<TextBaseline> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ TextStyle::height() {
		auto m = ManagedCall("TextStyle", "height");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	stdop<TextLeadingDistribution> /*var-nullable*/ TextStyle::leadingDistribution() {
		auto m = ManagedCall("TextStyle", "leadingDistribution");
		m.put("this", this);
		stdop<TextLeadingDistribution> result;
		m.call(result);
		return result;
	}

	shptr<class Locale> /*var-nullable*/ TextStyle::locale() {
		auto m = ManagedCall("TextStyle", "locale");
		m.put("this", this);
		shptr<class Locale> result;
		m.call(result);
		return result;
	}

	shptr<class Paint> /*var-nullable*/ TextStyle::foreground() {
		auto m = ManagedCall("TextStyle", "foreground");
		m.put("this", this);
		shptr<class Paint> result;
		m.call(result);
		return result;
	}

	shptr<class Paint> /*var-nullable*/ TextStyle::background() {
		auto m = ManagedCall("TextStyle", "background");
		m.put("this", this);
		shptr<class Paint> result;
		m.call(result);
		return result;
	}

	shptr<class TextDecoration> /*var-nullable*/ TextStyle::decoration() {
		auto m = ManagedCall("TextStyle", "decoration");
		m.put("this", this);
		shptr<class TextDecoration> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ TextStyle::decorationColor() {
		auto m = ManagedCall("TextStyle", "decorationColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	stdop<TextDecorationStyle> /*var-nullable*/ TextStyle::decorationStyle() {
		auto m = ManagedCall("TextStyle", "decorationStyle");
		m.put("this", this);
		stdop<TextDecorationStyle> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ TextStyle::decorationThickness() {
		auto m = ManagedCall("TextStyle", "decorationThickness");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	stdop<stdstr> /*var-nullable*/ TextStyle::debugLabel() {
		auto m = ManagedCall("TextStyle", "debugLabel");
		m.put("this", this);
		stdop<stdstr> result;
		m.call(result);
		return result;
	}

	stdop<TextOverflow> /*var-nullable*/ TextStyle::overflow() {
		auto m = ManagedCall("TextStyle", "overflow");
		m.put("this", this);
		stdop<TextOverflow> result;
		m.call(result);
		return result;
	}

	shptr<class TextStyle> /*non-null*/ TextStyle::copyWith(_copyWith p) {
		auto m = ManagedCall("TextStyle", "copyWith");
		m.put("this", this);
		m.put("inherit", p.inherit);
		m.put("color", p.color);
		m.put("backgroundColor", p.backgroundColor);
		m.put("fontSize", p.fontSize);
		m.put("fontWeight", p.fontWeight);
		m.put("fontStyle", p.fontStyle);
		m.put("letterSpacing", p.letterSpacing);
		m.put("wordSpacing", p.wordSpacing);
		m.put("textBaseline", p.textBaseline);
		m.put("height", p.height);
		m.put("leadingDistribution", p.leadingDistribution);
		m.put("locale", p.locale);
		m.put("foreground", p.foreground);
		m.put("background", p.background);
		m.put("shadows", p.shadows);
		m.put("fontFeatures", p.fontFeatures);
		m.put("fontVariations", p.fontVariations);
		m.put("decoration", p.decoration);
		m.put("decorationColor", p.decorationColor);
		m.put("decorationStyle", p.decorationStyle);
		m.put("decorationThickness", p.decorationThickness);
		m.put("debugLabel", p.debugLabel);
		m.put("fontFamily", p.fontFamily);
		m.put("fontFamilyFallback", p.fontFamilyFallback);
		m.put("package", p.package);
		m.put("overflow", p.overflow);
		shptr<class TextStyle> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class TextStyle> /*non-null*/ TextStyle::apply(_apply p) {
		auto m = ManagedCall("TextStyle", "apply");
		m.put("this", this);
		m.put("color", p.color);
		m.put("backgroundColor", p.backgroundColor);
		m.put("decoration", p.decoration);
		m.put("decorationColor", p.decorationColor);
		m.put("decorationStyle", p.decorationStyle);
		m.put("decorationThicknessFactor", p.decorationThicknessFactor);
		m.put("decorationThicknessDelta", p.decorationThicknessDelta);
		m.put("fontFamily", p.fontFamily);
		m.put("fontFamilyFallback", p.fontFamilyFallback);
		m.put("fontSizeFactor", p.fontSizeFactor);
		m.put("fontSizeDelta", p.fontSizeDelta);
		m.put("fontWeightDelta", p.fontWeightDelta);
		m.put("fontStyle", p.fontStyle);
		m.put("letterSpacingFactor", p.letterSpacingFactor);
		m.put("letterSpacingDelta", p.letterSpacingDelta);
		m.put("wordSpacingFactor", p.wordSpacingFactor);
		m.put("wordSpacingDelta", p.wordSpacingDelta);
		m.put("heightFactor", p.heightFactor);
		m.put("heightDelta", p.heightDelta);
		m.put("textBaseline", p.textBaseline);
		m.put("leadingDistribution", p.leadingDistribution);
		m.put("locale", p.locale);
		m.put("shadows", p.shadows);
		m.put("fontFeatures", p.fontFeatures);
		m.put("fontVariations", p.fontVariations);
		m.put("package", p.package);
		m.put("overflow", p.overflow);
		shptr<class TextStyle> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class TextStyle> /*non-null*/ TextStyle::merge(/*nullable*/ shptr<class TextStyle> other) {
		auto m = ManagedCall("TextStyle", "merge");
		m.put("this", this);
		m.put("other", other);
		shptr<class TextStyle> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class TextStyle> /*nullable*/ TextStyle::lerp(/*nullable*/ shptr<class TextStyle> a, /*nullable*/ shptr<class TextStyle> b, /*non-null*/ double t) {
		auto m = ManagedCall("TextStyle", "lerp");
		m.put("a", a);
		m.put("b", b);
		m.put("t", t);
		shptr<class TextStyle> result;
		m.call(result);
		return result;
	}

	shptr<class TextStyle> /*non-null*/ TextStyle::getTextStyle(_getTextStyle p) {
		auto m = ManagedCall("TextStyle", "getTextStyle");
		m.put("this", this);
		m.put("textScaleFactor", p.textScaleFactor);
		shptr<class TextStyle> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ParagraphStyle> /*non-null*/ TextStyle::getParagraphStyle(_getParagraphStyle p) {
		auto m = ManagedCall("TextStyle", "getParagraphStyle");
		m.put("this", this);
		m.put("textAlign", p.textAlign);
		m.put("textDirection", p.textDirection);
		m.put("textScaleFactor", p.textScaleFactor);
		m.put("ellipsis", p.ellipsis);
		m.put("maxLines", p.maxLines);
		m.put("textHeightBehavior", p.textHeightBehavior);
		m.put("locale", p.locale);
		m.put("fontFamily", p.fontFamily);
		m.put("fontSize", p.fontSize);
		m.put("fontWeight", p.fontWeight);
		m.put("fontStyle", p.fontStyle);
		m.put("height", p.height);
		m.put("strutStyle", p.strutStyle);
		shptr<class ParagraphStyle> result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ TextStyle::equals(/*non-null*/ shptr<class ObjBase> other) {
		auto m = ManagedCall("TextStyle", "==");
		m.put("this", this);
		m.put("other", other, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	stdstr /*non-null*/ TextStyle::toStringShort() {
		auto m = ManagedCall("TextStyle", "toStringShort");
		m.put("this", this);
		stdstr result;
		m.check(m.call(result));
		return result;
	}

	shptr<class TextStyle> /*non-null*/ TextStyle::ctorMain(_ctorMain p) {
		auto m = ManagedCall("TextStyle", "TextStyle");
		m.put("inherit", p.inherit);
		m.put("color", p.color);
		m.put("backgroundColor", p.backgroundColor);
		m.put("fontSize", p.fontSize);
		m.put("fontWeight", p.fontWeight);
		m.put("fontStyle", p.fontStyle);
		m.put("letterSpacing", p.letterSpacing);
		m.put("wordSpacing", p.wordSpacing);
		m.put("textBaseline", p.textBaseline);
		m.put("height", p.height);
		m.put("leadingDistribution", p.leadingDistribution);
		m.put("locale", p.locale);
		m.put("foreground", p.foreground);
		m.put("background", p.background);
		m.put("shadows", p.shadows);
		m.put("fontFeatures", p.fontFeatures);
		m.put("fontVariations", p.fontVariations);
		m.put("decoration", p.decoration);
		m.put("decorationColor", p.decorationColor);
		m.put("decorationStyle", p.decorationStyle);
		m.put("decorationThickness", p.decorationThickness);
		m.put("debugLabel", p.debugLabel);
		m.put("fontFamily", p.fontFamily);
		m.put("fontFamilyFallback", p.fontFamilyFallback);
		m.put("package", p.package);
		m.put("overflow", p.overflow);
		shptr<class TextStyle> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class StrutStyle> /*var-non-null*/ StrutStyle::disabled() {
		auto m = ManagedCall("StrutStyle", "disabled");
		shptr<class StrutStyle> result;
		m.check(m.call(result));
		return result;
	}

	stdop<stdstr> /*var-nullable*/ StrutStyle::fontFamily() {
		auto m = ManagedCall("StrutStyle", "fontFamily");
		m.put("this", this);
		stdop<stdstr> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ StrutStyle::fontSize() {
		auto m = ManagedCall("StrutStyle", "fontSize");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ StrutStyle::height() {
		auto m = ManagedCall("StrutStyle", "height");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	stdop<TextLeadingDistribution> /*var-nullable*/ StrutStyle::leadingDistribution() {
		auto m = ManagedCall("StrutStyle", "leadingDistribution");
		m.put("this", this);
		stdop<TextLeadingDistribution> result;
		m.call(result);
		return result;
	}

	shptr<class FontWeight> /*var-nullable*/ StrutStyle::fontWeight() {
		auto m = ManagedCall("StrutStyle", "fontWeight");
		m.put("this", this);
		shptr<class FontWeight> result;
		m.call(result);
		return result;
	}

	stdop<FontStyle> /*var-nullable*/ StrutStyle::fontStyle() {
		auto m = ManagedCall("StrutStyle", "fontStyle");
		m.put("this", this);
		stdop<FontStyle> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ StrutStyle::leading() {
		auto m = ManagedCall("StrutStyle", "leading");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	stdop<bool> /*var-nullable*/ StrutStyle::forceStrutHeight() {
		auto m = ManagedCall("StrutStyle", "forceStrutHeight");
		m.put("this", this);
		stdop<bool> result;
		m.call(result);
		return result;
	}

	stdop<stdstr> /*var-nullable*/ StrutStyle::debugLabel() {
		auto m = ManagedCall("StrutStyle", "debugLabel");
		m.put("this", this);
		stdop<stdstr> result;
		m.call(result);
		return result;
	}

	RenderComparison /*non-null*/ StrutStyle::compareTo(/*non-null*/ shptr<class StrutStyle> other) {
		auto m = ManagedCall("StrutStyle", "compareTo");
		m.put("this", this);
		m.put("other", other, true);
		RenderComparison result;
		m.check(m.call(result));
		return result;
	}

	shptr<class StrutStyle> /*non-null*/ StrutStyle::inheritFromTextStyle(/*nullable*/ shptr<class TextStyle> other) {
		auto m = ManagedCall("StrutStyle", "inheritFromTextStyle");
		m.put("this", this);
		m.put("other", other);
		shptr<class StrutStyle> result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ StrutStyle::equals(/*non-null*/ shptr<class ObjBase> other) {
		auto m = ManagedCall("StrutStyle", "==");
		m.put("this", this);
		m.put("other", other, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	stdstr /*non-null*/ StrutStyle::toStringShort() {
		auto m = ManagedCall("StrutStyle", "toStringShort");
		m.put("this", this);
		stdstr result;
		m.check(m.call(result));
		return result;
	}

	shptr<class StrutStyle> /*non-null*/ StrutStyle::ctorMain(_ctorMain p) {
		auto m = ManagedCall("StrutStyle", "StrutStyle");
		m.put("fontFamily", p.fontFamily);
		m.put("fontFamilyFallback", p.fontFamilyFallback);
		m.put("fontSize", p.fontSize);
		m.put("height", p.height);
		m.put("leadingDistribution", p.leadingDistribution);
		m.put("leading", p.leading);
		m.put("fontWeight", p.fontWeight);
		m.put("fontStyle", p.fontStyle);
		m.put("forceStrutHeight", p.forceStrutHeight);
		m.put("debugLabel", p.debugLabel);
		m.put("package", p.package);
		shptr<class StrutStyle> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class StrutStyle> /*non-null*/ StrutStyle::fromTextStyle(/*non-null*/ shptr<class TextStyle> textStyle, _fromTextStyle p) {
		auto m = ManagedCall("StrutStyle", "fromTextStyle");
		m.put("textStyle", textStyle, true);
		m.put("fontFamily", p.fontFamily);
		m.put("fontFamilyFallback", p.fontFamilyFallback);
		m.put("fontSize", p.fontSize);
		m.put("height", p.height);
		m.put("leadingDistribution", p.leadingDistribution);
		m.put("leading", p.leading);
		m.put("fontWeight", p.fontWeight);
		m.put("fontStyle", p.fontStyle);
		m.put("forceStrutHeight", p.forceStrutHeight);
		m.put("debugLabel", p.debugLabel);
		m.put("package", p.package);
		shptr<class StrutStyle> result;
		m.check(m.call(result, true));
		return result;
	}

	int64 /*var-non-null*/ FontWeight::index() {
		auto m = ManagedCall("FontWeight", "index");
		m.put("this", this);
		int64 result;
		m.check(m.call(result));
		return result;
	}

	int64 /*var-non-null*/ FontWeight::value() {
		auto m = ManagedCall("FontWeight", "value");
		m.put("this", this);
		int64 result;
		m.check(m.call(result));
		return result;
	}

	shptr<class FontWeight> /*var-non-null*/ FontWeight::w100() {
		auto m = ManagedCall("FontWeight", "w100");
		shptr<class FontWeight> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class FontWeight> /*var-non-null*/ FontWeight::w200() {
		auto m = ManagedCall("FontWeight", "w200");
		shptr<class FontWeight> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class FontWeight> /*var-non-null*/ FontWeight::w300() {
		auto m = ManagedCall("FontWeight", "w300");
		shptr<class FontWeight> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class FontWeight> /*var-non-null*/ FontWeight::w400() {
		auto m = ManagedCall("FontWeight", "w400");
		shptr<class FontWeight> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class FontWeight> /*var-non-null*/ FontWeight::w500() {
		auto m = ManagedCall("FontWeight", "w500");
		shptr<class FontWeight> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class FontWeight> /*var-non-null*/ FontWeight::w600() {
		auto m = ManagedCall("FontWeight", "w600");
		shptr<class FontWeight> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class FontWeight> /*var-non-null*/ FontWeight::w700() {
		auto m = ManagedCall("FontWeight", "w700");
		shptr<class FontWeight> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class FontWeight> /*var-non-null*/ FontWeight::w800() {
		auto m = ManagedCall("FontWeight", "w800");
		shptr<class FontWeight> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class FontWeight> /*var-non-null*/ FontWeight::w900() {
		auto m = ManagedCall("FontWeight", "w900");
		shptr<class FontWeight> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class FontWeight> /*var-non-null*/ FontWeight::normal() {
		auto m = ManagedCall("FontWeight", "normal");
		shptr<class FontWeight> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class FontWeight> /*var-non-null*/ FontWeight::bold() {
		auto m = ManagedCall("FontWeight", "bold");
		shptr<class FontWeight> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class FontWeight> /*nullable*/ FontWeight::lerp(/*nullable*/ shptr<class FontWeight> a, /*nullable*/ shptr<class FontWeight> b, /*non-null*/ double t) {
		auto m = ManagedCall("FontWeight", "lerp");
		m.put("a", a);
		m.put("b", b);
		m.put("t", t);
		shptr<class FontWeight> result;
		m.call(result);
		return result;
	}

	double /*var-non-null*/ FileImage::scale() {
		auto m = ManagedCall("FileImage", "scale");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ FileImage::equals(/*non-null*/ shptr<class ObjBase> other) {
		auto m = ManagedCall("FileImage", "==");
		m.put("this", this);
		m.put("other", other, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class FileImage> /*non-null*/ FileImage::ctorMain(/*non-null*/ stdstr file, _ctorMain p) {
		auto m = ManagedCall("FileImage", "FileImage");
		m.put("file", file);
		m.put("scale", p.scale);
		shptr<class FileImage> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Uint8List> /*var-non-null*/ MemoryImage::bytes() {
		auto m = ManagedCall("MemoryImage", "bytes");
		m.put("this", this);
		shptr<class Uint8List> result;
		m.check(m.call(result));
		return result;
	}

	double /*var-non-null*/ MemoryImage::scale() {
		auto m = ManagedCall("MemoryImage", "scale");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ MemoryImage::equals(/*non-null*/ shptr<class ObjBase> other) {
		auto m = ManagedCall("MemoryImage", "==");
		m.put("this", this);
		m.put("other", other, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class MemoryImage> /*non-null*/ MemoryImage::ctorMain(/*non-null*/ shptr<class Uint8List> bytes, _ctorMain p) {
		auto m = ManagedCall("MemoryImage", "MemoryImage");
		m.put("bytes", bytes, true);
		m.put("scale", p.scale);
		shptr<class MemoryImage> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class ImageFilter> /*non-null*/ ImageFilter::blur(_blur p) {
		auto m = ManagedCall("ImageFilter", "blur");
		m.put("sigmaX", p.sigmaX);
		m.put("sigmaY", p.sigmaY);
		m.put("tileMode", p.tileMode);
		shptr<class ImageFilter> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class ImageFilter> /*non-null*/ ImageFilter::dilate(_dilate p) {
		auto m = ManagedCall("ImageFilter", "dilate");
		m.put("radiusX", p.radiusX);
		m.put("radiusY", p.radiusY);
		shptr<class ImageFilter> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class ImageFilter> /*non-null*/ ImageFilter::erode(_erode p) {
		auto m = ManagedCall("ImageFilter", "erode");
		m.put("radiusX", p.radiusX);
		m.put("radiusY", p.radiusY);
		shptr<class ImageFilter> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class ImageFilter> /*non-null*/ ImageFilter::matrix(/*non-null*/ shptr<class Float64List> matrix4, _matrix p) {
		auto m = ManagedCall("ImageFilter", "matrix");
		m.put("matrix4", matrix4, true);
		m.put("filterQuality", p.filterQuality);
		shptr<class ImageFilter> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class ImageFilter> /*non-null*/ ImageFilter::compose(_compose p) {
		auto m = ManagedCall("ImageFilter", "compose");
		m.put("outer", p.outer, true);
		m.put("inner", p.inner, true);
		shptr<class ImageFilter> result;
		m.check(m.call(result, true));
		return result;
	}

	bool /*non-null*/ ColorFilter::equals(/*non-null*/ shptr<class ObjBase> other) {
		auto m = ManagedCall("ColorFilter", "==");
		m.put("this", this);
		m.put("other", other, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ColorFilter> /*non-null*/ ColorFilter::mode(/*non-null*/ shptr<class Color> color, /*non-null*/ BlendMode blendMode) {
		auto m = ManagedCall("ColorFilter", "mode");
		m.put("color", color, true);
		m.put("blendMode", blendMode);
		shptr<class ColorFilter> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class ColorFilter> /*non-null*/ ColorFilter::matrix(/*non-null*/ stdvec<double> matrix) {
		auto m = ManagedCall("ColorFilter", "matrix");
		m.put("matrix", matrix);
		shptr<class ColorFilter> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class ColorFilter> /*non-null*/ ColorFilter::linearToSrgbGamma() {
		auto m = ManagedCall("ColorFilter", "linearToSrgbGamma");
		shptr<class ColorFilter> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class ColorFilter> /*non-null*/ ColorFilter::srgbToLinearGamma() {
		auto m = ManagedCall("ColorFilter", "srgbToLinearGamma");
		shptr<class ColorFilter> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class ColorFilter> /*var-nullable*/ DecorationImage::colorFilter() {
		auto m = ManagedCall("DecorationImage", "colorFilter");
		m.put("this", this);
		shptr<class ColorFilter> result;
		m.call(result);
		return result;
	}

	stdop<BoxFit> /*var-nullable*/ DecorationImage::fit() {
		auto m = ManagedCall("DecorationImage", "fit");
		m.put("this", this);
		stdop<BoxFit> result;
		m.call(result);
		return result;
	}

	shptr<class AlignmentGeometry> /*var-non-null*/ DecorationImage::alignment() {
		auto m = ManagedCall("DecorationImage", "alignment");
		m.put("this", this);
		shptr<class AlignmentGeometry> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Rect> /*var-nullable*/ DecorationImage::centerSlice() {
		auto m = ManagedCall("DecorationImage", "centerSlice");
		m.put("this", this);
		shptr<class Rect> result;
		m.call(result);
		return result;
	}

	ImageRepeat /*var-non-null*/ DecorationImage::repeat() {
		auto m = ManagedCall("DecorationImage", "repeat");
		m.put("this", this);
		ImageRepeat result;
		m.check(m.call(result));
		return result;
	}

	bool /*var-non-null*/ DecorationImage::matchTextDirection() {
		auto m = ManagedCall("DecorationImage", "matchTextDirection");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	double /*var-non-null*/ DecorationImage::scale() {
		auto m = ManagedCall("DecorationImage", "scale");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	double /*var-non-null*/ DecorationImage::opacity() {
		auto m = ManagedCall("DecorationImage", "opacity");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	FilterQuality /*var-non-null*/ DecorationImage::filterQuality() {
		auto m = ManagedCall("DecorationImage", "filterQuality");
		m.put("this", this);
		FilterQuality result;
		m.check(m.call(result));
		return result;
	}

	bool /*var-non-null*/ DecorationImage::invertColors() {
		auto m = ManagedCall("DecorationImage", "invertColors");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	bool /*var-non-null*/ DecorationImage::isAntiAlias() {
		auto m = ManagedCall("DecorationImage", "isAntiAlias");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class DecorationImagePainter> /*non-null*/ DecorationImage::createPainter(/*non-null*/ stdfunc<void()> /*() -> void*/ onChanged) {
		auto m = ManagedCall("DecorationImage", "createPainter");
		m.put("this", this);
		m.put("onChanged", onChanged, true);
		shptr<class DecorationImagePainter> result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ DecorationImage::equals(/*non-null*/ shptr<class ObjBase> other) {
		auto m = ManagedCall("DecorationImage", "==");
		m.put("this", this);
		m.put("other", other, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class DecorationImage> /*non-null*/ DecorationImage::ctorMain(_ctorMain p) {
		auto m = ManagedCall("DecorationImage", "DecorationImage");
		m.put("image", p.image, true);
//		m.put("onError", p.onError);
		m.put("colorFilter", p.colorFilter);
		m.put("fit", p.fit);
		m.put("alignment", p.alignment, true);
		m.put("centerSlice", p.centerSlice);
		m.put("repeat", p.repeat);
		m.put("matchTextDirection", p.matchTextDirection);
		m.put("scale", p.scale);
		m.put("opacity", p.opacity);
		m.put("filterQuality", p.filterQuality);
		m.put("invertColors", p.invertColors);
		m.put("isAntiAlias", p.isAntiAlias);
		shptr<class DecorationImage> result;
		m.check(m.call(result, true));
		return result;
	}

	double /*var-non-null*/ BoxConstraints::minWidth() {
		auto m = ManagedCall("BoxConstraints", "minWidth");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	double /*var-non-null*/ BoxConstraints::maxWidth() {
		auto m = ManagedCall("BoxConstraints", "maxWidth");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	double /*var-non-null*/ BoxConstraints::minHeight() {
		auto m = ManagedCall("BoxConstraints", "minHeight");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	double /*var-non-null*/ BoxConstraints::maxHeight() {
		auto m = ManagedCall("BoxConstraints", "maxHeight");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	shptr<class BoxConstraints> /*get-non-null*/ BoxConstraints::flipped() {
		auto m = ManagedCall("BoxConstraints", "flipped");
		m.put("this", this);
		shptr<class BoxConstraints> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Size> /*get-non-null*/ BoxConstraints::biggest() {
		auto m = ManagedCall("BoxConstraints", "biggest");
		m.put("this", this);
		shptr<class Size> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Size> /*get-non-null*/ BoxConstraints::smallest() {
		auto m = ManagedCall("BoxConstraints", "smallest");
		m.put("this", this);
		shptr<class Size> result;
		m.check(m.call(result));
		return result;
	}

	bool /*get-non-null*/ BoxConstraints::hasTightWidth() {
		auto m = ManagedCall("BoxConstraints", "hasTightWidth");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	bool /*get-non-null*/ BoxConstraints::hasTightHeight() {
		auto m = ManagedCall("BoxConstraints", "hasTightHeight");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	bool /*get-non-null*/ BoxConstraints::isTight() {
		auto m = ManagedCall("BoxConstraints", "isTight");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	bool /*get-non-null*/ BoxConstraints::hasBoundedWidth() {
		auto m = ManagedCall("BoxConstraints", "hasBoundedWidth");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	bool /*get-non-null*/ BoxConstraints::hasBoundedHeight() {
		auto m = ManagedCall("BoxConstraints", "hasBoundedHeight");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	bool /*get-non-null*/ BoxConstraints::hasInfiniteWidth() {
		auto m = ManagedCall("BoxConstraints", "hasInfiniteWidth");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	bool /*get-non-null*/ BoxConstraints::hasInfiniteHeight() {
		auto m = ManagedCall("BoxConstraints", "hasInfiniteHeight");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	bool /*get-non-null*/ BoxConstraints::isNormalized() {
		auto m = ManagedCall("BoxConstraints", "isNormalized");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class BoxConstraints> /*non-null*/ BoxConstraints::copyWith(_copyWith p) {
		auto m = ManagedCall("BoxConstraints", "copyWith");
		m.put("this", this);
		m.put("minWidth", p.minWidth);
		m.put("maxWidth", p.maxWidth);
		m.put("minHeight", p.minHeight);
		m.put("maxHeight", p.maxHeight);
		shptr<class BoxConstraints> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class BoxConstraints> /*non-null*/ BoxConstraints::deflate(/*non-null*/ shptr<class EdgeInsets> edges) {
		auto m = ManagedCall("BoxConstraints", "deflate");
		m.put("this", this);
		m.put("edges", edges, true);
		shptr<class BoxConstraints> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class BoxConstraints> /*non-null*/ BoxConstraints::loosen() {
		auto m = ManagedCall("BoxConstraints", "loosen");
		m.put("this", this);
		shptr<class BoxConstraints> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class BoxConstraints> /*non-null*/ BoxConstraints::enforce(/*non-null*/ shptr<class BoxConstraints> constraints) {
		auto m = ManagedCall("BoxConstraints", "enforce");
		m.put("this", this);
		m.put("constraints", constraints, true);
		shptr<class BoxConstraints> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class BoxConstraints> /*non-null*/ BoxConstraints::tighten(_tighten p) {
		auto m = ManagedCall("BoxConstraints", "tighten");
		m.put("this", this);
		m.put("width", p.width);
		m.put("height", p.height);
		shptr<class BoxConstraints> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class BoxConstraints> /*non-null*/ BoxConstraints::widthConstraints() {
		auto m = ManagedCall("BoxConstraints", "widthConstraints");
		m.put("this", this);
		shptr<class BoxConstraints> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class BoxConstraints> /*non-null*/ BoxConstraints::heightConstraints() {
		auto m = ManagedCall("BoxConstraints", "heightConstraints");
		m.put("this", this);
		shptr<class BoxConstraints> result;
		m.check(m.call(result));
		return result;
	}

	double /*non-null*/ BoxConstraints::constrainWidth(/*non-null*/ double width) {
		auto m = ManagedCall("BoxConstraints", "constrainWidth");
		m.put("this", this);
		m.put("width", width);
		double result;
		m.check(m.call(result));
		return result;
	}

	double /*non-null*/ BoxConstraints::constrainHeight(/*non-null*/ double height) {
		auto m = ManagedCall("BoxConstraints", "constrainHeight");
		m.put("this", this);
		m.put("height", height);
		double result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Size> /*non-null*/ BoxConstraints::constrain(/*non-null*/ shptr<class Size> size) {
		auto m = ManagedCall("BoxConstraints", "constrain");
		m.put("this", this);
		m.put("size", size, true);
		shptr<class Size> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Size> /*non-null*/ BoxConstraints::constrainDimensions(/*non-null*/ double width, /*non-null*/ double height) {
		auto m = ManagedCall("BoxConstraints", "constrainDimensions");
		m.put("this", this);
		m.put("width", width);
		m.put("height", height);
		shptr<class Size> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Size> /*non-null*/ BoxConstraints::constrainSizeAndAttemptToPreserveAspectRatio(/*non-null*/ shptr<class Size> size) {
		auto m = ManagedCall("BoxConstraints", "constrainSizeAndAttemptToPreserveAspectRatio");
		m.put("this", this);
		m.put("size", size, true);
		shptr<class Size> result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ BoxConstraints::isSatisfiedBy(/*non-null*/ shptr<class Size> size) {
		auto m = ManagedCall("BoxConstraints", "isSatisfiedBy");
		m.put("this", this);
		m.put("size", size, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class BoxConstraints> /*non-null*/ BoxConstraints::mul(/*non-null*/ double factor) {
		auto m = ManagedCall("BoxConstraints", "*");
		m.put("this", this);
		m.put("factor", factor);
		shptr<class BoxConstraints> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class BoxConstraints> /*non-null*/ BoxConstraints::div(/*non-null*/ double factor) {
		auto m = ManagedCall("BoxConstraints", "/");
		m.put("this", this);
		m.put("factor", factor);
		shptr<class BoxConstraints> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class BoxConstraints> /*non-null*/ BoxConstraints::idiv(/*non-null*/ double factor) {
		auto m = ManagedCall("BoxConstraints", "~/");
		m.put("this", this);
		m.put("factor", factor);
		shptr<class BoxConstraints> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class BoxConstraints> /*non-null*/ BoxConstraints::mod(/*non-null*/ double value) {
		auto m = ManagedCall("BoxConstraints", "%");
		m.put("this", this);
		m.put("value", value);
		shptr<class BoxConstraints> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class BoxConstraints> /*nullable*/ BoxConstraints::lerp(/*nullable*/ shptr<class BoxConstraints> a, /*nullable*/ shptr<class BoxConstraints> b, /*non-null*/ double t) {
		auto m = ManagedCall("BoxConstraints", "lerp");
		m.put("a", a);
		m.put("b", b);
		m.put("t", t);
		shptr<class BoxConstraints> result;
		m.call(result);
		return result;
	}

	shptr<class BoxConstraints> /*non-null*/ BoxConstraints::normalize() {
		auto m = ManagedCall("BoxConstraints", "normalize");
		m.put("this", this);
		shptr<class BoxConstraints> result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ BoxConstraints::equals(/*non-null*/ shptr<class ObjBase> other) {
		auto m = ManagedCall("BoxConstraints", "==");
		m.put("this", this);
		m.put("other", other, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class BoxConstraints> /*non-null*/ BoxConstraints::ctorMain(_ctorMain p) {
		auto m = ManagedCall("BoxConstraints", "BoxConstraints");
		m.put("minWidth", p.minWidth);
		m.put("maxWidth", p.maxWidth);
		m.put("minHeight", p.minHeight);
		m.put("maxHeight", p.maxHeight);
		shptr<class BoxConstraints> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class BoxConstraints> /*non-null*/ BoxConstraints::tight(/*non-null*/ shptr<class Size> size) {
		auto m = ManagedCall("BoxConstraints", "tight");
		m.put("size", size, true);
		shptr<class BoxConstraints> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class BoxConstraints> /*non-null*/ BoxConstraints::tightFor(_tightFor p) {
		auto m = ManagedCall("BoxConstraints", "tightFor");
		m.put("width", p.width);
		m.put("height", p.height);
		shptr<class BoxConstraints> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class BoxConstraints> /*non-null*/ BoxConstraints::tightForFinite(_tightForFinite p) {
		auto m = ManagedCall("BoxConstraints", "tightForFinite");
		m.put("width", p.width);
		m.put("height", p.height);
		shptr<class BoxConstraints> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class BoxConstraints> /*non-null*/ BoxConstraints::loose(/*non-null*/ shptr<class Size> size) {
		auto m = ManagedCall("BoxConstraints", "loose");
		m.put("size", size, true);
		shptr<class BoxConstraints> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class BoxConstraints> /*non-null*/ BoxConstraints::expand(_expand p) {
		auto m = ManagedCall("BoxConstraints", "expand");
		m.put("width", p.width);
		m.put("height", p.height);
		shptr<class BoxConstraints> result;
		m.check(m.call(result, true));
		return result;
	}

	PathFillType /*get-non-null*/ Path::fillType() {
		auto m = ManagedCall("Path", "fillType");
		m.put("this", this);
		PathFillType result;
		m.check(m.call(result));
		return result;
	}

	void Path::moveTo(/*non-null*/ double x, /*non-null*/ double y) {
		auto m = ManagedCall("Path", "moveTo");
		m.put("this", this);
		m.put("x", x);
		m.put("y", y);
		m.call();
	}

	void Path::relativeMoveTo(/*non-null*/ double dx, /*non-null*/ double dy) {
		auto m = ManagedCall("Path", "relativeMoveTo");
		m.put("this", this);
		m.put("dx", dx);
		m.put("dy", dy);
		m.call();
	}

	void Path::lineTo(/*non-null*/ double x, /*non-null*/ double y) {
		auto m = ManagedCall("Path", "lineTo");
		m.put("this", this);
		m.put("x", x);
		m.put("y", y);
		m.call();
	}

	void Path::relativeLineTo(/*non-null*/ double dx, /*non-null*/ double dy) {
		auto m = ManagedCall("Path", "relativeLineTo");
		m.put("this", this);
		m.put("dx", dx);
		m.put("dy", dy);
		m.call();
	}

	void Path::quadraticBezierTo(/*non-null*/ double x1, /*non-null*/ double y1, /*non-null*/ double x2, /*non-null*/ double y2) {
		auto m = ManagedCall("Path", "quadraticBezierTo");
		m.put("this", this);
		m.put("x1", x1);
		m.put("y1", y1);
		m.put("x2", x2);
		m.put("y2", y2);
		m.call();
	}

	void Path::relativeQuadraticBezierTo(/*non-null*/ double x1, /*non-null*/ double y1, /*non-null*/ double x2, /*non-null*/ double y2) {
		auto m = ManagedCall("Path", "relativeQuadraticBezierTo");
		m.put("this", this);
		m.put("x1", x1);
		m.put("y1", y1);
		m.put("x2", x2);
		m.put("y2", y2);
		m.call();
	}

	void Path::cubicTo(/*non-null*/ double x1, /*non-null*/ double y1, /*non-null*/ double x2, /*non-null*/ double y2, /*non-null*/ double x3, /*non-null*/ double y3) {
		auto m = ManagedCall("Path", "cubicTo");
		m.put("this", this);
		m.put("x1", x1);
		m.put("y1", y1);
		m.put("x2", x2);
		m.put("y2", y2);
		m.put("x3", x3);
		m.put("y3", y3);
		m.call();
	}

	void Path::relativeCubicTo(/*non-null*/ double x1, /*non-null*/ double y1, /*non-null*/ double x2, /*non-null*/ double y2, /*non-null*/ double x3, /*non-null*/ double y3) {
		auto m = ManagedCall("Path", "relativeCubicTo");
		m.put("this", this);
		m.put("x1", x1);
		m.put("y1", y1);
		m.put("x2", x2);
		m.put("y2", y2);
		m.put("x3", x3);
		m.put("y3", y3);
		m.call();
	}

	void Path::conicTo(/*non-null*/ double x1, /*non-null*/ double y1, /*non-null*/ double x2, /*non-null*/ double y2, /*non-null*/ double w) {
		auto m = ManagedCall("Path", "conicTo");
		m.put("this", this);
		m.put("x1", x1);
		m.put("y1", y1);
		m.put("x2", x2);
		m.put("y2", y2);
		m.put("w", w);
		m.call();
	}

	void Path::relativeConicTo(/*non-null*/ double x1, /*non-null*/ double y1, /*non-null*/ double x2, /*non-null*/ double y2, /*non-null*/ double w) {
		auto m = ManagedCall("Path", "relativeConicTo");
		m.put("this", this);
		m.put("x1", x1);
		m.put("y1", y1);
		m.put("x2", x2);
		m.put("y2", y2);
		m.put("w", w);
		m.call();
	}

	void Path::arcTo(/*non-null*/ shptr<class Rect> rect, /*non-null*/ double startAngle, /*non-null*/ double sweepAngle, /*non-null*/ bool forceMoveTo) {
		auto m = ManagedCall("Path", "arcTo");
		m.put("this", this);
		m.put("rect", rect, true);
		m.put("startAngle", startAngle);
		m.put("sweepAngle", sweepAngle);
		m.put("forceMoveTo", forceMoveTo);
		m.call();
	}

	void Path::arcToPoint(/*non-null*/ shptr<class Offset> arcEnd, _arcToPoint p) {
		auto m = ManagedCall("Path", "arcToPoint");
		m.put("this", this);
		m.put("arcEnd", arcEnd, true);
		m.put("radius", p.radius, true);
		m.put("rotation", p.rotation);
		m.put("largeArc", p.largeArc);
		m.put("clockwise", p.clockwise);
		m.call();
	}

	void Path::relativeArcToPoint(/*non-null*/ shptr<class Offset> arcEndDelta, _relativeArcToPoint p) {
		auto m = ManagedCall("Path", "relativeArcToPoint");
		m.put("this", this);
		m.put("arcEndDelta", arcEndDelta, true);
		m.put("radius", p.radius, true);
		m.put("rotation", p.rotation);
		m.put("largeArc", p.largeArc);
		m.put("clockwise", p.clockwise);
		m.call();
	}

	void Path::addRect(/*non-null*/ shptr<class Rect> rect) {
		auto m = ManagedCall("Path", "addRect");
		m.put("this", this);
		m.put("rect", rect, true);
		m.call();
	}

	void Path::addOval(/*non-null*/ shptr<class Rect> oval) {
		auto m = ManagedCall("Path", "addOval");
		m.put("this", this);
		m.put("oval", oval, true);
		m.call();
	}

	void Path::addArc(/*non-null*/ shptr<class Rect> oval, /*non-null*/ double startAngle, /*non-null*/ double sweepAngle) {
		auto m = ManagedCall("Path", "addArc");
		m.put("this", this);
		m.put("oval", oval, true);
		m.put("startAngle", startAngle);
		m.put("sweepAngle", sweepAngle);
		m.call();
	}

	void Path::addPolygon(/*non-null*/ stdvec<shptr<class Offset>> points, /*non-null*/ bool close) {
		auto m = ManagedCall("Path", "addPolygon");
		m.put("this", this);
		m.put("points", points);
		m.put("close", close);
		m.call();
	}

	void Path::addRRect(/*non-null*/ shptr<class RRect> rrect) {
		auto m = ManagedCall("Path", "addRRect");
		m.put("this", this);
		m.put("rrect", rrect, true);
		m.call();
	}

	void Path::addPath(/*non-null*/ shptr<class Path> path, /*non-null*/ shptr<class Offset> offset, _addPath p) {
		auto m = ManagedCall("Path", "addPath");
		m.put("this", this);
		m.put("path", path, true);
		m.put("offset", offset, true);
		m.put("matrix4", p.matrix4);
		m.call();
	}

	void Path::extendWithPath(/*non-null*/ shptr<class Path> path, /*non-null*/ shptr<class Offset> offset, _extendWithPath p) {
		auto m = ManagedCall("Path", "extendWithPath");
		m.put("this", this);
		m.put("path", path, true);
		m.put("offset", offset, true);
		m.put("matrix4", p.matrix4);
		m.call();
	}

	void Path::close() {
		auto m = ManagedCall("Path", "close");
		m.put("this", this);
		m.call();
	}

	void Path::reset() {
		auto m = ManagedCall("Path", "reset");
		m.put("this", this);
		m.call();
	}

	bool /*non-null*/ Path::contains(/*non-null*/ shptr<class Offset> point) {
		auto m = ManagedCall("Path", "contains");
		m.put("this", this);
		m.put("point", point, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Path> /*non-null*/ Path::shift(/*non-null*/ shptr<class Offset> offset) {
		auto m = ManagedCall("Path", "shift");
		m.put("this", this);
		m.put("offset", offset, true);
		shptr<class Path> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Path> /*non-null*/ Path::transform(/*non-null*/ shptr<class Float64List> matrix4) {
		auto m = ManagedCall("Path", "transform");
		m.put("this", this);
		m.put("matrix4", matrix4, true);
		shptr<class Path> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Rect> /*non-null*/ Path::getBounds() {
		auto m = ManagedCall("Path", "getBounds");
		m.put("this", this);
		shptr<class Rect> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Path> /*non-null*/ Path::combine(/*non-null*/ PathOperation operation, /*non-null*/ shptr<class Path> path1, /*non-null*/ shptr<class Path> path2) {
		auto m = ManagedCall("Path", "combine");
		m.put("operation", operation);
		m.put("path1", path1, true);
		m.put("path2", path2, true);
		shptr<class Path> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class PathMetrics> /*non-null*/ Path::computeMetrics(_computeMetrics p) {
		auto m = ManagedCall("Path", "computeMetrics");
		m.put("this", this);
		m.put("forceClosed", p.forceClosed);
		shptr<class PathMetrics> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Path> /*non-null*/ Path::ctorMain() {
		auto m = ManagedCall("Path", "Path");
		shptr<class Path> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Path> /*non-null*/ Path::from(/*non-null*/ shptr<class Path> source) {
		auto m = ManagedCall("Path", "from");
		m.put("source", source, true);
		shptr<class Path> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class AlignmentGeometry> /*var-non-null*/ Align::alignment() {
		auto m = ManagedCall("Align", "alignment");
		m.put("this", this);
		shptr<class AlignmentGeometry> result;
		m.check(m.call(result));
		return result;
	}

	stdop<double> /*var-nullable*/ Align::widthFactor() {
		auto m = ManagedCall("Align", "widthFactor");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ Align::heightFactor() {
		auto m = ManagedCall("Align", "heightFactor");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	shptr<class Align> /*non-null*/ Align::ctorMain(_ctorMain p) {
		auto m = ManagedCall("Align", "Align");
		m.put("key", p.key);
		m.put("alignment", p.alignment, true);
		m.put("widthFactor", p.widthFactor);
		m.put("heightFactor", p.heightFactor);
		m.put("child", p.child);
		shptr<class Align> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Center> /*non-null*/ Center::ctorMain(_ctorMain p) {
		auto m = ManagedCall("Center", "Center");
		m.put("key", p.key);
		m.put("widthFactor", p.widthFactor);
		m.put("heightFactor", p.heightFactor);
		m.put("child", p.child);
		shptr<class Center> result;
		m.check(m.call(result, true));
		return result;
	}

	int64 /*var-non-null*/ Flexible::flex() {
		auto m = ManagedCall("Flexible", "flex");
		m.put("this", this);
		int64 result;
		m.check(m.call(result));
		return result;
	}

	FlexFit /*var-non-null*/ Flexible::fit() {
		auto m = ManagedCall("Flexible", "fit");
		m.put("this", this);
		FlexFit result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Flexible> /*non-null*/ Flexible::ctorMain(_ctorMain p) {
		auto m = ManagedCall("Flexible", "Flexible");
		m.put("key", p.key);
		m.put("flex", p.flex);
		m.put("fit", p.fit);
		m.put("child", p.child, true);
		shptr<class Flexible> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Column> /*non-null*/ Column::ctorMain(_ctorMain p) {
		auto m = ManagedCall("Column", "Column");
		m.put("key", p.key);
		m.put("mainAxisAlignment", p.mainAxisAlignment);
		m.put("mainAxisSize", p.mainAxisSize);
		m.put("crossAxisAlignment", p.crossAxisAlignment);
		m.put("textDirection", p.textDirection);
		m.put("verticalDirection", p.verticalDirection);
		m.put("textBaseline", p.textBaseline);
		m.put("children", p.children);
		shptr<class Column> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Row> /*non-null*/ Row::ctorMain(_ctorMain p) {
		auto m = ManagedCall("Row", "Row");
		m.put("key", p.key);
		m.put("mainAxisAlignment", p.mainAxisAlignment);
		m.put("mainAxisSize", p.mainAxisSize);
		m.put("crossAxisAlignment", p.crossAxisAlignment);
		m.put("textDirection", p.textDirection);
		m.put("verticalDirection", p.verticalDirection);
		m.put("textBaseline", p.textBaseline);
		m.put("children", p.children);
		shptr<class Row> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Expanded> /*non-null*/ Expanded::ctorMain(_ctorMain p) {
		auto m = ManagedCall("Expanded", "Expanded");
		m.put("key", p.key);
		m.put("flex", p.flex);
		m.put("child", p.child, true);
		shptr<class Expanded> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class EdgeInsetsGeometry> /*var-non-null*/ Padding::padding() {
		auto m = ManagedCall("Padding", "padding");
		m.put("this", this);
		shptr<class EdgeInsetsGeometry> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Padding> /*non-null*/ Padding::ctorMain(_ctorMain p) {
		auto m = ManagedCall("Padding", "Padding");
		m.put("key", p.key);
		m.put("padding", p.padding, true);
		m.put("child", p.child);
		shptr<class Padding> result;
		m.check(m.call(result, true));
		return result;
	}

	int64 /*var-non-null*/ IconData::codePoint() {
		auto m = ManagedCall("IconData", "codePoint");
		m.put("this", this);
		int64 result;
		m.check(m.call(result));
		return result;
	}

	stdop<stdstr> /*var-nullable*/ IconData::fontFamily() {
		auto m = ManagedCall("IconData", "fontFamily");
		m.put("this", this);
		stdop<stdstr> result;
		m.call(result);
		return result;
	}

	stdop<stdstr> /*var-nullable*/ IconData::fontPackage() {
		auto m = ManagedCall("IconData", "fontPackage");
		m.put("this", this);
		stdop<stdstr> result;
		m.call(result);
		return result;
	}

	bool /*var-non-null*/ IconData::matchTextDirection() {
		auto m = ManagedCall("IconData", "matchTextDirection");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ IconData::equals(/*non-null*/ shptr<class ObjBase> other) {
		auto m = ManagedCall("IconData", "==");
		m.put("this", this);
		m.put("other", other, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class IconData> /*non-null*/ IconData::ctorMain(/*non-null*/ int64 codePoint, _ctorMain p) {
		auto m = ManagedCall("IconData", "IconData");
		m.put("codePoint", codePoint);
		m.put("fontFamily", p.fontFamily);
		m.put("fontPackage", p.fontPackage);
		m.put("matchTextDirection", p.matchTextDirection);
		m.put("fontFamilyFallback", p.fontFamilyFallback);
		shptr<class IconData> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class IconData> /*var-nullable*/ Icon::icon() {
		auto m = ManagedCall("Icon", "icon");
		m.put("this", this);
		shptr<class IconData> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ Icon::size() {
		auto m = ManagedCall("Icon", "size");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ Icon::fill() {
		auto m = ManagedCall("Icon", "fill");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ Icon::weight() {
		auto m = ManagedCall("Icon", "weight");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ Icon::grade() {
		auto m = ManagedCall("Icon", "grade");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ Icon::opticalSize() {
		auto m = ManagedCall("Icon", "opticalSize");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ Icon::color() {
		auto m = ManagedCall("Icon", "color");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	stdop<stdstr> /*var-nullable*/ Icon::semanticLabel() {
		auto m = ManagedCall("Icon", "semanticLabel");
		m.put("this", this);
		stdop<stdstr> result;
		m.call(result);
		return result;
	}

	stdop<TextDirection> /*var-nullable*/ Icon::textDirection() {
		auto m = ManagedCall("Icon", "textDirection");
		m.put("this", this);
		stdop<TextDirection> result;
		m.call(result);
		return result;
	}

	shptr<class Icon> /*non-null*/ Icon::ctorMain(/*nullable*/ shptr<class IconData> icon, _ctorMain p) {
		auto m = ManagedCall("Icon", "Icon");
		m.put("icon", icon);
		m.put("key", p.key);
		m.put("size", p.size);
		m.put("fill", p.fill);
		m.put("weight", p.weight);
		m.put("grade", p.grade);
		m.put("opticalSize", p.opticalSize);
		m.put("color", p.color);
		m.put("shadows", p.shadows);
		m.put("semanticLabel", p.semanticLabel);
		m.put("textDirection", p.textDirection);
		shptr<class Icon> result;
		m.check(m.call(result, true));
		return result;
	}

	stdop<TextDirection> /*var-nullable*/ UnconstrainedBox::textDirection() {
		auto m = ManagedCall("UnconstrainedBox", "textDirection");
		m.put("this", this);
		stdop<TextDirection> result;
		m.call(result);
		return result;
	}

	shptr<class AlignmentGeometry> /*var-non-null*/ UnconstrainedBox::alignment() {
		auto m = ManagedCall("UnconstrainedBox", "alignment");
		m.put("this", this);
		shptr<class AlignmentGeometry> result;
		m.check(m.call(result));
		return result;
	}

	stdop<Axis> /*var-nullable*/ UnconstrainedBox::constrainedAxis() {
		auto m = ManagedCall("UnconstrainedBox", "constrainedAxis");
		m.put("this", this);
		stdop<Axis> result;
		m.call(result);
		return result;
	}

	Clip /*var-non-null*/ UnconstrainedBox::clipBehavior() {
		auto m = ManagedCall("UnconstrainedBox", "clipBehavior");
		m.put("this", this);
		Clip result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Widget> /*var-nullable*/ UnconstrainedBox::child() {
		auto m = ManagedCall("UnconstrainedBox", "child");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	shptr<class UnconstrainedBox> /*non-null*/ UnconstrainedBox::ctorMain(_ctorMain p) {
		auto m = ManagedCall("UnconstrainedBox", "UnconstrainedBox");
		m.put("key", p.key);
		m.put("child", p.child);
		m.put("textDirection", p.textDirection);
		m.put("alignment", p.alignment, true);
		m.put("constrainedAxis", p.constrainedAxis);
		m.put("clipBehavior", p.clipBehavior);
		shptr<class UnconstrainedBox> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Color> /*var-non-null*/ ColoredBox::color() {
		auto m = ManagedCall("ColoredBox", "color");
		m.put("this", this);
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ColoredBox> /*non-null*/ ColoredBox::ctorMain(_ctorMain p) {
		auto m = ManagedCall("ColoredBox", "ColoredBox");
		m.put("color", p.color, true);
		m.put("child", p.child);
		m.put("key", p.key);
		shptr<class ColoredBox> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class AlignmentGeometry> /*var-non-null*/ SizedOverflowBox::alignment() {
		auto m = ManagedCall("SizedOverflowBox", "alignment");
		m.put("this", this);
		shptr<class AlignmentGeometry> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Size> /*var-non-null*/ SizedOverflowBox::size() {
		auto m = ManagedCall("SizedOverflowBox", "size");
		m.put("this", this);
		shptr<class Size> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class SizedOverflowBox> /*non-null*/ SizedOverflowBox::ctorMain(_ctorMain p) {
		auto m = ManagedCall("SizedOverflowBox", "SizedOverflowBox");
		m.put("key", p.key);
		m.put("size", p.size, true);
		m.put("alignment", p.alignment, true);
		m.put("child", p.child);
		shptr<class SizedOverflowBox> result;
		m.check(m.call(result, true));
		return result;
	}

	stdop<double> /*var-nullable*/ SizedBox::width() {
		auto m = ManagedCall("SizedBox", "width");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ SizedBox::height() {
		auto m = ManagedCall("SizedBox", "height");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	stdstr /*non-null*/ SizedBox::toStringShort() {
		auto m = ManagedCall("SizedBox", "toStringShort");
		m.put("this", this);
		stdstr result;
		m.check(m.call(result));
		return result;
	}

	shptr<class SizedBox> /*non-null*/ SizedBox::ctorMain(_ctorMain p) {
		auto m = ManagedCall("SizedBox", "SizedBox");
		m.put("key", p.key);
		m.put("width", p.width);
		m.put("height", p.height);
		m.put("child", p.child);
		shptr<class SizedBox> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class SizedBox> /*non-null*/ SizedBox::expand(_expand p) {
		auto m = ManagedCall("SizedBox", "expand");
		m.put("key", p.key);
		m.put("child", p.child);
		shptr<class SizedBox> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class SizedBox> /*non-null*/ SizedBox::shrink(_shrink p) {
		auto m = ManagedCall("SizedBox", "shrink");
		m.put("key", p.key);
		m.put("child", p.child);
		shptr<class SizedBox> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class SizedBox> /*non-null*/ SizedBox::fromSize(_fromSize p) {
		auto m = ManagedCall("SizedBox", "fromSize");
		m.put("key", p.key);
		m.put("child", p.child);
		m.put("size", p.size);
		shptr<class SizedBox> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class SizedBox> /*non-null*/ SizedBox::square(_square p) {
		auto m = ManagedCall("SizedBox", "square");
		m.put("key", p.key);
		m.put("child", p.child);
		m.put("dimension", p.dimension);
		shptr<class SizedBox> result;
		m.check(m.call(result, true));
		return result;
	}

	Clip /*var-non-null*/ ClipRect::clipBehavior() {
		auto m = ManagedCall("ClipRect", "clipBehavior");
		m.put("this", this);
		Clip result;
		m.check(m.call(result));
		return result;
	}
	
	shptr<class ClipRect> /*non-null*/ ClipRect::ctorMain(_ctorMain p) {
		auto m = ManagedCall("ClipRect", "ClipRect");
		m.put("key", p.key);
//		m.put("clipper", p.clipper);
		m.put("clipBehavior", p.clipBehavior);
		m.put("child", p.child);
		shptr<class ClipRect> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class BorderRadiusGeometry> /*var-non-null*/ ClipRRect::borderRadius() {
		auto m = ManagedCall("ClipRRect", "borderRadius");
		m.put("this", this);
		shptr<class BorderRadiusGeometry> result;
		m.check(m.call(result));
		return result;
	}

	Clip /*var-non-null*/ ClipRRect::clipBehavior() {
		auto m = ManagedCall("ClipRRect", "clipBehavior");
		m.put("this", this);
		Clip result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ClipRRect> /*non-null*/ ClipRRect::ctorMain(_ctorMain p) {
		auto m = ManagedCall("ClipRRect", "ClipRRect");
		m.put("key", p.key);
		m.put("borderRadius", p.borderRadius, true);
//		m.put("clipper", p.clipper);
		m.put("clipBehavior", p.clipBehavior);
		m.put("child", p.child);
		shptr<class ClipRRect> result;
		m.check(m.call(result, true));
		return result;
	}

	Clip /*var-non-null*/ ClipPath::clipBehavior() {
		auto m = ManagedCall("ClipPath", "clipBehavior");
		m.put("this", this);
		Clip result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Widget> /*non-null*/ ClipPath::shape(_shape p) {
		auto m = ManagedCall("ClipPath", "shape");
		m.put("key", p.key);
		m.put("shape", p.shape, true);
		m.put("clipBehavior", p.clipBehavior);
		m.put("child", p.child);
		shptr<class Widget> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ClipPath> /*non-null*/ ClipPath::ctorMain(_ctorMain p) {
		auto m = ManagedCall("ClipPath", "ClipPath");
		m.put("key", p.key);
		m.put("_getClip", p._getClip, true);
		m.put("_shouldReclip", p._shouldReclip, true);
		m.put("clipBehavior", p.clipBehavior);
		m.put("child", p.child);
		shptr<class ClipPath> result;
		m.check(m.call(result, true));
		return result;
	}

	double /*var-non-null*/ AspectRatio::aspectRatio() {
		auto m = ManagedCall("AspectRatio", "aspectRatio");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	shptr<class AspectRatio> /*non-null*/ AspectRatio::ctorMain(_ctorMain p) {
		auto m = ManagedCall("AspectRatio", "AspectRatio");
		m.put("key", p.key);
		m.put("aspectRatio", p.aspectRatio);
		m.put("child", p.child);
		shptr<class AspectRatio> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class MediaQueryData> /*var-non-null*/ MediaQuery::data() {
		auto m = ManagedCall("MediaQuery", "data");
		m.put("this", this);
		shptr<class MediaQueryData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Widget> /*non-null*/ MediaQuery::fromWindow(_fromWindow p) {
		auto m = ManagedCall("MediaQuery", "fromWindow");
		m.put("key", p.key);
		m.put("child", p.child, true);
		shptr<class Widget> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Widget> /*non-null*/ MediaQuery::fromView(_fromView p) {
		auto m = ManagedCall("MediaQuery", "fromView");
		m.put("key", p.key);
		m.put("view", p.view, true);
		m.put("child", p.child, true);
		shptr<class Widget> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class MediaQueryData> /*non-null*/ MediaQuery::of(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("MediaQuery", "of");
		m.put("context", context, true);
		shptr<class MediaQueryData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class MediaQueryData> /*nullable*/ MediaQuery::maybeOf(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("MediaQuery", "maybeOf");
		m.put("context", context, true);
		shptr<class MediaQueryData> result;
		m.call(result);
		return result;
	}

	shptr<class Size> /*non-null*/ MediaQuery::sizeOf(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("MediaQuery", "sizeOf");
		m.put("context", context, true);
		shptr<class Size> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Size> /*nullable*/ MediaQuery::maybeSizeOf(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("MediaQuery", "maybeSizeOf");
		m.put("context", context, true);
		shptr<class Size> result;
		m.call(result);
		return result;
	}

	Orientation /*non-null*/ MediaQuery::orientationOf(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("MediaQuery", "orientationOf");
		m.put("context", context, true);
		Orientation result;
		m.check(m.call(result));
		return result;
	}

	stdop<Orientation> /*nullable*/ MediaQuery::maybeOrientationOf(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("MediaQuery", "maybeOrientationOf");
		m.put("context", context, true);
		stdop<Orientation> result;
		m.call(result);
		return result;
	}

	double /*non-null*/ MediaQuery::devicePixelRatioOf(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("MediaQuery", "devicePixelRatioOf");
		m.put("context", context, true);
		double result;
		m.check(m.call(result));
		return result;
	}

	stdop<double> /*nullable*/ MediaQuery::maybeDevicePixelRatioOf(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("MediaQuery", "maybeDevicePixelRatioOf");
		m.put("context", context, true);
		stdop<double> result;
		m.call(result);
		return result;
	}

	double /*non-null*/ MediaQuery::textScaleFactorOf(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("MediaQuery", "textScaleFactorOf");
		m.put("context", context, true);
		double result;
		m.check(m.call(result));
		return result;
	}

	stdop<double> /*nullable*/ MediaQuery::maybeTextScaleFactorOf(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("MediaQuery", "maybeTextScaleFactorOf");
		m.put("context", context, true);
		stdop<double> result;
		m.call(result);
		return result;
	}

	Brightness /*non-null*/ MediaQuery::platformBrightnessOf(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("MediaQuery", "platformBrightnessOf");
		m.put("context", context, true);
		Brightness result;
		m.check(m.call(result));
		return result;
	}

	stdop<Brightness> /*nullable*/ MediaQuery::maybePlatformBrightnessOf(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("MediaQuery", "maybePlatformBrightnessOf");
		m.put("context", context, true);
		stdop<Brightness> result;
		m.call(result);
		return result;
	}

	shptr<class EdgeInsets> /*non-null*/ MediaQuery::paddingOf(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("MediaQuery", "paddingOf");
		m.put("context", context, true);
		shptr<class EdgeInsets> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class EdgeInsets> /*nullable*/ MediaQuery::maybePaddingOf(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("MediaQuery", "maybePaddingOf");
		m.put("context", context, true);
		shptr<class EdgeInsets> result;
		m.call(result);
		return result;
	}

	shptr<class EdgeInsets> /*non-null*/ MediaQuery::viewInsetsOf(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("MediaQuery", "viewInsetsOf");
		m.put("context", context, true);
		shptr<class EdgeInsets> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class EdgeInsets> /*nullable*/ MediaQuery::maybeViewInsetsOf(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("MediaQuery", "maybeViewInsetsOf");
		m.put("context", context, true);
		shptr<class EdgeInsets> result;
		m.call(result);
		return result;
	}

	shptr<class EdgeInsets> /*non-null*/ MediaQuery::systemGestureInsetsOf(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("MediaQuery", "systemGestureInsetsOf");
		m.put("context", context, true);
		shptr<class EdgeInsets> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class EdgeInsets> /*nullable*/ MediaQuery::maybeSystemGestureInsetsOf(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("MediaQuery", "maybeSystemGestureInsetsOf");
		m.put("context", context, true);
		shptr<class EdgeInsets> result;
		m.call(result);
		return result;
	}

	shptr<class EdgeInsets> /*non-null*/ MediaQuery::viewPaddingOf(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("MediaQuery", "viewPaddingOf");
		m.put("context", context, true);
		shptr<class EdgeInsets> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class EdgeInsets> /*nullable*/ MediaQuery::maybeViewPaddingOf(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("MediaQuery", "maybeViewPaddingOf");
		m.put("context", context, true);
		shptr<class EdgeInsets> result;
		m.call(result);
		return result;
	}

	bool /*non-null*/ MediaQuery::alwaysUse24HourFormatOf(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("MediaQuery", "alwaysUse24HourFormatOf");
		m.put("context", context, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	stdop<bool> /*nullable*/ MediaQuery::maybeAlwaysUse24HourFormatOf(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("MediaQuery", "maybeAlwaysUse24HourFormatOf");
		m.put("context", context, true);
		stdop<bool> result;
		m.call(result);
		return result;
	}

	bool /*non-null*/ MediaQuery::accessibleNavigationOf(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("MediaQuery", "accessibleNavigationOf");
		m.put("context", context, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	stdop<bool> /*nullable*/ MediaQuery::maybeAccessibleNavigationOf(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("MediaQuery", "maybeAccessibleNavigationOf");
		m.put("context", context, true);
		stdop<bool> result;
		m.call(result);
		return result;
	}

	bool /*non-null*/ MediaQuery::invertColorsOf(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("MediaQuery", "invertColorsOf");
		m.put("context", context, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	stdop<bool> /*nullable*/ MediaQuery::maybeInvertColorsOf(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("MediaQuery", "maybeInvertColorsOf");
		m.put("context", context, true);
		stdop<bool> result;
		m.call(result);
		return result;
	}

	bool /*non-null*/ MediaQuery::highContrastOf(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("MediaQuery", "highContrastOf");
		m.put("context", context, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	stdop<bool> /*nullable*/ MediaQuery::maybeHighContrastOf(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("MediaQuery", "maybeHighContrastOf");
		m.put("context", context, true);
		stdop<bool> result;
		m.call(result);
		return result;
	}

	bool /*non-null*/ MediaQuery::disableAnimationsOf(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("MediaQuery", "disableAnimationsOf");
		m.put("context", context, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	stdop<bool> /*nullable*/ MediaQuery::maybeDisableAnimationsOf(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("MediaQuery", "maybeDisableAnimationsOf");
		m.put("context", context, true);
		stdop<bool> result;
		m.call(result);
		return result;
	}

	bool /*non-null*/ MediaQuery::boldTextOf(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("MediaQuery", "boldTextOf");
		m.put("context", context, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ MediaQuery::boldTextOverride(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("MediaQuery", "boldTextOverride");
		m.put("context", context, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	stdop<bool> /*nullable*/ MediaQuery::maybeBoldTextOf(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("MediaQuery", "maybeBoldTextOf");
		m.put("context", context, true);
		stdop<bool> result;
		m.call(result);
		return result;
	}

	NavigationMode /*non-null*/ MediaQuery::navigationModeOf(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("MediaQuery", "navigationModeOf");
		m.put("context", context, true);
		NavigationMode result;
		m.check(m.call(result));
		return result;
	}

	stdop<NavigationMode> /*nullable*/ MediaQuery::maybeNavigationModeOf(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("MediaQuery", "maybeNavigationModeOf");
		m.put("context", context, true);
		stdop<NavigationMode> result;
		m.call(result);
		return result;
	}

	shptr<class DeviceGestureSettings> /*non-null*/ MediaQuery::gestureSettingsOf(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("MediaQuery", "gestureSettingsOf");
		m.put("context", context, true);
		shptr<class DeviceGestureSettings> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class DeviceGestureSettings> /*nullable*/ MediaQuery::maybeGestureSettingsOf(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("MediaQuery", "maybeGestureSettingsOf");
		m.put("context", context, true);
		shptr<class DeviceGestureSettings> result;
		m.call(result);
		return result;
	}

	bool /*non-null*/ MediaQuery::updateShouldNotify(/*non-null*/ shptr<class MediaQuery> oldWidget) {
		auto m = ManagedCall("MediaQuery", "updateShouldNotify");
		m.put("this", this);
		m.put("oldWidget", oldWidget, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class MediaQuery> /*non-null*/ MediaQuery::ctorMain(_ctorMain p) {
		auto m = ManagedCall("MediaQuery", "MediaQuery");
		m.put("key", p.key);
		m.put("data", p.data, true);
		m.put("child", p.child, true);
		shptr<class MediaQuery> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class MediaQuery> /*non-null*/ MediaQuery::removePadding(_removePadding p) {
		auto m = ManagedCall("MediaQuery", "removePadding");
		m.put("key", p.key);
		m.put("context", p.context, true);
		m.put("removeLeft", p.removeLeft);
		m.put("removeTop", p.removeTop);
		m.put("removeRight", p.removeRight);
		m.put("removeBottom", p.removeBottom);
		m.put("child", p.child, true);
		shptr<class MediaQuery> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class MediaQuery> /*non-null*/ MediaQuery::removeViewInsets(_removeViewInsets p) {
		auto m = ManagedCall("MediaQuery", "removeViewInsets");
		m.put("key", p.key);
		m.put("context", p.context, true);
		m.put("removeLeft", p.removeLeft);
		m.put("removeTop", p.removeTop);
		m.put("removeRight", p.removeRight);
		m.put("removeBottom", p.removeBottom);
		m.put("child", p.child, true);
		shptr<class MediaQuery> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class MediaQuery> /*non-null*/ MediaQuery::removeViewPadding(_removeViewPadding p) {
		auto m = ManagedCall("MediaQuery", "removeViewPadding");
		m.put("key", p.key);
		m.put("context", p.context, true);
		m.put("removeLeft", p.removeLeft);
		m.put("removeTop", p.removeTop);
		m.put("removeRight", p.removeRight);
		m.put("removeBottom", p.removeBottom);
		m.put("child", p.child, true);
		shptr<class MediaQuery> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Size> /*var-non-null*/ MediaQueryData::size() {
		auto m = ManagedCall("MediaQueryData", "size");
		m.put("this", this);
		shptr<class Size> result;
		m.check(m.call(result));
		return result;
	}

	double /*var-non-null*/ MediaQueryData::devicePixelRatio() {
		auto m = ManagedCall("MediaQueryData", "devicePixelRatio");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	double /*var-non-null*/ MediaQueryData::textScaleFactor() {
		auto m = ManagedCall("MediaQueryData", "textScaleFactor");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	Brightness /*var-non-null*/ MediaQueryData::platformBrightness() {
		auto m = ManagedCall("MediaQueryData", "platformBrightness");
		m.put("this", this);
		Brightness result;
		m.check(m.call(result));
		return result;
	}

	shptr<class EdgeInsets> /*var-non-null*/ MediaQueryData::viewInsets() {
		auto m = ManagedCall("MediaQueryData", "viewInsets");
		m.put("this", this);
		shptr<class EdgeInsets> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class EdgeInsets> /*var-non-null*/ MediaQueryData::padding() {
		auto m = ManagedCall("MediaQueryData", "padding");
		m.put("this", this);
		shptr<class EdgeInsets> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class EdgeInsets> /*var-non-null*/ MediaQueryData::viewPadding() {
		auto m = ManagedCall("MediaQueryData", "viewPadding");
		m.put("this", this);
		shptr<class EdgeInsets> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class EdgeInsets> /*var-non-null*/ MediaQueryData::systemGestureInsets() {
		auto m = ManagedCall("MediaQueryData", "systemGestureInsets");
		m.put("this", this);
		shptr<class EdgeInsets> result;
		m.check(m.call(result));
		return result;
	}

	bool /*var-non-null*/ MediaQueryData::alwaysUse24HourFormat() {
		auto m = ManagedCall("MediaQueryData", "alwaysUse24HourFormat");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	bool /*var-non-null*/ MediaQueryData::accessibleNavigation() {
		auto m = ManagedCall("MediaQueryData", "accessibleNavigation");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	bool /*var-non-null*/ MediaQueryData::invertColors() {
		auto m = ManagedCall("MediaQueryData", "invertColors");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	bool /*var-non-null*/ MediaQueryData::highContrast() {
		auto m = ManagedCall("MediaQueryData", "highContrast");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	bool /*var-non-null*/ MediaQueryData::disableAnimations() {
		auto m = ManagedCall("MediaQueryData", "disableAnimations");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	bool /*var-non-null*/ MediaQueryData::boldText() {
		auto m = ManagedCall("MediaQueryData", "boldText");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	NavigationMode /*var-non-null*/ MediaQueryData::navigationMode() {
		auto m = ManagedCall("MediaQueryData", "navigationMode");
		m.put("this", this);
		NavigationMode result;
		m.check(m.call(result));
		return result;
	}

	shptr<class DeviceGestureSettings> /*var-non-null*/ MediaQueryData::gestureSettings() {
		auto m = ManagedCall("MediaQueryData", "gestureSettings");
		m.put("this", this);
		shptr<class DeviceGestureSettings> result;
		m.check(m.call(result));
		return result;
	}

	Orientation /*get-non-null*/ MediaQueryData::orientation() {
		auto m = ManagedCall("MediaQueryData", "orientation");
		m.put("this", this);
		Orientation result;
		m.check(m.call(result));
		return result;
	}

	shptr<class MediaQueryData> /*non-null*/ MediaQueryData::copyWith(_copyWith p) {
		auto m = ManagedCall("MediaQueryData", "copyWith");
		m.put("this", this);
		m.put("size", p.size);
		m.put("devicePixelRatio", p.devicePixelRatio);
		m.put("textScaleFactor", p.textScaleFactor);
		m.put("platformBrightness", p.platformBrightness);
		m.put("padding", p.padding);
		m.put("viewPadding", p.viewPadding);
		m.put("viewInsets", p.viewInsets);
		m.put("systemGestureInsets", p.systemGestureInsets);
		m.put("alwaysUse24HourFormat", p.alwaysUse24HourFormat);
		m.put("highContrast", p.highContrast);
		m.put("disableAnimations", p.disableAnimations);
		m.put("invertColors", p.invertColors);
		m.put("accessibleNavigation", p.accessibleNavigation);
		m.put("boldText", p.boldText);
		m.put("navigationMode", p.navigationMode);
		m.put("gestureSettings", p.gestureSettings);
		m.put("displayFeatures", p.displayFeatures);
		shptr<class MediaQueryData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class MediaQueryData> /*non-null*/ MediaQueryData::removePadding(_removePadding p) {
		auto m = ManagedCall("MediaQueryData", "removePadding");
		m.put("this", this);
		m.put("removeLeft", p.removeLeft);
		m.put("removeTop", p.removeTop);
		m.put("removeRight", p.removeRight);
		m.put("removeBottom", p.removeBottom);
		shptr<class MediaQueryData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class MediaQueryData> /*non-null*/ MediaQueryData::removeViewInsets(_removeViewInsets p) {
		auto m = ManagedCall("MediaQueryData", "removeViewInsets");
		m.put("this", this);
		m.put("removeLeft", p.removeLeft);
		m.put("removeTop", p.removeTop);
		m.put("removeRight", p.removeRight);
		m.put("removeBottom", p.removeBottom);
		shptr<class MediaQueryData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class MediaQueryData> /*non-null*/ MediaQueryData::removeViewPadding(_removeViewPadding p) {
		auto m = ManagedCall("MediaQueryData", "removeViewPadding");
		m.put("this", this);
		m.put("removeLeft", p.removeLeft);
		m.put("removeTop", p.removeTop);
		m.put("removeRight", p.removeRight);
		m.put("removeBottom", p.removeBottom);
		shptr<class MediaQueryData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class MediaQueryData> /*non-null*/ MediaQueryData::removeDisplayFeatures(/*non-null*/ shptr<class Rect> subScreen) {
		auto m = ManagedCall("MediaQueryData", "removeDisplayFeatures");
		m.put("this", this);
		m.put("subScreen", subScreen, true);
		shptr<class MediaQueryData> result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ MediaQueryData::equals(/*non-null*/ shptr<class ObjBase> other) {
		auto m = ManagedCall("MediaQueryData", "==");
		m.put("this", this);
		m.put("other", other, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class MediaQueryData> /*non-null*/ MediaQueryData::fromView(/*non-null*/ shptr<class FlutterView> view, _fromView p) {
		auto m = ManagedCall("MediaQueryData", "fromView");
		m.put("view", view, true);
		m.put("platformData", p.platformData);
		shptr<class MediaQueryData> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class MediaQueryData> /*non-null*/ MediaQueryData::fromWindow(/*non-null*/ shptr<class FlutterView> window) {
		auto m = ManagedCall("MediaQueryData", "fromWindow");
		m.put("window", window, true);
		shptr<class MediaQueryData> result;
		m.check(m.call(result, true));
		return result;
	}

	int64 /*var-non-null*/ Spacer::flex() {
		auto m = ManagedCall("Spacer", "flex");
		m.put("this", this);
		int64 result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Spacer> /*non-null*/ Spacer::ctorMain(_ctorMain p) {
		auto m = ManagedCall("Spacer", "Spacer");
		m.put("key", p.key);
		m.put("flex", p.flex);
		shptr<class Spacer> result;
		m.check(m.call(result, true));
		return result;
	}

	bool /*var-non-null*/ SafeArea::left() {
		auto m = ManagedCall("SafeArea", "left");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	bool /*var-non-null*/ SafeArea::top() {
		auto m = ManagedCall("SafeArea", "top");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	bool /*var-non-null*/ SafeArea::right() {
		auto m = ManagedCall("SafeArea", "right");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	bool /*var-non-null*/ SafeArea::bottom() {
		auto m = ManagedCall("SafeArea", "bottom");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class EdgeInsets> /*var-non-null*/ SafeArea::minimum() {
		auto m = ManagedCall("SafeArea", "minimum");
		m.put("this", this);
		shptr<class EdgeInsets> result;
		m.check(m.call(result));
		return result;
	}

	bool /*var-non-null*/ SafeArea::maintainBottomViewPadding() {
		auto m = ManagedCall("SafeArea", "maintainBottomViewPadding");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Widget> /*var-non-null*/ SafeArea::child() {
		auto m = ManagedCall("SafeArea", "child");
		m.put("this", this);
		shptr<class Widget> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class SafeArea> /*non-null*/ SafeArea::ctorMain(_ctorMain p) {
		auto m = ManagedCall("SafeArea", "SafeArea");
		m.put("key", p.key);
		m.put("left", p.left);
		m.put("top", p.top);
		m.put("right", p.right);
		m.put("bottom", p.bottom);
		m.put("minimum", p.minimum, true);
		m.put("maintainBottomViewPadding", p.maintainBottomViewPadding);
		m.put("child", p.child, true);
		shptr<class SafeArea> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Offset> /*var-non-null*/ TapDownDetails::globalPosition() {
		auto m = ManagedCall("TapDownDetails", "globalPosition");
		m.put("this", this);
		shptr<class Offset> result;
		m.check(m.call(result));
		return result;
	}

	stdop<PointerDeviceKind> /*var-nullable*/ TapDownDetails::kind() {
		auto m = ManagedCall("TapDownDetails", "kind");
		m.put("this", this);
		stdop<PointerDeviceKind> result;
		m.call(result);
		return result;
	}

	shptr<class Offset> /*var-non-null*/ TapDownDetails::localPosition() {
		auto m = ManagedCall("TapDownDetails", "localPosition");
		m.put("this", this);
		shptr<class Offset> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class TapDownDetails> /*non-null*/ TapDownDetails::ctorMain(_ctorMain p) {
		auto m = ManagedCall("TapDownDetails", "TapDownDetails");
		m.put("globalPosition", p.globalPosition, true);
		m.put("localPosition", p.localPosition);
		m.put("kind", p.kind);
		shptr<class TapDownDetails> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Offset> /*var-non-null*/ TapUpDetails::globalPosition() {
		auto m = ManagedCall("TapUpDetails", "globalPosition");
		m.put("this", this);
		shptr<class Offset> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Offset> /*var-non-null*/ TapUpDetails::localPosition() {
		auto m = ManagedCall("TapUpDetails", "localPosition");
		m.put("this", this);
		shptr<class Offset> result;
		m.check(m.call(result));
		return result;
	}

	PointerDeviceKind /*var-non-null*/ TapUpDetails::kind() {
		auto m = ManagedCall("TapUpDetails", "kind");
		m.put("this", this);
		PointerDeviceKind result;
		m.check(m.call(result));
		return result;
	}

	shptr<class TapUpDetails> /*non-null*/ TapUpDetails::ctorMain(_ctorMain p) {
		auto m = ManagedCall("TapUpDetails", "TapUpDetails");
		m.put("kind", p.kind);
		m.put("globalPosition", p.globalPosition, true);
		m.put("localPosition", p.localPosition);
		shptr<class TapUpDetails> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Offset> /*var-non-null*/ LongPressDownDetails::globalPosition() {
		auto m = ManagedCall("LongPressDownDetails", "globalPosition");
		m.put("this", this);
		shptr<class Offset> result;
		m.check(m.call(result));
		return result;
	}

	stdop<PointerDeviceKind> /*var-nullable*/ LongPressDownDetails::kind() {
		auto m = ManagedCall("LongPressDownDetails", "kind");
		m.put("this", this);
		stdop<PointerDeviceKind> result;
		m.call(result);
		return result;
	}

	shptr<class Offset> /*var-non-null*/ LongPressDownDetails::localPosition() {
		auto m = ManagedCall("LongPressDownDetails", "localPosition");
		m.put("this", this);
		shptr<class Offset> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class LongPressDownDetails> /*non-null*/ LongPressDownDetails::ctorMain(_ctorMain p) {
		auto m = ManagedCall("LongPressDownDetails", "LongPressDownDetails");
		m.put("globalPosition", p.globalPosition, true);
		m.put("localPosition", p.localPosition);
		m.put("kind", p.kind);
		shptr<class LongPressDownDetails> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Offset> /*var-non-null*/ LongPressStartDetails::globalPosition() {
		auto m = ManagedCall("LongPressStartDetails", "globalPosition");
		m.put("this", this);
		shptr<class Offset> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Offset> /*var-non-null*/ LongPressStartDetails::localPosition() {
		auto m = ManagedCall("LongPressStartDetails", "localPosition");
		m.put("this", this);
		shptr<class Offset> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class LongPressStartDetails> /*non-null*/ LongPressStartDetails::ctorMain(_ctorMain p) {
		auto m = ManagedCall("LongPressStartDetails", "LongPressStartDetails");
		m.put("globalPosition", p.globalPosition, true);
		m.put("localPosition", p.localPosition);
		shptr<class LongPressStartDetails> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Offset> /*var-non-null*/ LongPressMoveUpdateDetails::globalPosition() {
		auto m = ManagedCall("LongPressMoveUpdateDetails", "globalPosition");
		m.put("this", this);
		shptr<class Offset> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Offset> /*var-non-null*/ LongPressMoveUpdateDetails::localPosition() {
		auto m = ManagedCall("LongPressMoveUpdateDetails", "localPosition");
		m.put("this", this);
		shptr<class Offset> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Offset> /*var-non-null*/ LongPressMoveUpdateDetails::offsetFromOrigin() {
		auto m = ManagedCall("LongPressMoveUpdateDetails", "offsetFromOrigin");
		m.put("this", this);
		shptr<class Offset> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Offset> /*var-non-null*/ LongPressMoveUpdateDetails::localOffsetFromOrigin() {
		auto m = ManagedCall("LongPressMoveUpdateDetails", "localOffsetFromOrigin");
		m.put("this", this);
		shptr<class Offset> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class LongPressMoveUpdateDetails> /*non-null*/ LongPressMoveUpdateDetails::ctorMain(_ctorMain p) {
		auto m = ManagedCall("LongPressMoveUpdateDetails", "LongPressMoveUpdateDetails");
		m.put("globalPosition", p.globalPosition, true);
		m.put("localPosition", p.localPosition);
		m.put("offsetFromOrigin", p.offsetFromOrigin, true);
		m.put("localOffsetFromOrigin", p.localOffsetFromOrigin);
		shptr<class LongPressMoveUpdateDetails> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Offset> /*var-non-null*/ LongPressEndDetails::globalPosition() {
		auto m = ManagedCall("LongPressEndDetails", "globalPosition");
		m.put("this", this);
		shptr<class Offset> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Offset> /*var-non-null*/ LongPressEndDetails::localPosition() {
		auto m = ManagedCall("LongPressEndDetails", "localPosition");
		m.put("this", this);
		shptr<class Offset> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Velocity> /*var-non-null*/ LongPressEndDetails::velocity() {
		auto m = ManagedCall("LongPressEndDetails", "velocity");
		m.put("this", this);
		shptr<class Velocity> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class LongPressEndDetails> /*non-null*/ LongPressEndDetails::ctorMain(_ctorMain p) {
		auto m = ManagedCall("LongPressEndDetails", "LongPressEndDetails");
		m.put("globalPosition", p.globalPosition, true);
		m.put("localPosition", p.localPosition);
		m.put("velocity", p.velocity, true);
		shptr<class LongPressEndDetails> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Offset> /*var-non-null*/ ForcePressDetails::globalPosition() {
		auto m = ManagedCall("ForcePressDetails", "globalPosition");
		m.put("this", this);
		shptr<class Offset> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Offset> /*var-non-null*/ ForcePressDetails::localPosition() {
		auto m = ManagedCall("ForcePressDetails", "localPosition");
		m.put("this", this);
		shptr<class Offset> result;
		m.check(m.call(result));
		return result;
	}

	double /*var-non-null*/ ForcePressDetails::pressure() {
		auto m = ManagedCall("ForcePressDetails", "pressure");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ForcePressDetails> /*non-null*/ ForcePressDetails::ctorMain(_ctorMain p) {
		auto m = ManagedCall("ForcePressDetails", "ForcePressDetails");
		m.put("globalPosition", p.globalPosition, true);
		m.put("localPosition", p.localPosition);
		m.put("pressure", p.pressure);
		shptr<class ForcePressDetails> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Offset> /*var-non-null*/ DragDownDetails::globalPosition() {
		auto m = ManagedCall("DragDownDetails", "globalPosition");
		m.put("this", this);
		shptr<class Offset> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Offset> /*var-non-null*/ DragDownDetails::localPosition() {
		auto m = ManagedCall("DragDownDetails", "localPosition");
		m.put("this", this);
		shptr<class Offset> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class DragDownDetails> /*non-null*/ DragDownDetails::ctorMain(_ctorMain p) {
		auto m = ManagedCall("DragDownDetails", "DragDownDetails");
		m.put("globalPosition", p.globalPosition, true);
		m.put("localPosition", p.localPosition);
		shptr<class DragDownDetails> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Duration> /*var-nullable*/ DragStartDetails::sourceTimeStamp() {
		auto m = ManagedCall("DragStartDetails", "sourceTimeStamp");
		m.put("this", this);
		shptr<class Duration> result;
		m.call(result);
		return result;
	}

	shptr<class Offset> /*var-non-null*/ DragStartDetails::globalPosition() {
		auto m = ManagedCall("DragStartDetails", "globalPosition");
		m.put("this", this);
		shptr<class Offset> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Offset> /*var-non-null*/ DragStartDetails::localPosition() {
		auto m = ManagedCall("DragStartDetails", "localPosition");
		m.put("this", this);
		shptr<class Offset> result;
		m.check(m.call(result));
		return result;
	}

	stdop<PointerDeviceKind> /*var-nullable*/ DragStartDetails::kind() {
		auto m = ManagedCall("DragStartDetails", "kind");
		m.put("this", this);
		stdop<PointerDeviceKind> result;
		m.call(result);
		return result;
	}

	shptr<class DragStartDetails> /*non-null*/ DragStartDetails::ctorMain(_ctorMain p) {
		auto m = ManagedCall("DragStartDetails", "DragStartDetails");
		m.put("sourceTimeStamp", p.sourceTimeStamp);
		m.put("globalPosition", p.globalPosition, true);
		m.put("localPosition", p.localPosition);
		m.put("kind", p.kind);
		shptr<class DragStartDetails> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Duration> /*var-nullable*/ DragUpdateDetails::sourceTimeStamp() {
		auto m = ManagedCall("DragUpdateDetails", "sourceTimeStamp");
		m.put("this", this);
		shptr<class Duration> result;
		m.call(result);
		return result;
	}

	shptr<class Offset> /*var-non-null*/ DragUpdateDetails::delta() {
		auto m = ManagedCall("DragUpdateDetails", "delta");
		m.put("this", this);
		shptr<class Offset> result;
		m.check(m.call(result));
		return result;
	}

	stdop<double> /*var-nullable*/ DragUpdateDetails::primaryDelta() {
		auto m = ManagedCall("DragUpdateDetails", "primaryDelta");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	shptr<class Offset> /*var-non-null*/ DragUpdateDetails::globalPosition() {
		auto m = ManagedCall("DragUpdateDetails", "globalPosition");
		m.put("this", this);
		shptr<class Offset> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Offset> /*var-non-null*/ DragUpdateDetails::localPosition() {
		auto m = ManagedCall("DragUpdateDetails", "localPosition");
		m.put("this", this);
		shptr<class Offset> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class DragUpdateDetails> /*non-null*/ DragUpdateDetails::ctorMain(_ctorMain p) {
		auto m = ManagedCall("DragUpdateDetails", "DragUpdateDetails");
		m.put("sourceTimeStamp", p.sourceTimeStamp);
		m.put("delta", p.delta, true);
		m.put("primaryDelta", p.primaryDelta);
		m.put("globalPosition", p.globalPosition, true);
		m.put("localPosition", p.localPosition);
		shptr<class DragUpdateDetails> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Velocity> /*var-non-null*/ DragEndDetails::velocity() {
		auto m = ManagedCall("DragEndDetails", "velocity");
		m.put("this", this);
		shptr<class Velocity> result;
		m.check(m.call(result));
		return result;
	}

	stdop<double> /*var-nullable*/ DragEndDetails::primaryVelocity() {
		auto m = ManagedCall("DragEndDetails", "primaryVelocity");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	shptr<class DragEndDetails> /*non-null*/ DragEndDetails::ctorMain(_ctorMain p) {
		auto m = ManagedCall("DragEndDetails", "DragEndDetails");
		m.put("velocity", p.velocity, true);
		m.put("primaryVelocity", p.primaryVelocity);
		shptr<class DragEndDetails> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Offset> /*var-non-null*/ ScaleStartDetails::focalPoint() {
		auto m = ManagedCall("ScaleStartDetails", "focalPoint");
		m.put("this", this);
		shptr<class Offset> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Offset> /*var-non-null*/ ScaleStartDetails::localFocalPoint() {
		auto m = ManagedCall("ScaleStartDetails", "localFocalPoint");
		m.put("this", this);
		shptr<class Offset> result;
		m.check(m.call(result));
		return result;
	}

	int64 /*var-non-null*/ ScaleStartDetails::pointerCount() {
		auto m = ManagedCall("ScaleStartDetails", "pointerCount");
		m.put("this", this);
		int64 result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ScaleStartDetails> /*non-null*/ ScaleStartDetails::ctorMain(_ctorMain p) {
		auto m = ManagedCall("ScaleStartDetails", "ScaleStartDetails");
		m.put("focalPoint", p.focalPoint, true);
		m.put("localFocalPoint", p.localFocalPoint);
		m.put("pointerCount", p.pointerCount);
		shptr<class ScaleStartDetails> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Velocity> /*var-non-null*/ ScaleEndDetails::velocity() {
		auto m = ManagedCall("ScaleEndDetails", "velocity");
		m.put("this", this);
		shptr<class Velocity> result;
		m.check(m.call(result));
		return result;
	}

	double /*var-non-null*/ ScaleEndDetails::scaleVelocity() {
		auto m = ManagedCall("ScaleEndDetails", "scaleVelocity");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	int64 /*var-non-null*/ ScaleEndDetails::pointerCount() {
		auto m = ManagedCall("ScaleEndDetails", "pointerCount");
		m.put("this", this);
		int64 result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ScaleEndDetails> /*non-null*/ ScaleEndDetails::ctorMain(_ctorMain p) {
		auto m = ManagedCall("ScaleEndDetails", "ScaleEndDetails");
		m.put("velocity", p.velocity, true);
		m.put("scaleVelocity", p.scaleVelocity);
		m.put("pointerCount", p.pointerCount);
		shptr<class ScaleEndDetails> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Offset> /*var-non-null*/ ScaleUpdateDetails::focalPointDelta() {
		auto m = ManagedCall("ScaleUpdateDetails", "focalPointDelta");
		m.put("this", this);
		shptr<class Offset> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Offset> /*var-non-null*/ ScaleUpdateDetails::focalPoint() {
		auto m = ManagedCall("ScaleUpdateDetails", "focalPoint");
		m.put("this", this);
		shptr<class Offset> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Offset> /*var-non-null*/ ScaleUpdateDetails::localFocalPoint() {
		auto m = ManagedCall("ScaleUpdateDetails", "localFocalPoint");
		m.put("this", this);
		shptr<class Offset> result;
		m.check(m.call(result));
		return result;
	}

	double /*var-non-null*/ ScaleUpdateDetails::scale() {
		auto m = ManagedCall("ScaleUpdateDetails", "scale");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	double /*var-non-null*/ ScaleUpdateDetails::horizontalScale() {
		auto m = ManagedCall("ScaleUpdateDetails", "horizontalScale");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	double /*var-non-null*/ ScaleUpdateDetails::verticalScale() {
		auto m = ManagedCall("ScaleUpdateDetails", "verticalScale");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	double /*var-non-null*/ ScaleUpdateDetails::rotation() {
		auto m = ManagedCall("ScaleUpdateDetails", "rotation");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	int64 /*var-non-null*/ ScaleUpdateDetails::pointerCount() {
		auto m = ManagedCall("ScaleUpdateDetails", "pointerCount");
		m.put("this", this);
		int64 result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ScaleUpdateDetails> /*non-null*/ ScaleUpdateDetails::ctorMain(_ctorMain p) {
		auto m = ManagedCall("ScaleUpdateDetails", "ScaleUpdateDetails");
		m.put("focalPoint", p.focalPoint, true);
		m.put("localFocalPoint", p.localFocalPoint);
		m.put("scale", p.scale);
		m.put("horizontalScale", p.horizontalScale);
		m.put("verticalScale", p.verticalScale);
		m.put("rotation", p.rotation);
		m.put("pointerCount", p.pointerCount);
		m.put("focalPointDelta", p.focalPointDelta, true);
		shptr<class ScaleUpdateDetails> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Widget> /*var-nullable*/ GestureDetector::child() {
		auto m = ManagedCall("GestureDetector", "child");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	stdop<HitTestBehavior> /*var-nullable*/ GestureDetector::behavior() {
		auto m = ManagedCall("GestureDetector", "behavior");
		m.put("this", this);
		stdop<HitTestBehavior> result;
		m.call(result);
		return result;
	}

	bool /*var-non-null*/ GestureDetector::excludeFromSemantics() {
		auto m = ManagedCall("GestureDetector", "excludeFromSemantics");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	DragStartBehavior /*var-non-null*/ GestureDetector::dragStartBehavior() {
		auto m = ManagedCall("GestureDetector", "dragStartBehavior");
		m.put("this", this);
		DragStartBehavior result;
		m.check(m.call(result));
		return result;
	}

	bool /*var-non-null*/ GestureDetector::trackpadScrollCausesScale() {
		auto m = ManagedCall("GestureDetector", "trackpadScrollCausesScale");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Offset> /*var-non-null*/ GestureDetector::trackpadScrollToScaleFactor() {
		auto m = ManagedCall("GestureDetector", "trackpadScrollToScaleFactor");
		m.put("this", this);
		shptr<class Offset> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class GestureDetector> /*non-null*/ GestureDetector::ctorMain(_ctorMain p) {
		auto m = ManagedCall("GestureDetector", "GestureDetector");
		m.put("key", p.key);
		m.put("child", p.child);
		m.put("onTapDown", p.onTapDown);
		m.put("onTapUp", p.onTapUp);
		m.put("onTap", p.onTap);
		m.put("onTapCancel", p.onTapCancel);
		m.put("onSecondaryTap", p.onSecondaryTap);
		m.put("onSecondaryTapDown", p.onSecondaryTapDown);
		m.put("onSecondaryTapUp", p.onSecondaryTapUp);
		m.put("onSecondaryTapCancel", p.onSecondaryTapCancel);
		m.put("onTertiaryTapDown", p.onTertiaryTapDown);
		m.put("onTertiaryTapUp", p.onTertiaryTapUp);
		m.put("onTertiaryTapCancel", p.onTertiaryTapCancel);
		m.put("onDoubleTapDown", p.onDoubleTapDown);
		m.put("onDoubleTap", p.onDoubleTap);
		m.put("onDoubleTapCancel", p.onDoubleTapCancel);
		m.put("onLongPressDown", p.onLongPressDown);
		m.put("onLongPressCancel", p.onLongPressCancel);
		m.put("onLongPress", p.onLongPress);
		m.put("onLongPressStart", p.onLongPressStart);
		m.put("onLongPressMoveUpdate", p.onLongPressMoveUpdate);
		m.put("onLongPressUp", p.onLongPressUp);
		m.put("onLongPressEnd", p.onLongPressEnd);
		m.put("onSecondaryLongPressDown", p.onSecondaryLongPressDown);
		m.put("onSecondaryLongPressCancel", p.onSecondaryLongPressCancel);
		m.put("onSecondaryLongPress", p.onSecondaryLongPress);
		m.put("onSecondaryLongPressStart", p.onSecondaryLongPressStart);
		m.put("onSecondaryLongPressMoveUpdate", p.onSecondaryLongPressMoveUpdate);
		m.put("onSecondaryLongPressUp", p.onSecondaryLongPressUp);
		m.put("onSecondaryLongPressEnd", p.onSecondaryLongPressEnd);
		m.put("onTertiaryLongPressDown", p.onTertiaryLongPressDown);
		m.put("onTertiaryLongPressCancel", p.onTertiaryLongPressCancel);
		m.put("onTertiaryLongPress", p.onTertiaryLongPress);
		m.put("onTertiaryLongPressStart", p.onTertiaryLongPressStart);
		m.put("onTertiaryLongPressMoveUpdate", p.onTertiaryLongPressMoveUpdate);
		m.put("onTertiaryLongPressUp", p.onTertiaryLongPressUp);
		m.put("onTertiaryLongPressEnd", p.onTertiaryLongPressEnd);
		m.put("onVerticalDragDown", p.onVerticalDragDown);
		m.put("onVerticalDragStart", p.onVerticalDragStart);
		m.put("onVerticalDragUpdate", p.onVerticalDragUpdate);
		m.put("onVerticalDragEnd", p.onVerticalDragEnd);
		m.put("onVerticalDragCancel", p.onVerticalDragCancel);
		m.put("onHorizontalDragDown", p.onHorizontalDragDown);
		m.put("onHorizontalDragStart", p.onHorizontalDragStart);
		m.put("onHorizontalDragUpdate", p.onHorizontalDragUpdate);
		m.put("onHorizontalDragEnd", p.onHorizontalDragEnd);
		m.put("onHorizontalDragCancel", p.onHorizontalDragCancel);
		m.put("onForcePressStart", p.onForcePressStart);
		m.put("onForcePressPeak", p.onForcePressPeak);
		m.put("onForcePressUpdate", p.onForcePressUpdate);
		m.put("onForcePressEnd", p.onForcePressEnd);
		m.put("onPanDown", p.onPanDown);
		m.put("onPanStart", p.onPanStart);
		m.put("onPanUpdate", p.onPanUpdate);
		m.put("onPanEnd", p.onPanEnd);
		m.put("onPanCancel", p.onPanCancel);
		m.put("onScaleStart", p.onScaleStart);
		m.put("onScaleUpdate", p.onScaleUpdate);
		m.put("onScaleEnd", p.onScaleEnd);
		m.put("behavior", p.behavior);
		m.put("excludeFromSemantics", p.excludeFromSemantics);
		m.put("dragStartBehavior", p.dragStartBehavior);
		m.put("trackpadScrollCausesScale", p.trackpadScrollCausesScale);
		m.put("trackpadScrollToScaleFactor", p.trackpadScrollToScaleFactor, true);
//		m.put("supportedDevices", p.supportedDevices);
		shptr<class GestureDetector> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class MouseCursor> /*var-non-null*/ MouseRegion::cursor() {
		auto m = ManagedCall("MouseRegion", "cursor");
		m.put("this", this);
		shptr<class MouseCursor> result;
		m.check(m.call(result));
		return result;
	}

	bool /*var-non-null*/ MouseRegion::opaque() {
		auto m = ManagedCall("MouseRegion", "opaque");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	stdop<HitTestBehavior> /*var-nullable*/ MouseRegion::hitTestBehavior() {
		auto m = ManagedCall("MouseRegion", "hitTestBehavior");
		m.put("this", this);
		stdop<HitTestBehavior> result;
		m.call(result);
		return result;
	}

	shptr<class MouseRegion> /*non-null*/ MouseRegion::ctorMain(_ctorMain p) {
		auto m = ManagedCall("MouseRegion", "MouseRegion");
		m.put("key", p.key);
		m.put("onEnter", p.onEnter);
		m.put("onExit", p.onExit);
		m.put("onHover", p.onHover);
//		m.put("cursor", p.cursor, true);
		m.put("opaque", p.opaque);
		m.put("hitTestBehavior", p.hitTestBehavior);
		m.put("child", p.child);
		shptr<class MouseRegion> result;
		m.check(m.call(result, true));
		return result;
	}

	bool /*var-non-null*/ FocusableActionDetector::enabled() {
		auto m = ManagedCall("FocusableActionDetector", "enabled");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class FocusNode> /*var-nullable*/ FocusableActionDetector::focusNode() {
		auto m = ManagedCall("FocusableActionDetector", "focusNode");
		m.put("this", this);
		shptr<class FocusNode> result;
		m.call(result);
		return result;
	}

	bool /*var-non-null*/ FocusableActionDetector::autofocus() {
		auto m = ManagedCall("FocusableActionDetector", "autofocus");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	bool /*var-non-null*/ FocusableActionDetector::descendantsAreFocusable() {
		auto m = ManagedCall("FocusableActionDetector", "descendantsAreFocusable");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	bool /*var-non-null*/ FocusableActionDetector::descendantsAreTraversable() {
		auto m = ManagedCall("FocusableActionDetector", "descendantsAreTraversable");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class MouseCursor> /*var-non-null*/ FocusableActionDetector::mouseCursor() {
		auto m = ManagedCall("FocusableActionDetector", "mouseCursor");
		m.put("this", this);
		shptr<class MouseCursor> result;
		m.check(m.call(result));
		return result;
	}

	bool /*var-non-null*/ FocusableActionDetector::includeFocusSemantics() {
		auto m = ManagedCall("FocusableActionDetector", "includeFocusSemantics");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Widget> /*var-non-null*/ FocusableActionDetector::child() {
		auto m = ManagedCall("FocusableActionDetector", "child");
		m.put("this", this);
		shptr<class Widget> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class FocusableActionDetector> /*non-null*/ FocusableActionDetector::ctorMain(_ctorMain p) {
		auto m = ManagedCall("FocusableActionDetector", "FocusableActionDetector");
		m.put("key", p.key);
		m.put("enabled", p.enabled);
		m.put("focusNode", p.focusNode);
		m.put("autofocus", p.autofocus);
		m.put("descendantsAreFocusable", p.descendantsAreFocusable);
		m.put("descendantsAreTraversable", p.descendantsAreTraversable);
//		m.put("shortcuts", p.shortcuts);
//		m.put("actions", p.actions);
		m.put("onShowFocusHighlight", p.onShowFocusHighlight);
		m.put("onShowHoverHighlight", p.onShowHoverHighlight);
		m.put("onFocusChange", p.onFocusChange);
//		m.put("mouseCursor", p.mouseCursor, true);
		m.put("includeFocusSemantics", p.includeFocusSemantics);
		m.put("child", p.child, true);
		shptr<class FocusableActionDetector> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class AlignmentGeometry> /*var-non-null*/ Stack::alignment() {
		auto m = ManagedCall("Stack", "alignment");
		m.put("this", this);
		shptr<class AlignmentGeometry> result;
		m.check(m.call(result));
		return result;
	}

	stdop<TextDirection> /*var-nullable*/ Stack::textDirection() {
		auto m = ManagedCall("Stack", "textDirection");
		m.put("this", this);
		stdop<TextDirection> result;
		m.call(result);
		return result;
	}

	StackFit /*var-non-null*/ Stack::fit() {
		auto m = ManagedCall("Stack", "fit");
		m.put("this", this);
		StackFit result;
		m.check(m.call(result));
		return result;
	}

	Clip /*var-non-null*/ Stack::clipBehavior() {
		auto m = ManagedCall("Stack", "clipBehavior");
		m.put("this", this);
		Clip result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Stack> /*non-null*/ Stack::ctorMain(_ctorMain p) {
		auto m = ManagedCall("Stack", "Stack");
		m.put("key", p.key);
		m.put("alignment", p.alignment, true);
		m.put("textDirection", p.textDirection);
		m.put("fit", p.fit);
		m.put("clipBehavior", p.clipBehavior);
		m.put("children", p.children);
		shptr<class Stack> result;
		m.check(m.call(result, true));
		return result;
	}

	stdop<double> /*var-nullable*/ Positioned::left() {
		auto m = ManagedCall("Positioned", "left");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ Positioned::top() {
		auto m = ManagedCall("Positioned", "top");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ Positioned::right() {
		auto m = ManagedCall("Positioned", "right");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ Positioned::bottom() {
		auto m = ManagedCall("Positioned", "bottom");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ Positioned::width() {
		auto m = ManagedCall("Positioned", "width");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ Positioned::height() {
		auto m = ManagedCall("Positioned", "height");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	void Positioned::applyParentData(/*non-null*/ shptr<class RenderObject> renderObject) {
		auto m = ManagedCall("Positioned", "applyParentData");
		m.put("this", this);
		m.put("renderObject", renderObject, true);
		m.call();
	}

	shptr<class Positioned> /*non-null*/ Positioned::ctorMain(_ctorMain p) {
		auto m = ManagedCall("Positioned", "Positioned");
		m.put("key", p.key);
		m.put("left", p.left);
		m.put("top", p.top);
		m.put("right", p.right);
		m.put("bottom", p.bottom);
		m.put("width", p.width);
		m.put("height", p.height);
		m.put("child", p.child, true);
		shptr<class Positioned> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Positioned> /*non-null*/ Positioned::fromRect(_fromRect p) {
		auto m = ManagedCall("Positioned", "fromRect");
		m.put("key", p.key);
		m.put("rect", p.rect, true);
		m.put("child", p.child, true);
		shptr<class Positioned> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Positioned> /*non-null*/ Positioned::fromRelativeRect(_fromRelativeRect p) {
		auto m = ManagedCall("Positioned", "fromRelativeRect");
		m.put("key", p.key);
		m.put("rect", p.rect, true);
		m.put("child", p.child, true);
		shptr<class Positioned> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Positioned> /*non-null*/ Positioned::fill(_fill p) {
		auto m = ManagedCall("Positioned", "fill");
		m.put("key", p.key);
		m.put("left", p.left);
		m.put("top", p.top);
		m.put("right", p.right);
		m.put("bottom", p.bottom);
		m.put("child", p.child, true);
		shptr<class Positioned> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Positioned> /*non-null*/ Positioned::directional(_directional p) {
		auto m = ManagedCall("Positioned", "directional");
		m.put("key", p.key);
		m.put("textDirection", p.textDirection);
		m.put("start", p.start);
		m.put("top", p.top);
		m.put("end", p.end);
		m.put("bottom", p.bottom);
		m.put("width", p.width);
		m.put("height", p.height);
		m.put("child", p.child, true);
		shptr<class Positioned> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class SliverToBoxAdapter> /*non-null*/ SliverToBoxAdapter::ctorMain(_ctorMain p) {
		auto m = ManagedCall("SliverToBoxAdapter", "SliverToBoxAdapter");
		m.put("key", p.key);
		m.put("child", p.child);
		shptr<class SliverToBoxAdapter> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class EdgeInsetsGeometry> /*var-non-null*/ SliverPadding::padding() {
		auto m = ManagedCall("SliverPadding", "padding");
		m.put("this", this);
		shptr<class EdgeInsetsGeometry> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class SliverPadding> /*non-null*/ SliverPadding::ctorMain(_ctorMain p) {
		auto m = ManagedCall("SliverPadding", "SliverPadding");
		m.put("key", p.key);
		m.put("padding", p.padding, true);
		m.put("sliver", p.sliver);
		shptr<class SliverPadding> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Widget> /*var-non-null*/ PreferredSize::child() {
		auto m = ManagedCall("PreferredSize", "child");
		m.put("this", this);
		shptr<class Widget> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Size> /*var-non-null*/ PreferredSize::preferredSize() {
		auto m = ManagedCall("PreferredSize", "preferredSize");
		m.put("this", this);
		shptr<class Size> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class PreferredSize> /*non-null*/ PreferredSize::ctorMain(_ctorMain p) {
		auto m = ManagedCall("PreferredSize", "PreferredSize");
		m.put("key", p.key);
		m.put("preferredSize", p.preferredSize, true);
		m.put("child", p.child, true);
		shptr<class PreferredSize> result;
		m.check(m.call(result, true));
		return result;
	}

	double /*var-non-null*/ Opacity::opacity() {
		auto m = ManagedCall("Opacity", "opacity");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	bool /*var-non-null*/ Opacity::alwaysIncludeSemantics() {
		auto m = ManagedCall("Opacity", "alwaysIncludeSemantics");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Opacity> /*non-null*/ Opacity::ctorMain(_ctorMain p) {
		auto m = ManagedCall("Opacity", "Opacity");
		m.put("key", p.key);
		m.put("opacity", p.opacity);
		m.put("alwaysIncludeSemantics", p.alwaysIncludeSemantics);
		m.put("child", p.child);
		shptr<class Opacity> result;
		m.check(m.call(result, true));
		return result;
	}

	double /*var-non-null*/ SliverOpacity::opacity() {
		auto m = ManagedCall("SliverOpacity", "opacity");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	bool /*var-non-null*/ SliverOpacity::alwaysIncludeSemantics() {
		auto m = ManagedCall("SliverOpacity", "alwaysIncludeSemantics");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class SliverOpacity> /*non-null*/ SliverOpacity::ctorMain(_ctorMain p) {
		auto m = ManagedCall("SliverOpacity", "SliverOpacity");
		m.put("key", p.key);
		m.put("opacity", p.opacity);
		m.put("alwaysIncludeSemantics", p.alwaysIncludeSemantics);
		m.put("sliver", p.sliver);
		shptr<class SliverOpacity> result;
		m.check(m.call(result, true));
		return result;
	}

	bool /*var-non-null*/ Offstage::offstage() {
		auto m = ManagedCall("Offstage", "offstage");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Offstage> /*non-null*/ Offstage::ctorMain(_ctorMain p) {
		auto m = ManagedCall("Offstage", "Offstage");
		m.put("key", p.key);
		m.put("offstage", p.offstage);
		m.put("child", p.child);
		shptr<class Offstage> result;
		m.check(m.call(result, true));
		return result;
	}

	bool /*var-non-null*/ SliverOffstage::offstage() {
		auto m = ManagedCall("SliverOffstage", "offstage");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class SliverOffstage> /*non-null*/ SliverOffstage::ctorMain(_ctorMain p) {
		auto m = ManagedCall("SliverOffstage", "SliverOffstage");
		m.put("key", p.key);
		m.put("offstage", p.offstage);
		m.put("sliver", p.sliver);
		shptr<class SliverOffstage> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class RepaintBoundary> /*non-null*/ RepaintBoundary::ctorMain(_ctorMain p) {
		auto m = ManagedCall("RepaintBoundary", "RepaintBoundary");
		m.put("key", p.key);
		m.put("child", p.child);
		shptr<class RepaintBoundary> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class RepaintBoundary> /*non-null*/ RepaintBoundary::wrap(/*non-null*/ shptr<class Widget> child, /*non-null*/ int64 childIndex) {
		auto m = ManagedCall("RepaintBoundary", "wrap");
		m.put("child", child, true);
		m.put("childIndex", childIndex);
		shptr<class RepaintBoundary> result;
		m.check(m.call(result, true));
		return result;
	}

	bool /*var-non-null*/ AbsorbPointer::absorbing() {
		auto m = ManagedCall("AbsorbPointer", "absorbing");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	stdop<bool> /*var-nullable*/ AbsorbPointer::ignoringSemantics() {
		auto m = ManagedCall("AbsorbPointer", "ignoringSemantics");
		m.put("this", this);
		stdop<bool> result;
		m.call(result);
		return result;
	}

	shptr<class AbsorbPointer> /*non-null*/ AbsorbPointer::ctorMain(_ctorMain p) {
		auto m = ManagedCall("AbsorbPointer", "AbsorbPointer");
		m.put("key", p.key);
		m.put("absorbing", p.absorbing);
		m.put("ignoringSemantics", p.ignoringSemantics);
		m.put("child", p.child);
		shptr<class AbsorbPointer> result;
		m.check(m.call(result, true));
		return result;
	}

	bool /*var-non-null*/ IgnorePointer::ignoring() {
		auto m = ManagedCall("IgnorePointer", "ignoring");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	stdop<bool> /*var-nullable*/ IgnorePointer::ignoringSemantics() {
		auto m = ManagedCall("IgnorePointer", "ignoringSemantics");
		m.put("this", this);
		stdop<bool> result;
		m.call(result);
		return result;
	}

	shptr<class IgnorePointer> /*non-null*/ IgnorePointer::ctorMain(_ctorMain p) {
		auto m = ManagedCall("IgnorePointer", "IgnorePointer");
		m.put("key", p.key);
		m.put("ignoring", p.ignoring);
		m.put("ignoringSemantics", p.ignoringSemantics);
		m.put("child", p.child);
		shptr<class IgnorePointer> result;
		m.check(m.call(result, true));
		return result;
	}

	bool /*var-non-null*/ SliverIgnorePointer::ignoring() {
		auto m = ManagedCall("SliverIgnorePointer", "ignoring");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	stdop<bool> /*var-nullable*/ SliverIgnorePointer::ignoringSemantics() {
		auto m = ManagedCall("SliverIgnorePointer", "ignoringSemantics");
		m.put("this", this);
		stdop<bool> result;
		m.call(result);
		return result;
	}

	shptr<class SliverIgnorePointer> /*non-null*/ SliverIgnorePointer::ctorMain(_ctorMain p) {
		auto m = ManagedCall("SliverIgnorePointer", "SliverIgnorePointer");
		m.put("key", p.key);
		m.put("ignoring", p.ignoring);
		m.put("ignoringSemantics", p.ignoringSemantics);
		m.put("sliver", p.sliver);
		shptr<class SliverIgnorePointer> result;
		m.check(m.call(result, true));
		return result;
	}

	void Navigator::push(/*non-null*/ shptr<class BuildContext> context, /*non-null*/ shptr<class Route> route, /*nullable*/ stdfunc<void()> onComplete) {
		auto m = ManagedCall("Navigator", "push");
		m.put("context", context, true);
		m.put("route", route, true);
		m.put("onComplete", onComplete);
		m.call();
	}

	bool /*non-null*/ Navigator::canPop(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("Navigator", "canPop");
		m.put("context", context, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	void Navigator::pop(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("Navigator", "pop");
		m.put("context", context, true);
		m.call();
	}

	shptr<class MaterialPageRoute> /*non-null*/ MaterialPageRoute::ctorMain(_ctorMain p) {
		auto m = ManagedCall("MaterialPageRoute", "MaterialPageRoute");
		m.put("builder", p.builder, true);
		m.put("settings", p.settings);
		m.put("maintainState", p.maintainState);
		m.put("fullscreenDialog", p.fullscreenDialog);
		m.put("allowSnapshotting", p.allowSnapshotting);
		shptr<class MaterialPageRoute> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class CupertinoPageRoute> /*non-null*/ CupertinoPageRoute::ctorMain(_ctorMain p) {
		auto m = ManagedCall("CupertinoPageRoute", "CupertinoPageRoute");
		m.put("builder", p.builder, true);
		m.put("title", p.title);
		m.put("settings", p.settings);
		m.put("maintainState", p.maintainState);
		m.put("fullscreenDialog", p.fullscreenDialog);
		m.put("allowSnapshotting", p.allowSnapshotting);
		shptr<class CupertinoPageRoute> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class PageRouteBuilder> /*non-null*/ PageRouteBuilder::ctorMain(_ctorMain p) {
		auto m = ManagedCall("PageRouteBuilder", "PageRouteBuilder");
		m.put("settings", p.settings);
		m.put("pageBuilder", p.pageBuilder, true);
//		m.put("transitionsBuilder", p.transitionsBuilder, true);
		m.put("transitionDuration", p.transitionDuration, true);
		m.put("reverseTransitionDuration", p.reverseTransitionDuration, true);
		m.put("opaque", p.opaque);
		m.put("barrierDismissible", p.barrierDismissible);
		m.put("barrierColor", p.barrierColor);
		m.put("barrierLabel", p.barrierLabel);
		m.put("maintainState", p.maintainState);
		m.put("fullscreenDialog", p.fullscreenDialog);
		m.put("allowSnapshotting", p.allowSnapshotting);
		shptr<class PageRouteBuilder> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class BoxConstraints> /*var-non-null*/ ConstrainedBox::constraints() {
		auto m = ManagedCall("ConstrainedBox", "constraints");
		m.put("this", this);
		shptr<class BoxConstraints> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ConstrainedBox> /*non-null*/ ConstrainedBox::ctorMain(_ctorMain p) {
		auto m = ManagedCall("ConstrainedBox", "ConstrainedBox");
		m.put("key", p.key);
		m.put("constraints", p.constraints, true);
		m.put("child", p.child);
		shptr<class ConstrainedBox> result;
		m.check(m.call(result, true));
		return result;
	}

	double /*var-non-null*/ LimitedBox::maxWidth() {
		auto m = ManagedCall("LimitedBox", "maxWidth");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	double /*var-non-null*/ LimitedBox::maxHeight() {
		auto m = ManagedCall("LimitedBox", "maxHeight");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	shptr<class LimitedBox> /*non-null*/ LimitedBox::ctorMain(_ctorMain p) {
		auto m = ManagedCall("LimitedBox", "LimitedBox");
		m.put("key", p.key);
		m.put("maxWidth", p.maxWidth);
		m.put("maxHeight", p.maxHeight);
		m.put("child", p.child);
		shptr<class LimitedBox> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class AlignmentGeometry> /*var-non-null*/ OverflowBox::alignment() {
		auto m = ManagedCall("OverflowBox", "alignment");
		m.put("this", this);
		shptr<class AlignmentGeometry> result;
		m.check(m.call(result));
		return result;
	}

	stdop<double> /*var-nullable*/ OverflowBox::minWidth() {
		auto m = ManagedCall("OverflowBox", "minWidth");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ OverflowBox::maxWidth() {
		auto m = ManagedCall("OverflowBox", "maxWidth");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ OverflowBox::minHeight() {
		auto m = ManagedCall("OverflowBox", "minHeight");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ OverflowBox::maxHeight() {
		auto m = ManagedCall("OverflowBox", "maxHeight");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	shptr<class OverflowBox> /*non-null*/ OverflowBox::ctorMain(_ctorMain p) {
		auto m = ManagedCall("OverflowBox", "OverflowBox");
		m.put("key", p.key);
		m.put("alignment", p.alignment, true);
		m.put("minWidth", p.minWidth);
		m.put("maxWidth", p.maxWidth);
		m.put("minHeight", p.minHeight);
		m.put("maxHeight", p.maxHeight);
		m.put("child", p.child);
		shptr<class OverflowBox> result;
		m.check(m.call(result, true));
		return result;
	}

	BoxFit /*var-non-null*/ FittedBox::fit() {
		auto m = ManagedCall("FittedBox", "fit");
		m.put("this", this);
		BoxFit result;
		m.check(m.call(result));
		return result;
	}

	shptr<class AlignmentGeometry> /*var-non-null*/ FittedBox::alignment() {
		auto m = ManagedCall("FittedBox", "alignment");
		m.put("this", this);
		shptr<class AlignmentGeometry> result;
		m.check(m.call(result));
		return result;
	}

	Clip /*var-non-null*/ FittedBox::clipBehavior() {
		auto m = ManagedCall("FittedBox", "clipBehavior");
		m.put("this", this);
		Clip result;
		m.check(m.call(result));
		return result;
	}

	shptr<class FittedBox> /*non-null*/ FittedBox::ctorMain(_ctorMain p) {
		auto m = ManagedCall("FittedBox", "FittedBox");
		m.put("key", p.key);
		m.put("fit", p.fit);
		m.put("alignment", p.alignment, true);
		m.put("clipBehavior", p.clipBehavior);
		m.put("child", p.child);
		shptr<class FittedBox> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Offset> /*var-non-null*/ FractionalTranslation::translation() {
		auto m = ManagedCall("FractionalTranslation", "translation");
		m.put("this", this);
		shptr<class Offset> result;
		m.check(m.call(result));
		return result;
	}

	bool /*var-non-null*/ FractionalTranslation::transformHitTests() {
		auto m = ManagedCall("FractionalTranslation", "transformHitTests");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class FractionalTranslation> /*non-null*/ FractionalTranslation::ctorMain(_ctorMain p) {
		auto m = ManagedCall("FractionalTranslation", "FractionalTranslation");
		m.put("key", p.key);
		m.put("translation", p.translation, true);
		m.put("transformHitTests", p.transformHitTests);
		m.put("child", p.child);
		shptr<class FractionalTranslation> result;
		m.check(m.call(result, true));
		return result;
	}

	stdop<double> /*var-nullable*/ FractionallySizedBox::widthFactor() {
		auto m = ManagedCall("FractionallySizedBox", "widthFactor");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ FractionallySizedBox::heightFactor() {
		auto m = ManagedCall("FractionallySizedBox", "heightFactor");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	shptr<class AlignmentGeometry> /*var-non-null*/ FractionallySizedBox::alignment() {
		auto m = ManagedCall("FractionallySizedBox", "alignment");
		m.put("this", this);
		shptr<class AlignmentGeometry> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class FractionallySizedBox> /*non-null*/ FractionallySizedBox::ctorMain(_ctorMain p) {
		auto m = ManagedCall("FractionallySizedBox", "FractionallySizedBox");
		m.put("key", p.key);
		m.put("alignment", p.alignment, true);
		m.put("widthFactor", p.widthFactor);
		m.put("heightFactor", p.heightFactor);
		m.put("child", p.child);
		shptr<class FractionallySizedBox> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Builder> /*non-null*/ Builder::ctorMain(_ctorMain p) {
		auto m = ManagedCall("Builder", "Builder");
		m.put("key", p.key);
		m.put("builder", p.builder, true);
		shptr<class Builder> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class LayoutBuilder> /*non-null*/ LayoutBuilder::ctorMain(_ctorMain p) {
		auto m = ManagedCall("LayoutBuilder", "LayoutBuilder");
		m.put("key", p.key);
		m.put("builder", p.builder, true);
		shptr<class LayoutBuilder> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class AlignmentGeometry> /*var-non-null*/ IndexedStack::alignment() {
		auto m = ManagedCall("IndexedStack", "alignment");
		m.put("this", this);
		shptr<class AlignmentGeometry> result;
		m.check(m.call(result));
		return result;
	}

	stdop<TextDirection> /*var-nullable*/ IndexedStack::textDirection() {
		auto m = ManagedCall("IndexedStack", "textDirection");
		m.put("this", this);
		stdop<TextDirection> result;
		m.call(result);
		return result;
	}

	Clip /*var-non-null*/ IndexedStack::clipBehavior() {
		auto m = ManagedCall("IndexedStack", "clipBehavior");
		m.put("this", this);
		Clip result;
		m.check(m.call(result));
		return result;
	}

	StackFit /*var-non-null*/ IndexedStack::sizing() {
		auto m = ManagedCall("IndexedStack", "sizing");
		m.put("this", this);
		StackFit result;
		m.check(m.call(result));
		return result;
	}

	stdop<int64> /*var-nullable*/ IndexedStack::index() {
		auto m = ManagedCall("IndexedStack", "index");
		m.put("this", this);
		stdop<int64> result;
		m.call(result);
		return result;
	}

	shptr<class IndexedStack> /*non-null*/ IndexedStack::ctorMain(_ctorMain p) {
		auto m = ManagedCall("IndexedStack", "IndexedStack");
		m.put("key", p.key);
		m.put("alignment", p.alignment, true);
		m.put("textDirection", p.textDirection);
		m.put("clipBehavior", p.clipBehavior);
		m.put("sizing", p.sizing);
		m.put("index", p.index);
		m.put("children", p.children);
		shptr<class IndexedStack> result;
		m.check(m.call(result, true));
		return result;
	}

	double /*var-non-null*/ OverflowBar::spacing() {
		auto m = ManagedCall("OverflowBar", "spacing");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	stdop<MainAxisAlignment> /*var-nullable*/ OverflowBar::alignment() {
		auto m = ManagedCall("OverflowBar", "alignment");
		m.put("this", this);
		stdop<MainAxisAlignment> result;
		m.call(result);
		return result;
	}

	double /*var-non-null*/ OverflowBar::overflowSpacing() {
		auto m = ManagedCall("OverflowBar", "overflowSpacing");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	OverflowBarAlignment /*var-non-null*/ OverflowBar::overflowAlignment() {
		auto m = ManagedCall("OverflowBar", "overflowAlignment");
		m.put("this", this);
		OverflowBarAlignment result;
		m.check(m.call(result));
		return result;
	}

	VerticalDirection /*var-non-null*/ OverflowBar::overflowDirection() {
		auto m = ManagedCall("OverflowBar", "overflowDirection");
		m.put("this", this);
		VerticalDirection result;
		m.check(m.call(result));
		return result;
	}

	stdop<TextDirection> /*var-nullable*/ OverflowBar::textDirection() {
		auto m = ManagedCall("OverflowBar", "textDirection");
		m.put("this", this);
		stdop<TextDirection> result;
		m.call(result);
		return result;
	}

	Clip /*var-non-null*/ OverflowBar::clipBehavior() {
		auto m = ManagedCall("OverflowBar", "clipBehavior");
		m.put("this", this);
		Clip result;
		m.check(m.call(result));
		return result;
	}

	shptr<class OverflowBar> /*non-null*/ OverflowBar::ctorMain(_ctorMain p) {
		auto m = ManagedCall("OverflowBar", "OverflowBar");
		m.put("key", p.key);
		m.put("spacing", p.spacing);
		m.put("alignment", p.alignment);
		m.put("overflowSpacing", p.overflowSpacing);
		m.put("overflowAlignment", p.overflowAlignment);
		m.put("overflowDirection", p.overflowDirection);
		m.put("textDirection", p.textDirection);
		m.put("clipBehavior", p.clipBehavior);
		m.put("children", p.children);
		shptr<class OverflowBar> result;
		m.check(m.call(result, true));
		return result;
	}

	BoxShape /*var-non-null*/ PhysicalModel::shape() {
		auto m = ManagedCall("PhysicalModel", "shape");
		m.put("this", this);
		BoxShape result;
		m.check(m.call(result));
		return result;
	}

	Clip /*var-non-null*/ PhysicalModel::clipBehavior() {
		auto m = ManagedCall("PhysicalModel", "clipBehavior");
		m.put("this", this);
		Clip result;
		m.check(m.call(result));
		return result;
	}

	shptr<class BorderRadius> /*var-nullable*/ PhysicalModel::borderRadius() {
		auto m = ManagedCall("PhysicalModel", "borderRadius");
		m.put("this", this);
		shptr<class BorderRadius> result;
		m.call(result);
		return result;
	}

	double /*var-non-null*/ PhysicalModel::elevation() {
		auto m = ManagedCall("PhysicalModel", "elevation");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*var-non-null*/ PhysicalModel::color() {
		auto m = ManagedCall("PhysicalModel", "color");
		m.put("this", this);
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*var-non-null*/ PhysicalModel::shadowColor() {
		auto m = ManagedCall("PhysicalModel", "shadowColor");
		m.put("this", this);
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class PhysicalModel> /*non-null*/ PhysicalModel::ctorMain(_ctorMain p) {
		auto m = ManagedCall("PhysicalModel", "PhysicalModel");
		m.put("key", p.key);
		m.put("shape", p.shape);
		m.put("clipBehavior", p.clipBehavior);
		m.put("borderRadius", p.borderRadius);
		m.put("elevation", p.elevation);
		m.put("color", p.color, true);
		m.put("shadowColor", p.shadowColor, true);
		m.put("child", p.child);
		shptr<class PhysicalModel> result;
		m.check(m.call(result, true));
		return result;
	}

	BlendMode /*var-non-null*/ ShaderMask::blendMode() {
		auto m = ManagedCall("ShaderMask", "blendMode");
		m.put("this", this);
		BlendMode result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ShaderMask> /*non-null*/ ShaderMask::ctorMain(_ctorMain p) {
		auto m = ManagedCall("ShaderMask", "ShaderMask");
		m.put("key", p.key);
		m.put("shaderCallback", p.shaderCallback, true);
		m.put("blendMode", p.blendMode);
		m.put("child", p.child);
		shptr<class ShaderMask> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Widget> /*var-non-null*/ Visibility::child() {
		auto m = ManagedCall("Visibility", "child");
		m.put("this", this);
		shptr<class Widget> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Widget> /*var-non-null*/ Visibility::replacement() {
		auto m = ManagedCall("Visibility", "replacement");
		m.put("this", this);
		shptr<class Widget> result;
		m.check(m.call(result));
		return result;
	}

	bool /*var-non-null*/ Visibility::visible() {
		auto m = ManagedCall("Visibility", "visible");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	bool /*var-non-null*/ Visibility::maintainState() {
		auto m = ManagedCall("Visibility", "maintainState");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	bool /*var-non-null*/ Visibility::maintainAnimation() {
		auto m = ManagedCall("Visibility", "maintainAnimation");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	bool /*var-non-null*/ Visibility::maintainSize() {
		auto m = ManagedCall("Visibility", "maintainSize");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	bool /*var-non-null*/ Visibility::maintainSemantics() {
		auto m = ManagedCall("Visibility", "maintainSemantics");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	bool /*var-non-null*/ Visibility::maintainInteractivity() {
		auto m = ManagedCall("Visibility", "maintainInteractivity");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ Visibility::of(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("Visibility", "of");
		m.put("context", context, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Visibility> /*non-null*/ Visibility::ctorMain(_ctorMain p) {
		auto m = ManagedCall("Visibility", "Visibility");
		m.put("key", p.key);
		m.put("child", p.child, true);
		m.put("replacement", p.replacement, true);
		m.put("visible", p.visible);
		m.put("maintainState", p.maintainState);
		m.put("maintainAnimation", p.maintainAnimation);
		m.put("maintainSize", p.maintainSize);
		m.put("maintainSemantics", p.maintainSemantics);
		m.put("maintainInteractivity", p.maintainInteractivity);
		shptr<class Visibility> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Visibility> /*non-null*/ Visibility::maintain(_maintain p) {
		auto m = ManagedCall("Visibility", "maintain");
		m.put("key", p.key);
		m.put("child", p.child, true);
		m.put("visible", p.visible);
		shptr<class Visibility> result;
		m.check(m.call(result, true));
		return result;
	}

	Axis /*var-non-null*/ Wrap::direction() {
		auto m = ManagedCall("Wrap", "direction");
		m.put("this", this);
		Axis result;
		m.check(m.call(result));
		return result;
	}

	WrapAlignment /*var-non-null*/ Wrap::alignment() {
		auto m = ManagedCall("Wrap", "alignment");
		m.put("this", this);
		WrapAlignment result;
		m.check(m.call(result));
		return result;
	}

	double /*var-non-null*/ Wrap::spacing() {
		auto m = ManagedCall("Wrap", "spacing");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	WrapAlignment /*var-non-null*/ Wrap::runAlignment() {
		auto m = ManagedCall("Wrap", "runAlignment");
		m.put("this", this);
		WrapAlignment result;
		m.check(m.call(result));
		return result;
	}

	double /*var-non-null*/ Wrap::runSpacing() {
		auto m = ManagedCall("Wrap", "runSpacing");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	WrapCrossAlignment /*var-non-null*/ Wrap::crossAxisAlignment() {
		auto m = ManagedCall("Wrap", "crossAxisAlignment");
		m.put("this", this);
		WrapCrossAlignment result;
		m.check(m.call(result));
		return result;
	}

	stdop<TextDirection> /*var-nullable*/ Wrap::textDirection() {
		auto m = ManagedCall("Wrap", "textDirection");
		m.put("this", this);
		stdop<TextDirection> result;
		m.call(result);
		return result;
	}

	VerticalDirection /*var-non-null*/ Wrap::verticalDirection() {
		auto m = ManagedCall("Wrap", "verticalDirection");
		m.put("this", this);
		VerticalDirection result;
		m.check(m.call(result));
		return result;
	}

	Clip /*var-non-null*/ Wrap::clipBehavior() {
		auto m = ManagedCall("Wrap", "clipBehavior");
		m.put("this", this);
		Clip result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Wrap> /*non-null*/ Wrap::ctorMain(_ctorMain p) {
		auto m = ManagedCall("Wrap", "Wrap");
		m.put("key", p.key);
		m.put("direction", p.direction);
		m.put("alignment", p.alignment);
		m.put("spacing", p.spacing);
		m.put("runAlignment", p.runAlignment);
		m.put("runSpacing", p.runSpacing);
		m.put("crossAxisAlignment", p.crossAxisAlignment);
		m.put("textDirection", p.textDirection);
		m.put("verticalDirection", p.verticalDirection);
		m.put("clipBehavior", p.clipBehavior);
		m.put("children", p.children);
		shptr<class Wrap> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Widget> /*var-nullable*/ Container::child() {
		auto m = ManagedCall("Container", "child");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	shptr<class AlignmentGeometry> /*var-nullable*/ Container::alignment() {
		auto m = ManagedCall("Container", "alignment");
		m.put("this", this);
		shptr<class AlignmentGeometry> result;
		m.call(result);
		return result;
	}

	shptr<class EdgeInsetsGeometry> /*var-nullable*/ Container::padding() {
		auto m = ManagedCall("Container", "padding");
		m.put("this", this);
		shptr<class EdgeInsetsGeometry> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ Container::color() {
		auto m = ManagedCall("Container", "color");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Decoration> /*var-nullable*/ Container::decoration() {
		auto m = ManagedCall("Container", "decoration");
		m.put("this", this);
		shptr<class Decoration> result;
		m.call(result);
		return result;
	}

	shptr<class Decoration> /*var-nullable*/ Container::foregroundDecoration() {
		auto m = ManagedCall("Container", "foregroundDecoration");
		m.put("this", this);
		shptr<class Decoration> result;
		m.call(result);
		return result;
	}

	shptr<class BoxConstraints> /*var-nullable*/ Container::constraints() {
		auto m = ManagedCall("Container", "constraints");
		m.put("this", this);
		shptr<class BoxConstraints> result;
		m.call(result);
		return result;
	}

	shptr<class EdgeInsetsGeometry> /*var-nullable*/ Container::margin() {
		auto m = ManagedCall("Container", "margin");
		m.put("this", this);
		shptr<class EdgeInsetsGeometry> result;
		m.call(result);
		return result;
	}

	shptr<class Matrix4> /*var-nullable*/ Container::transform() {
		auto m = ManagedCall("Container", "transform");
		m.put("this", this);
		shptr<class Matrix4> result;
		m.call(result);
		return result;
	}

	shptr<class AlignmentGeometry> /*var-nullable*/ Container::transformAlignment() {
		auto m = ManagedCall("Container", "transformAlignment");
		m.put("this", this);
		shptr<class AlignmentGeometry> result;
		m.call(result);
		return result;
	}

	Clip /*var-non-null*/ Container::clipBehavior() {
		auto m = ManagedCall("Container", "clipBehavior");
		m.put("this", this);
		Clip result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Container> /*non-null*/ Container::ctorMain(_ctorMain p) {
		auto m = ManagedCall("Container", "Container");
		m.put("key", p.key);
		m.put("alignment", p.alignment);
		m.put("padding", p.padding);
		m.put("color", p.color);
		m.put("decoration", p.decoration);
		m.put("foregroundDecoration", p.foregroundDecoration);
		m.put("width", p.width);
		m.put("height", p.height);
		m.put("constraints", p.constraints);
		m.put("margin", p.margin);
		m.put("transform", p.transform);
		m.put("transformAlignment", p.transformAlignment);
		m.put("child", p.child);
		m.put("clipBehavior", p.clipBehavior);
		shptr<class Container> result;
		m.check(m.call(result, true));
		return result;
	}

	stdop<stdstr> /*var-nullable*/ Text::data() {
		auto m = ManagedCall("Text", "data");
		m.put("this", this);
		stdop<stdstr> result;
		m.call(result);
		return result;
	}

	shptr<class InlineSpan> /*var-nullable*/ Text::textSpan() {
		auto m = ManagedCall("Text", "textSpan");
		m.put("this", this);
		shptr<class InlineSpan> result;
		m.call(result);
		return result;
	}

	shptr<class TextStyle> /*var-nullable*/ Text::style() {
		auto m = ManagedCall("Text", "style");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.call(result);
		return result;
	}

	shptr<class StrutStyle> /*var-nullable*/ Text::strutStyle() {
		auto m = ManagedCall("Text", "strutStyle");
		m.put("this", this);
		shptr<class StrutStyle> result;
		m.call(result);
		return result;
	}

	stdop<TextAlign> /*var-nullable*/ Text::textAlign() {
		auto m = ManagedCall("Text", "textAlign");
		m.put("this", this);
		stdop<TextAlign> result;
		m.call(result);
		return result;
	}

	stdop<TextDirection> /*var-nullable*/ Text::textDirection() {
		auto m = ManagedCall("Text", "textDirection");
		m.put("this", this);
		stdop<TextDirection> result;
		m.call(result);
		return result;
	}

	shptr<class Locale> /*var-nullable*/ Text::locale() {
		auto m = ManagedCall("Text", "locale");
		m.put("this", this);
		shptr<class Locale> result;
		m.call(result);
		return result;
	}

	stdop<bool> /*var-nullable*/ Text::softWrap() {
		auto m = ManagedCall("Text", "softWrap");
		m.put("this", this);
		stdop<bool> result;
		m.call(result);
		return result;
	}

	stdop<TextOverflow> /*var-nullable*/ Text::overflow() {
		auto m = ManagedCall("Text", "overflow");
		m.put("this", this);
		stdop<TextOverflow> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ Text::textScaleFactor() {
		auto m = ManagedCall("Text", "textScaleFactor");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	stdop<int64> /*var-nullable*/ Text::maxLines() {
		auto m = ManagedCall("Text", "maxLines");
		m.put("this", this);
		stdop<int64> result;
		m.call(result);
		return result;
	}

	stdop<stdstr> /*var-nullable*/ Text::semanticsLabel() {
		auto m = ManagedCall("Text", "semanticsLabel");
		m.put("this", this);
		stdop<stdstr> result;
		m.call(result);
		return result;
	}

	stdop<TextWidthBasis> /*var-nullable*/ Text::textWidthBasis() {
		auto m = ManagedCall("Text", "textWidthBasis");
		m.put("this", this);
		stdop<TextWidthBasis> result;
		m.call(result);
		return result;
	}

	shptr<class TextHeightBehavior> /*var-nullable*/ Text::textHeightBehavior() {
		auto m = ManagedCall("Text", "textHeightBehavior");
		m.put("this", this);
		shptr<class TextHeightBehavior> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ Text::selectionColor() {
		auto m = ManagedCall("Text", "selectionColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Text> /*non-null*/ Text::ctorMain(/*non-null*/ stdstr data, _ctorMain p) {
		auto m = ManagedCall("Text", "Text");
		m.put("data", data);
		m.put("key", p.key);
		m.put("style", p.style);
		m.put("strutStyle", p.strutStyle);
		m.put("textAlign", p.textAlign);
		m.put("textDirection", p.textDirection);
		m.put("locale", p.locale);
		m.put("softWrap", p.softWrap);
		m.put("overflow", p.overflow);
		m.put("textScaleFactor", p.textScaleFactor);
		m.put("maxLines", p.maxLines);
		m.put("semanticsLabel", p.semanticsLabel);
		m.put("textWidthBasis", p.textWidthBasis);
		m.put("textHeightBehavior", p.textHeightBehavior);
		m.put("selectionColor", p.selectionColor);
		shptr<class Text> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Text> /*non-null*/ Text::rich(/*non-null*/ shptr<class InlineSpan> textSpan, _rich p) {
		auto m = ManagedCall("Text", "rich");
		m.put("textSpan", textSpan, true);
		m.put("key", p.key);
		m.put("style", p.style);
		m.put("strutStyle", p.strutStyle);
		m.put("textAlign", p.textAlign);
		m.put("textDirection", p.textDirection);
		m.put("locale", p.locale);
		m.put("softWrap", p.softWrap);
		m.put("overflow", p.overflow);
		m.put("textScaleFactor", p.textScaleFactor);
		m.put("maxLines", p.maxLines);
		m.put("semanticsLabel", p.semanticsLabel);
		m.put("textWidthBasis", p.textWidthBasis);
		m.put("textHeightBehavior", p.textHeightBehavior);
		m.put("selectionColor", p.selectionColor);
		shptr<class Text> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class InlineSpan> /*var-non-null*/ RichText::text() {
		auto m = ManagedCall("RichText", "text");
		m.put("this", this);
		shptr<class InlineSpan> result;
		m.check(m.call(result));
		return result;
	}

	TextAlign /*var-non-null*/ RichText::textAlign() {
		auto m = ManagedCall("RichText", "textAlign");
		m.put("this", this);
		TextAlign result;
		m.check(m.call(result));
		return result;
	}

	stdop<TextDirection> /*var-nullable*/ RichText::textDirection() {
		auto m = ManagedCall("RichText", "textDirection");
		m.put("this", this);
		stdop<TextDirection> result;
		m.call(result);
		return result;
	}

	bool /*var-non-null*/ RichText::softWrap() {
		auto m = ManagedCall("RichText", "softWrap");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	TextOverflow /*var-non-null*/ RichText::overflow() {
		auto m = ManagedCall("RichText", "overflow");
		m.put("this", this);
		TextOverflow result;
		m.check(m.call(result));
		return result;
	}

	double /*var-non-null*/ RichText::textScaleFactor() {
		auto m = ManagedCall("RichText", "textScaleFactor");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	stdop<int64> /*var-nullable*/ RichText::maxLines() {
		auto m = ManagedCall("RichText", "maxLines");
		m.put("this", this);
		stdop<int64> result;
		m.call(result);
		return result;
	}

	shptr<class Locale> /*var-nullable*/ RichText::locale() {
		auto m = ManagedCall("RichText", "locale");
		m.put("this", this);
		shptr<class Locale> result;
		m.call(result);
		return result;
	}

	shptr<class StrutStyle> /*var-nullable*/ RichText::strutStyle() {
		auto m = ManagedCall("RichText", "strutStyle");
		m.put("this", this);
		shptr<class StrutStyle> result;
		m.call(result);
		return result;
	}

	TextWidthBasis /*var-non-null*/ RichText::textWidthBasis() {
		auto m = ManagedCall("RichText", "textWidthBasis");
		m.put("this", this);
		TextWidthBasis result;
		m.check(m.call(result));
		return result;
	}

	shptr<class TextHeightBehavior> /*var-nullable*/ RichText::textHeightBehavior() {
		auto m = ManagedCall("RichText", "textHeightBehavior");
		m.put("this", this);
		shptr<class TextHeightBehavior> result;
		m.call(result);
		return result;
	}

	shptr<class SelectionRegistrar> /*var-nullable*/ RichText::selectionRegistrar() {
		auto m = ManagedCall("RichText", "selectionRegistrar");
		m.put("this", this);
		shptr<class SelectionRegistrar> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ RichText::selectionColor() {
		auto m = ManagedCall("RichText", "selectionColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class RichText> /*non-null*/ RichText::ctorMain(_ctorMain p) {
		auto m = ManagedCall("RichText", "RichText");
		m.put("key", p.key);
		m.put("text", p.text, true);
		m.put("textAlign", p.textAlign);
		m.put("textDirection", p.textDirection);
		m.put("softWrap", p.softWrap);
		m.put("overflow", p.overflow);
		m.put("textScaleFactor", p.textScaleFactor);
		m.put("maxLines", p.maxLines);
		m.put("locale", p.locale);
		m.put("strutStyle", p.strutStyle);
		m.put("textWidthBasis", p.textWidthBasis);
		m.put("textHeightBehavior", p.textHeightBehavior);
		m.put("selectionRegistrar", p.selectionRegistrar);
		m.put("selectionColor", p.selectionColor);
		shptr<class RichText> result;
		m.check(m.call(result, true));
		return result;
	}

	stdop<double> /*var-nullable*/ Image::width() {
		auto m = ManagedCall("Image", "width");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ Image::height() {
		auto m = ManagedCall("Image", "height");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ Image::color() {
		auto m = ManagedCall("Image", "color");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	FilterQuality /*var-non-null*/ Image::filterQuality() {
		auto m = ManagedCall("Image", "filterQuality");
		m.put("this", this);
		FilterQuality result;
		m.check(m.call(result));
		return result;
	}

	stdop<BlendMode> /*var-nullable*/ Image::colorBlendMode() {
		auto m = ManagedCall("Image", "colorBlendMode");
		m.put("this", this);
		stdop<BlendMode> result;
		m.call(result);
		return result;
	}

	stdop<BoxFit> /*var-nullable*/ Image::fit() {
		auto m = ManagedCall("Image", "fit");
		m.put("this", this);
		stdop<BoxFit> result;
		m.call(result);
		return result;
	}

	shptr<class AlignmentGeometry> /*var-non-null*/ Image::alignment() {
		auto m = ManagedCall("Image", "alignment");
		m.put("this", this);
		shptr<class AlignmentGeometry> result;
		m.check(m.call(result));
		return result;
	}

	ImageRepeat /*var-non-null*/ Image::repeat() {
		auto m = ManagedCall("Image", "repeat");
		m.put("this", this);
		ImageRepeat result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Rect> /*var-nullable*/ Image::centerSlice() {
		auto m = ManagedCall("Image", "centerSlice");
		m.put("this", this);
		shptr<class Rect> result;
		m.call(result);
		return result;
	}

	bool /*var-non-null*/ Image::matchTextDirection() {
		auto m = ManagedCall("Image", "matchTextDirection");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	bool /*var-non-null*/ Image::gaplessPlayback() {
		auto m = ManagedCall("Image", "gaplessPlayback");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	stdop<stdstr> /*var-nullable*/ Image::semanticLabel() {
		auto m = ManagedCall("Image", "semanticLabel");
		m.put("this", this);
		stdop<stdstr> result;
		m.call(result);
		return result;
	}

	bool /*var-non-null*/ Image::excludeFromSemantics() {
		auto m = ManagedCall("Image", "excludeFromSemantics");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	bool /*var-non-null*/ Image::isAntiAlias() {
		auto m = ManagedCall("Image", "isAntiAlias");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Image> /*non-null*/ Image::ctorMain(_ctorMain p) {
		auto m = ManagedCall("Image", "Image");
		m.put("key", p.key);
		m.put("image", p.image, true);
//		m.put("frameBuilder", p.frameBuilder);
//		m.put("loadingBuilder", p.loadingBuilder);
//		m.put("errorBuilder", p.errorBuilder);
		m.put("semanticLabel", p.semanticLabel);
		m.put("excludeFromSemantics", p.excludeFromSemantics);
		m.put("width", p.width);
		m.put("height", p.height);
		m.put("color", p.color);
//		m.put("opacity", p.opacity);
		m.put("colorBlendMode", p.colorBlendMode);
		m.put("fit", p.fit);
		m.put("alignment", p.alignment, true);
		m.put("repeat", p.repeat);
		m.put("centerSlice", p.centerSlice);
		m.put("matchTextDirection", p.matchTextDirection);
		m.put("gaplessPlayback", p.gaplessPlayback);
		m.put("isAntiAlias", p.isAntiAlias);
		m.put("filterQuality", p.filterQuality);
		shptr<class Image> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Image> /*non-null*/ Image::file(/*non-null*/ stdstr file, _file p) {
		auto m = ManagedCall("Image", "file");
		m.put("file", file);
		m.put("key", p.key);
		m.put("scale", p.scale);
//		m.put("frameBuilder", p.frameBuilder);
//		m.put("errorBuilder", p.errorBuilder);
		m.put("semanticLabel", p.semanticLabel);
		m.put("excludeFromSemantics", p.excludeFromSemantics);
		m.put("width", p.width);
		m.put("height", p.height);
		m.put("color", p.color);
//		m.put("opacity", p.opacity);
		m.put("colorBlendMode", p.colorBlendMode);
		m.put("fit", p.fit);
		m.put("alignment", p.alignment, true);
		m.put("repeat", p.repeat);
		m.put("centerSlice", p.centerSlice);
		m.put("matchTextDirection", p.matchTextDirection);
		m.put("gaplessPlayback", p.gaplessPlayback);
		m.put("isAntiAlias", p.isAntiAlias);
		m.put("filterQuality", p.filterQuality);
		m.put("cacheWidth", p.cacheWidth);
		m.put("cacheHeight", p.cacheHeight);
		shptr<class Image> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Image> /*non-null*/ Image::asset(/*non-null*/ stdstr name, _asset p) {
		auto m = ManagedCall("Image", "asset");
		m.put("name", name);
		m.put("key", p.key);
		m.put("bundle", p.bundle);
//		m.put("frameBuilder", p.frameBuilder);
//		m.put("errorBuilder", p.errorBuilder);
		m.put("semanticLabel", p.semanticLabel);
		m.put("excludeFromSemantics", p.excludeFromSemantics);
		m.put("scale", p.scale);
		m.put("width", p.width);
		m.put("height", p.height);
		m.put("color", p.color);
//		m.put("opacity", p.opacity);
		m.put("colorBlendMode", p.colorBlendMode);
		m.put("fit", p.fit);
		m.put("alignment", p.alignment, true);
		m.put("repeat", p.repeat);
		m.put("centerSlice", p.centerSlice);
		m.put("matchTextDirection", p.matchTextDirection);
		m.put("gaplessPlayback", p.gaplessPlayback);
		m.put("isAntiAlias", p.isAntiAlias);
		m.put("package", p.package);
		m.put("filterQuality", p.filterQuality);
		m.put("cacheWidth", p.cacheWidth);
		m.put("cacheHeight", p.cacheHeight);
		shptr<class Image> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Image> /*non-null*/ Image::memory(/*non-null*/ shptr<class Uint8List> bytes, _memory p) {
		auto m = ManagedCall("Image", "memory");
		m.put("bytes", bytes, true);
		m.put("key", p.key);
		m.put("scale", p.scale);
//		m.put("frameBuilder", p.frameBuilder);
//		m.put("errorBuilder", p.errorBuilder);
		m.put("semanticLabel", p.semanticLabel);
		m.put("excludeFromSemantics", p.excludeFromSemantics);
		m.put("width", p.width);
		m.put("height", p.height);
		m.put("color", p.color);
//		m.put("opacity", p.opacity);
		m.put("colorBlendMode", p.colorBlendMode);
		m.put("fit", p.fit);
		m.put("alignment", p.alignment, true);
		m.put("repeat", p.repeat);
		m.put("centerSlice", p.centerSlice);
		m.put("matchTextDirection", p.matchTextDirection);
		m.put("gaplessPlayback", p.gaplessPlayback);
		m.put("isAntiAlias", p.isAntiAlias);
		m.put("filterQuality", p.filterQuality);
		m.put("cacheWidth", p.cacheWidth);
		m.put("cacheHeight", p.cacheHeight);
		shptr<class Image> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Widget> /*var-non-null*/ Hero::child() {
		auto m = ManagedCall("Hero", "child");
		m.put("this", this);
		shptr<class Widget> result;
		m.check(m.call(result));
		return result;
	}

	bool /*var-non-null*/ Hero::transitionOnUserGestures() {
		auto m = ManagedCall("Hero", "transitionOnUserGestures");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Hero> /*non-null*/ Hero::ctorMain(_ctorMain p) {
		auto m = ManagedCall("Hero", "Hero");
		m.put("key", p.key);
		m.put("tag", p.tag);
//		m.put("createRectTween", p.createRectTween);
//		m.put("flightShuttleBuilder", p.flightShuttleBuilder);
//		m.put("placeholderBuilder", p.placeholderBuilder);
		m.put("transitionOnUserGestures", p.transitionOnUserGestures);
		m.put("child", p.child, true);
		shptr<class Hero> result;
		m.check(m.call(result, true));
		return result;
	}

	stdop<stdstr> /*var-nullable*/ TextSpan::text() {
		auto m = ManagedCall("TextSpan", "text");
		m.put("this", this);
		stdop<stdstr> result;
		m.call(result);
		return result;
	}

	shptr<class GestureRecognizer> /*var-nullable*/ TextSpan::recognizer() {
		auto m = ManagedCall("TextSpan", "recognizer");
		m.put("this", this);
		shptr<class GestureRecognizer> result;
		m.call(result);
		return result;
	}

	shptr<class MouseCursor> /*var-non-null*/ TextSpan::mouseCursor() {
		auto m = ManagedCall("TextSpan", "mouseCursor");
		m.put("this", this);
		shptr<class MouseCursor> result;
		m.check(m.call(result));
		return result;
	}

	stdop<stdstr> /*var-nullable*/ TextSpan::semanticsLabel() {
		auto m = ManagedCall("TextSpan", "semanticsLabel");
		m.put("this", this);
		stdop<stdstr> result;
		m.call(result);
		return result;
	}

	shptr<class Locale> /*var-nullable*/ TextSpan::locale() {
		auto m = ManagedCall("TextSpan", "locale");
		m.put("this", this);
		shptr<class Locale> result;
		m.call(result);
		return result;
	}

	stdop<bool> /*var-nullable*/ TextSpan::spellOut() {
		auto m = ManagedCall("TextSpan", "spellOut");
		m.put("this", this);
		stdop<bool> result;
		m.call(result);
		return result;
	}

	shptr<class MouseCursor> /*get-non-null*/ TextSpan::cursor() {
		auto m = ManagedCall("TextSpan", "cursor");
		m.put("this", this);
		shptr<class MouseCursor> result;
		m.check(m.call(result));
		return result;
	}

	bool /*get-non-null*/ TextSpan::validForMouseTracker() {
		auto m = ManagedCall("TextSpan", "validForMouseTracker");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	void TextSpan::handleEvent(/*non-null*/ shptr<class PointerEvent> event, /*non-null*/ shptr<class HitTestEntry> entry) {
		auto m = ManagedCall("TextSpan", "handleEvent");
		m.put("this", this);
		m.put("event", event, true);
		m.put("entry", entry, true);
		m.call();
	}

	bool /*non-null*/ TextSpan::visitChildren(/*non-null*/ stdfunc<bool(shptr<class InlineSpan>)> /*(InlineSpan) -> bool*/ visitor) {
		auto m = ManagedCall("TextSpan", "visitChildren");
		m.put("this", this);
		m.put("visitor", visitor, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ TextSpan::visitDirectChildren(/*non-null*/ stdfunc<bool(shptr<class InlineSpan>)> /*(InlineSpan) -> bool*/ visitor) {
		auto m = ManagedCall("TextSpan", "visitDirectChildren");
		m.put("this", this);
		m.put("visitor", visitor, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class InlineSpan> /*nullable*/ TextSpan::getSpanForPositionVisitor(/*non-null*/ shptr<class TextPosition> position, /*non-null*/ shptr<class Accumulator> offset) {
		auto m = ManagedCall("TextSpan", "getSpanForPositionVisitor");
		m.put("this", this);
		m.put("position", position, true);
		m.put("offset", offset, true);
		shptr<class InlineSpan> result;
		m.call(result);
		return result;
	}

	void TextSpan::computeToPlainText(/*non-null*/ shptr<class StringBuffer> buffer, _computeToPlainText p) {
		auto m = ManagedCall("TextSpan", "computeToPlainText");
		m.put("this", this);
		m.put("buffer", buffer, true);
		m.put("includeSemanticsLabels", p.includeSemanticsLabels);
		m.put("includePlaceholders", p.includePlaceholders);
		m.call();
	}

	void TextSpan::computeSemanticsInformation(/*non-null*/ stdvec<shptr<class InlineSpanSemanticsInformation>> collector, _computeSemanticsInformation p) {
		auto m = ManagedCall("TextSpan", "computeSemanticsInformation");
		m.put("this", this);
		m.put("collector", collector);
		m.put("inheritedLocale", p.inheritedLocale);
		m.put("inheritedSpellOut", p.inheritedSpellOut);
		m.call();
	}

	stdop<int64> /*nullable*/ TextSpan::codeUnitAtVisitor(/*non-null*/ int64 index, /*non-null*/ shptr<class Accumulator> offset) {
		auto m = ManagedCall("TextSpan", "codeUnitAtVisitor");
		m.put("this", this);
		m.put("index", index);
		m.put("offset", offset, true);
		stdop<int64> result;
		m.call(result);
		return result;
	}

	void TextSpan::describeSemantics(/*non-null*/ shptr<class Accumulator> offset, /*non-null*/ stdvec<int64> semanticsOffsets, /*non-null*/ stdvec<shptr<class ObjBase>> semanticsElements) {
		auto m = ManagedCall("TextSpan", "describeSemantics");
		m.put("this", this);
		m.put("offset", offset, true);
		m.put("semanticsOffsets", semanticsOffsets);
		m.put("semanticsElements", semanticsElements);
		m.call();
	}

	RenderComparison /*non-null*/ TextSpan::compareTo(/*non-null*/ shptr<class InlineSpan> other) {
		auto m = ManagedCall("TextSpan", "compareTo");
		m.put("this", this);
		m.put("other", other, true);
		RenderComparison result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ TextSpan::equals(/*non-null*/ shptr<class ObjBase> other) {
		auto m = ManagedCall("TextSpan", "==");
		m.put("this", this);
		m.put("other", other, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	stdstr /*non-null*/ TextSpan::toStringShort() {
		auto m = ManagedCall("TextSpan", "toStringShort");
		m.put("this", this);
		stdstr result;
		m.check(m.call(result));
		return result;
	}

	shptr<class TextSpan> /*non-null*/ TextSpan::ctorMain(_ctorMain p) {
		auto m = ManagedCall("TextSpan", "TextSpan");
		m.put("text", p.text);
		m.put("children", p.children);
		m.put("style", p.style);
		m.put("recognizer", p.recognizer);
		m.put("mouseCursor", p.mouseCursor);
		m.put("onEnter", p.onEnter);
		m.put("onExit", p.onExit);
		m.put("semanticsLabel", p.semanticsLabel);
		m.put("locale", p.locale);
		m.put("spellOut", p.spellOut);
		shptr<class TextSpan> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Widget> /*var-non-null*/ WidgetSpan::child() {
		auto m = ManagedCall("WidgetSpan", "child");
		m.put("this", this);
		shptr<class Widget> result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ WidgetSpan::visitChildren(/*non-null*/ stdfunc<bool(shptr<class InlineSpan>)> /*(InlineSpan) -> bool*/ visitor) {
		auto m = ManagedCall("WidgetSpan", "visitChildren");
		m.put("this", this);
		m.put("visitor", visitor, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ WidgetSpan::visitDirectChildren(/*non-null*/ stdfunc<bool(shptr<class InlineSpan>)> /*(InlineSpan) -> bool*/ visitor) {
		auto m = ManagedCall("WidgetSpan", "visitDirectChildren");
		m.put("this", this);
		m.put("visitor", visitor, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class InlineSpan> /*nullable*/ WidgetSpan::getSpanForPositionVisitor(/*non-null*/ shptr<class TextPosition> position, /*non-null*/ shptr<class Accumulator> offset) {
		auto m = ManagedCall("WidgetSpan", "getSpanForPositionVisitor");
		m.put("this", this);
		m.put("position", position, true);
		m.put("offset", offset, true);
		shptr<class InlineSpan> result;
		m.call(result);
		return result;
	}

	stdop<int64> /*nullable*/ WidgetSpan::codeUnitAtVisitor(/*non-null*/ int64 index, /*non-null*/ shptr<class Accumulator> offset) {
		auto m = ManagedCall("WidgetSpan", "codeUnitAtVisitor");
		m.put("this", this);
		m.put("index", index);
		m.put("offset", offset, true);
		stdop<int64> result;
		m.call(result);
		return result;
	}

	RenderComparison /*non-null*/ WidgetSpan::compareTo(/*non-null*/ shptr<class InlineSpan> other) {
		auto m = ManagedCall("WidgetSpan", "compareTo");
		m.put("this", this);
		m.put("other", other, true);
		RenderComparison result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ WidgetSpan::equals(/*non-null*/ shptr<class ObjBase> other) {
		auto m = ManagedCall("WidgetSpan", "==");
		m.put("this", this);
		m.put("other", other, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class InlineSpan> /*nullable*/ WidgetSpan::getSpanForPosition(/*non-null*/ shptr<class TextPosition> position) {
		auto m = ManagedCall("WidgetSpan", "getSpanForPosition");
		m.put("this", this);
		m.put("position", position, true);
		shptr<class InlineSpan> result;
		m.call(result);
		return result;
	}

	shptr<class WidgetSpan> /*non-null*/ WidgetSpan::ctorMain(_ctorMain p) {
		auto m = ManagedCall("WidgetSpan", "WidgetSpan");
		m.put("child", p.child, true);
		m.put("alignment", p.alignment);
		m.put("baseline", p.baseline);
		m.put("style", p.style);
		shptr<class WidgetSpan> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class ImageFilter> /*var-non-null*/ BackdropFilter::filter() {
		auto m = ManagedCall("BackdropFilter", "filter");
		m.put("this", this);
		shptr<class ImageFilter> result;
		m.check(m.call(result));
		return result;
	}

	BlendMode /*var-non-null*/ BackdropFilter::blendMode() {
		auto m = ManagedCall("BackdropFilter", "blendMode");
		m.put("this", this);
		BlendMode result;
		m.check(m.call(result));
		return result;
	}

	shptr<class BackdropFilter> /*non-null*/ BackdropFilter::ctorMain(_ctorMain p) {
		auto m = ManagedCall("BackdropFilter", "BackdropFilter");
		m.put("key", p.key);
		m.put("filter", p.filter, true);
		m.put("child", p.child);
		m.put("blendMode", p.blendMode);
		shptr<class BackdropFilter> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class ImageFilter> /*var-non-null*/ ImageFiltered::imageFilter() {
		auto m = ManagedCall("ImageFiltered", "imageFilter");
		m.put("this", this);
		shptr<class ImageFilter> result;
		m.check(m.call(result));
		return result;
	}

	bool /*var-non-null*/ ImageFiltered::enabled() {
		auto m = ManagedCall("ImageFiltered", "enabled");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ImageFiltered> /*non-null*/ ImageFiltered::ctorMain(_ctorMain p) {
		auto m = ManagedCall("ImageFiltered", "ImageFiltered");
		m.put("key", p.key);
		m.put("imageFilter", p.imageFilter, true);
		m.put("child", p.child);
		m.put("enabled", p.enabled);
		shptr<class ImageFiltered> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Matrix4> /*var-non-null*/ Transform::transform() {
		auto m = ManagedCall("Transform", "transform");
		m.put("this", this);
		shptr<class Matrix4> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Offset> /*var-nullable*/ Transform::origin() {
		auto m = ManagedCall("Transform", "origin");
		m.put("this", this);
		shptr<class Offset> result;
		m.call(result);
		return result;
	}

	shptr<class AlignmentGeometry> /*var-nullable*/ Transform::alignment() {
		auto m = ManagedCall("Transform", "alignment");
		m.put("this", this);
		shptr<class AlignmentGeometry> result;
		m.call(result);
		return result;
	}

	bool /*var-non-null*/ Transform::transformHitTests() {
		auto m = ManagedCall("Transform", "transformHitTests");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	stdop<FilterQuality> /*var-nullable*/ Transform::filterQuality() {
		auto m = ManagedCall("Transform", "filterQuality");
		m.put("this", this);
		stdop<FilterQuality> result;
		m.call(result);
		return result;
	}

	shptr<class Transform> /*non-null*/ Transform::ctorMain(_ctorMain p) {
		auto m = ManagedCall("Transform", "Transform");
		m.put("key", p.key);
		m.put("transform", p.transform, true);
		m.put("origin", p.origin);
		m.put("alignment", p.alignment);
		m.put("transformHitTests", p.transformHitTests);
		m.put("filterQuality", p.filterQuality);
		m.put("child", p.child);
		shptr<class Transform> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Transform> /*non-null*/ Transform::rotate(_rotate p) {
		auto m = ManagedCall("Transform", "rotate");
		m.put("key", p.key);
		m.put("angle", p.angle);
		m.put("origin", p.origin);
		m.put("alignment", p.alignment);
		m.put("transformHitTests", p.transformHitTests);
		m.put("filterQuality", p.filterQuality);
		m.put("child", p.child);
		shptr<class Transform> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Transform> /*non-null*/ Transform::translate(_translate p) {
		auto m = ManagedCall("Transform", "translate");
		m.put("key", p.key);
		m.put("offset", p.offset, true);
		m.put("transformHitTests", p.transformHitTests);
		m.put("filterQuality", p.filterQuality);
		m.put("child", p.child);
		shptr<class Transform> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Transform> /*non-null*/ Transform::scale(_scale p) {
		auto m = ManagedCall("Transform", "scale");
		m.put("key", p.key);
		m.put("scale", p.scale);
		m.put("scaleX", p.scaleX);
		m.put("scaleY", p.scaleY);
		m.put("origin", p.origin);
		m.put("alignment", p.alignment);
		m.put("transformHitTests", p.transformHitTests);
		m.put("filterQuality", p.filterQuality);
		m.put("child", p.child);
		shptr<class Transform> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Transform> /*non-null*/ Transform::flip(_flip p) {
		auto m = ManagedCall("Transform", "flip");
		m.put("key", p.key);
		m.put("flipX", p.flipX);
		m.put("flipY", p.flipY);
		m.put("origin", p.origin);
		m.put("transformHitTests", p.transformHitTests);
		m.put("filterQuality", p.filterQuality);
		m.put("child", p.child);
		shptr<class Transform> result;
		m.check(m.call(result, true));
		return result;
	}

	stdop<double> /*var-nullable*/ Divider::height() {
		auto m = ManagedCall("Divider", "height");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ Divider::thickness() {
		auto m = ManagedCall("Divider", "thickness");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ Divider::indent() {
		auto m = ManagedCall("Divider", "indent");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ Divider::endIndent() {
		auto m = ManagedCall("Divider", "endIndent");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ Divider::color() {
		auto m = ManagedCall("Divider", "color");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class BorderSide> /*non-null*/ Divider::createBorderSide(/*nullable*/ shptr<class BuildContext> context, _createBorderSide p) {
		auto m = ManagedCall("Divider", "createBorderSide");
		m.put("context", context);
		m.put("color", p.color);
		m.put("width", p.width);
		shptr<class BorderSide> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Divider> /*non-null*/ Divider::ctorMain(_ctorMain p) {
		auto m = ManagedCall("Divider", "Divider");
		m.put("key", p.key);
		m.put("height", p.height);
		m.put("thickness", p.thickness);
		m.put("indent", p.indent);
		m.put("endIndent", p.endIndent);
		m.put("color", p.color);
		shptr<class Divider> result;
		m.check(m.call(result, true));
		return result;
	}

	stdop<double> /*var-nullable*/ VerticalDivider::width() {
		auto m = ManagedCall("VerticalDivider", "width");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ VerticalDivider::thickness() {
		auto m = ManagedCall("VerticalDivider", "thickness");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ VerticalDivider::indent() {
		auto m = ManagedCall("VerticalDivider", "indent");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ VerticalDivider::endIndent() {
		auto m = ManagedCall("VerticalDivider", "endIndent");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ VerticalDivider::color() {
		auto m = ManagedCall("VerticalDivider", "color");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class VerticalDivider> /*non-null*/ VerticalDivider::ctorMain(_ctorMain p) {
		auto m = ManagedCall("VerticalDivider", "VerticalDivider");
		m.put("key", p.key);
		m.put("width", p.width);
		m.put("thickness", p.thickness);
		m.put("indent", p.indent);
		m.put("endIndent", p.endIndent);
		m.put("color", p.color);
		shptr<class VerticalDivider> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Color> /*var-non-null*/ GridPaper::color() {
		auto m = ManagedCall("GridPaper", "color");
		m.put("this", this);
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	double /*var-non-null*/ GridPaper::interval() {
		auto m = ManagedCall("GridPaper", "interval");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	int64 /*var-non-null*/ GridPaper::divisions() {
		auto m = ManagedCall("GridPaper", "divisions");
		m.put("this", this);
		int64 result;
		m.check(m.call(result));
		return result;
	}

	int64 /*var-non-null*/ GridPaper::subdivisions() {
		auto m = ManagedCall("GridPaper", "subdivisions");
		m.put("this", this);
		int64 result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Widget> /*var-nullable*/ GridPaper::child() {
		auto m = ManagedCall("GridPaper", "child");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	shptr<class GridPaper> /*non-null*/ GridPaper::ctorMain(_ctorMain p) {
		auto m = ManagedCall("GridPaper", "GridPaper");
		m.put("key", p.key);
		m.put("color", p.color, true);
		m.put("interval", p.interval);
		m.put("divisions", p.divisions);
		m.put("subdivisions", p.subdivisions);
		m.put("child", p.child);
		shptr<class GridPaper> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Alignment> /*var-nullable*/ InteractiveViewer::alignment() {
		auto m = ManagedCall("InteractiveViewer", "alignment");
		m.put("this", this);
		shptr<class Alignment> result;
		m.call(result);
		return result;
	}

	Clip /*var-non-null*/ InteractiveViewer::clipBehavior() {
		auto m = ManagedCall("InteractiveViewer", "clipBehavior");
		m.put("this", this);
		Clip result;
		m.check(m.call(result));
		return result;
	}

	bool /*var-non-null*/ InteractiveViewer::alignPanAxis() {
		auto m = ManagedCall("InteractiveViewer", "alignPanAxis");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	PanAxis /*var-non-null*/ InteractiveViewer::panAxis() {
		auto m = ManagedCall("InteractiveViewer", "panAxis");
		m.put("this", this);
		PanAxis result;
		m.check(m.call(result));
		return result;
	}

	shptr<class EdgeInsets> /*var-non-null*/ InteractiveViewer::boundaryMargin() {
		auto m = ManagedCall("InteractiveViewer", "boundaryMargin");
		m.put("this", this);
		shptr<class EdgeInsets> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Widget> /*var-nullable*/ InteractiveViewer::child() {
		auto m = ManagedCall("InteractiveViewer", "child");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	bool /*var-non-null*/ InteractiveViewer::constrained() {
		auto m = ManagedCall("InteractiveViewer", "constrained");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	bool /*var-non-null*/ InteractiveViewer::panEnabled() {
		auto m = ManagedCall("InteractiveViewer", "panEnabled");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	bool /*var-non-null*/ InteractiveViewer::scaleEnabled() {
		auto m = ManagedCall("InteractiveViewer", "scaleEnabled");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	bool /*var-non-null*/ InteractiveViewer::trackpadScrollCausesScale() {
		auto m = ManagedCall("InteractiveViewer", "trackpadScrollCausesScale");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	double /*var-non-null*/ InteractiveViewer::scaleFactor() {
		auto m = ManagedCall("InteractiveViewer", "scaleFactor");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	double /*var-non-null*/ InteractiveViewer::maxScale() {
		auto m = ManagedCall("InteractiveViewer", "maxScale");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	double /*var-non-null*/ InteractiveViewer::minScale() {
		auto m = ManagedCall("InteractiveViewer", "minScale");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	double /*var-non-null*/ InteractiveViewer::interactionEndFrictionCoefficient() {
		auto m = ManagedCall("InteractiveViewer", "interactionEndFrictionCoefficient");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	shptr<class TransformationController> /*var-nullable*/ InteractiveViewer::transformationController() {
		auto m = ManagedCall("InteractiveViewer", "transformationController");
		m.put("this", this);
		shptr<class TransformationController> result;
		m.call(result);
		return result;
	}

	shptr<class InteractiveViewer> /*non-null*/ InteractiveViewer::ctorMain(_ctorMain p) {
		auto m = ManagedCall("InteractiveViewer", "InteractiveViewer");
		m.put("key", p.key);
		m.put("clipBehavior", p.clipBehavior);
		m.put("alignPanAxis", p.alignPanAxis);
		m.put("panAxis", p.panAxis);
		m.put("boundaryMargin", p.boundaryMargin, true);
		m.put("constrained", p.constrained);
		m.put("maxScale", p.maxScale);
		m.put("minScale", p.minScale);
		m.put("interactionEndFrictionCoefficient", p.interactionEndFrictionCoefficient);
		m.put("onInteractionEnd", p.onInteractionEnd);
		m.put("onInteractionStart", p.onInteractionStart);
		m.put("onInteractionUpdate", p.onInteractionUpdate);
		m.put("panEnabled", p.panEnabled);
		m.put("scaleEnabled", p.scaleEnabled);
		m.put("scaleFactor", p.scaleFactor);
		m.put("transformationController", p.transformationController);
		m.put("alignment", p.alignment);
		m.put("trackpadScrollCausesScale", p.trackpadScrollCausesScale);
		m.put("child", p.child, true);
		shptr<class InteractiveViewer> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Widget> /*non-null*/ keyboardContextMenuBuilder(/*non-null*/ shptr<class BuildContext> context, /*non-null*/ shptr<class EditableTextState> editableTextState, KeyboardContextMenuBuilder p) {
		auto m = ManagedCall("Funcs", "KeyboardContextMenuBuilder");
		m.put("context", context, true);
		m.put("editableTextState", editableTextState, true);
		m.put("fontSize", p.fontSize);
		m.put("fontColor", p.fontColor);
		m.put("backgroundColor", p.backgroundColor);
		m.put("multiline", p.multiline);
		m.put("onSubmit", p.onSubmit);
		m.put("hints", p.hints);
		shptr<class Widget> result;
		m.check(m.call(result));
		return result;
	}

	void showAboutDialog(ShowAboutDialog p) {
		auto m = ManagedCall("Funcs", "ShowAboutDialog");
		m.put("context", p.context, true);
		m.put("applicationName", p.applicationName);
		m.put("applicationVersion", p.applicationVersion);
		m.put("applicationIcon", p.applicationIcon);
		m.put("applicationLegalese", p.applicationLegalese);
		m.put("children", p.children);
		m.put("useRootNavigator", p.useRootNavigator);
		m.put("routeSettings", p.routeSettings);
		m.put("anchorPoint", p.anchorPoint);
		m.call();
	}

	void showAdaptiveDialog(ShowAdaptiveDialog p) {
		auto m = ManagedCall("Funcs", "ShowAdaptiveDialog");
		m.put("context", p.context, true);
		m.put("builder", p.builder, true);
		m.put("barrierDismissible", p.barrierDismissible);
		m.put("barrierColor", p.barrierColor);
		m.put("barrierLabel", p.barrierLabel);
		m.put("useSafeArea", p.useSafeArea);
		m.put("useRootNavigator", p.useRootNavigator);
		m.put("routeSettings", p.routeSettings);
		m.put("anchorPoint", p.anchorPoint);
		m.put("traversalEdgeBehavior", p.traversalEdgeBehavior);
		m.put("onComplete", p.onComplete);
		m.call();
	}

	void showBottomSheet(ShowBottomSheet p) {
		auto m = ManagedCall("Funcs", "ShowBottomSheet");
		m.put("context", p.context, true);
		m.put("builder", p.builder, true);
		m.put("backgroundColor", p.backgroundColor);
		m.put("elevation", p.elevation);
		m.put("shape", p.shape);
		m.put("clipBehavior", p.clipBehavior);
		m.put("constraints", p.constraints);
		m.put("enableDrag", p.enableDrag);
		m.put("transitionAnimationController", p.transitionAnimationController);
		m.put("onComplete", p.onComplete);
		m.call();
	}

	void showCupertinoDialog(ShowCupertinoDialog p) {
		auto m = ManagedCall("Funcs", "ShowCupertinoDialog");
		m.put("context", p.context, true);
		m.put("builder", p.builder, true);
		m.put("barrierLabel", p.barrierLabel);
		m.put("useRootNavigator", p.useRootNavigator);
		m.put("barrierDismissible", p.barrierDismissible);
		m.put("routeSettings", p.routeSettings);
		m.put("anchorPoint", p.anchorPoint);
		m.put("onComplete", p.onComplete);
		m.call();
	}

	void showCupertinoModalPopup(ShowCupertinoModalPopup p) {
		auto m = ManagedCall("Funcs", "ShowCupertinoModalPopup");
		m.put("context", p.context, true);
		m.put("builder", p.builder, true);
		m.put("filter", p.filter);
		m.put("barrierColor", p.barrierColor, true);
		m.put("barrierDismissible", p.barrierDismissible);
		m.put("useRootNavigator", p.useRootNavigator);
		m.put("semanticsDismissible", p.semanticsDismissible);
		m.put("routeSettings", p.routeSettings);
		m.put("anchorPoint", p.anchorPoint);
		m.put("onComplete", p.onComplete);
		m.call();
	}

	void showDatePicker(ShowDatePicker p) {
		auto m = ManagedCall("Funcs", "ShowDatePicker");		
		m.put("context", p.context, true);
		m.put("initialDate", p.initialDate, true);
		m.put("firstDate", p.firstDate, true);
		m.put("lastDate", p.lastDate, true);
		m.put("currentDate", p.currentDate);
		m.put("initialEntryMode", p.initialEntryMode);
		m.put("selectableDayPredicate", p.selectableDayPredicate);
		m.put("helpText", p.helpText);
		m.put("cancelText", p.cancelText);
		m.put("confirmText", p.confirmText);
		m.put("locale", p.locale);
		m.put("useRootNavigator", p.useRootNavigator);
		m.put("routeSettings", p.routeSettings);
		m.put("textDirection", p.textDirection);
		m.put("builder", p.builder);
		m.put("initialDatePickerMode", p.initialDatePickerMode);
		m.put("errorFormatText", p.errorFormatText);
		m.put("errorInvalidText", p.errorInvalidText);
		m.put("fieldHintText", p.fieldHintText);
		m.put("fieldLabelText", p.fieldLabelText);
		m.put("keyboardType", p.keyboardType);
		m.put("anchorPoint", p.anchorPoint);
		//	m.put("onDatePickerModeChange", p.onDatePickerModeChange);
		m.put("switchToInputEntryModeIcon", p.switchToInputEntryModeIcon);
		m.put("switchToCalendarEntryModeIcon", p.switchToCalendarEntryModeIcon);
		m.put("onResult", p.onResult, true);
		m.call();
	}

	void showDialog(ShowDialog p) {
		auto m = ManagedCall("Funcs", "ShowDialog");
		m.put("context", p.context, true);
		m.put("builder", p.builder, true);
		m.put("barrierDismissible", p.barrierDismissible);
		m.put("barrierColor", p.barrierColor);
		m.put("barrierLabel", p.barrierLabel);
		m.put("useSafeArea", p.useSafeArea);
		m.put("useRootNavigator", p.useRootNavigator);
		m.put("routeSettings", p.routeSettings);
		m.put("anchorPoint", p.anchorPoint);
		m.put("traversalEdgeBehavior", p.traversalEdgeBehavior);
		m.put("onComplete", p.onComplete);
		m.call();
	}

	void showGeneralDialog(ShowGeneralDialog p) {
		auto m = ManagedCall("Funcs", "ShowGeneralDialog");
		m.put("context", p.context, true);
		m.put("pageBuilder", p.pageBuilder, true);
		m.put("barrierDismissible", p.barrierDismissible);
		m.put("barrierLabel", p.barrierLabel);
		m.put("barrierColor", p.barrierColor, true);
		m.put("transitionDuration", p.transitionDuration, true);
		//	m.put("transitionBuilder", p.transitionBuilder);
		m.put("useRootNavigator", p.useRootNavigator);
		m.put("routeSettings", p.routeSettings);
		m.put("anchorPoint", p.anchorPoint);
		m.put("onComplete", p.onComplete);
		m.call();
	}

	void showMenu(ShowMenu p) {
		auto m = ManagedCall("Funcs", "ShowMenu");
		m.put("context", p.context, true);
		m.put("position", p.position, true);
		m.put("items", p.items);
		m.put("initialValue", p.initialValue);
		m.put("elevation", p.elevation);
		m.put("shadowColor", p.shadowColor);
		m.put("surfaceTintColor", p.surfaceTintColor);
		m.put("semanticLabel", p.semanticLabel);
		m.put("shape", p.shape);
		m.put("color", p.color);
		m.put("useRootNavigator", p.useRootNavigator);
		m.put("constraints", p.constraints);
		m.put("clipBehavior", p.clipBehavior);
		m.put("routeSettings", p.routeSettings);
		m.put("onComplete", p.onComplete);
		m.call();
	}

	void showModalBottomSheet(ShowModalBottomSheet p) {
		auto m = ManagedCall("Funcs", "ShowModalBottomSheet");
		m.put("context", p.context, true);
		m.put("builder", p.builder, true);
		m.put("backgroundColor", p.backgroundColor);
		m.put("barrierLabel", p.barrierLabel);
		m.put("elevation", p.elevation);
		m.put("shape", p.shape);
		m.put("clipBehavior", p.clipBehavior);
		m.put("constraints", p.constraints);
		m.put("barrierColor", p.barrierColor);
		m.put("isScrollControlled", p.isScrollControlled);
		m.put("useRootNavigator", p.useRootNavigator);
		m.put("isDismissible", p.isDismissible);
		m.put("enableDrag", p.enableDrag);
		m.put("showDragHandle", p.showDragHandle);
		m.put("useSafeArea", p.useSafeArea);
		m.put("routeSettings", p.routeSettings);
		m.put("transitionAnimationController", p.transitionAnimationController);
		m.put("anchorPoint", p.anchorPoint);
		m.put("onComplete", p.onComplete);
		m.call();
	}

	void showTimePicker(ShowTimePicker p) {
		auto m = ManagedCall("Funcs", "ShowTimePicker");		
		m.put("context", p.context, true);
		m.put("initialTime", p.initialTime, true);
		m.put("builder", p.builder);
		m.put("useRootNavigator", p.useRootNavigator);
		m.put("initialEntryMode", p.initialEntryMode);
		m.put("cancelText", p.cancelText);
		m.put("confirmText", p.confirmText);
		m.put("helpText", p.helpText);
		m.put("errorInvalidText", p.errorInvalidText);
		m.put("hourLabelText", p.hourLabelText);
		m.put("minuteLabelText", p.minuteLabelText);
		m.put("routeSettings", p.routeSettings);
		//	m.put("onEntryModeChanged", p.onEntryModeChanged);
		m.put("anchorPoint", p.anchorPoint);
		m.put("orientation", p.orientation);
		m.put("onResult", p.onResult, true);
		m.call();
	}

	shptr<class Widget> /*var-nullable*/ AnimatedScale::child() {
		auto m = ManagedCall("AnimatedScale", "child");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	double /*var-non-null*/ AnimatedScale::scale() {
		auto m = ManagedCall("AnimatedScale", "scale");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Alignment> /*var-non-null*/ AnimatedScale::alignment() {
		auto m = ManagedCall("AnimatedScale", "alignment");
		m.put("this", this);
		shptr<class Alignment> result;
		m.check(m.call(result));
		return result;
	}

	stdop<FilterQuality> /*var-nullable*/ AnimatedScale::filterQuality() {
		auto m = ManagedCall("AnimatedScale", "filterQuality");
		m.put("this", this);
		stdop<FilterQuality> result;
		m.call(result);
		return result;
	}

	shptr<class AnimatedScale> /*non-null*/ AnimatedScale::ctorMain(_ctorMain p) {
		auto m = ManagedCall("AnimatedScale", "AnimatedScale");
		m.put("key", p.key);
		m.put("child", p.child);
		m.put("scale", p.scale);
		m.put("alignment", p.alignment, true);
		m.put("filterQuality", p.filterQuality);
		m.put("curve", p.curve, true);
		m.put("duration", p.duration, true);
		m.put("onEnd", p.onEnd);
		shptr<class AnimatedScale> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Widget> /*var-nullable*/ AnimatedContainer::child() {
		auto m = ManagedCall("AnimatedContainer", "child");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	shptr<class AlignmentGeometry> /*var-nullable*/ AnimatedContainer::alignment() {
		auto m = ManagedCall("AnimatedContainer", "alignment");
		m.put("this", this);
		shptr<class AlignmentGeometry> result;
		m.call(result);
		return result;
	}

	shptr<class EdgeInsetsGeometry> /*var-nullable*/ AnimatedContainer::padding() {
		auto m = ManagedCall("AnimatedContainer", "padding");
		m.put("this", this);
		shptr<class EdgeInsetsGeometry> result;
		m.call(result);
		return result;
	}

	shptr<class Decoration> /*var-nullable*/ AnimatedContainer::decoration() {
		auto m = ManagedCall("AnimatedContainer", "decoration");
		m.put("this", this);
		shptr<class Decoration> result;
		m.call(result);
		return result;
	}

	shptr<class Decoration> /*var-nullable*/ AnimatedContainer::foregroundDecoration() {
		auto m = ManagedCall("AnimatedContainer", "foregroundDecoration");
		m.put("this", this);
		shptr<class Decoration> result;
		m.call(result);
		return result;
	}

	shptr<class BoxConstraints> /*var-nullable*/ AnimatedContainer::constraints() {
		auto m = ManagedCall("AnimatedContainer", "constraints");
		m.put("this", this);
		shptr<class BoxConstraints> result;
		m.call(result);
		return result;
	}

	shptr<class EdgeInsetsGeometry> /*var-nullable*/ AnimatedContainer::margin() {
		auto m = ManagedCall("AnimatedContainer", "margin");
		m.put("this", this);
		shptr<class EdgeInsetsGeometry> result;
		m.call(result);
		return result;
	}

	shptr<class Matrix4> /*var-nullable*/ AnimatedContainer::transform() {
		auto m = ManagedCall("AnimatedContainer", "transform");
		m.put("this", this);
		shptr<class Matrix4> result;
		m.call(result);
		return result;
	}

	shptr<class AlignmentGeometry> /*var-nullable*/ AnimatedContainer::transformAlignment() {
		auto m = ManagedCall("AnimatedContainer", "transformAlignment");
		m.put("this", this);
		shptr<class AlignmentGeometry> result;
		m.call(result);
		return result;
	}

	Clip /*var-non-null*/ AnimatedContainer::clipBehavior() {
		auto m = ManagedCall("AnimatedContainer", "clipBehavior");
		m.put("this", this);
		Clip result;
		m.check(m.call(result));
		return result;
	}

	shptr<class AnimatedContainer> /*non-null*/ AnimatedContainer::ctorMain(_ctorMain p) {
		auto m = ManagedCall("AnimatedContainer", "AnimatedContainer");
		m.put("key", p.key);
		m.put("alignment", p.alignment);
		m.put("padding", p.padding);
		m.put("color", p.color);
		m.put("decoration", p.decoration);
		m.put("foregroundDecoration", p.foregroundDecoration);
		m.put("width", p.width);
		m.put("height", p.height);
		m.put("constraints", p.constraints);
		m.put("margin", p.margin);
		m.put("transform", p.transform);
		m.put("transformAlignment", p.transformAlignment);
		m.put("child", p.child);
		m.put("clipBehavior", p.clipBehavior);
		m.put("curve", p.curve, true);
		m.put("duration", p.duration, true);
		m.put("onEnd", p.onEnd);
		shptr<class AnimatedContainer> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Widget> /*var-non-null*/ AnimatedPhysicalModel::child() {
		auto m = ManagedCall("AnimatedPhysicalModel", "child");
		m.put("this", this);
		shptr<class Widget> result;
		m.check(m.call(result));
		return result;
	}

	BoxShape /*var-non-null*/ AnimatedPhysicalModel::shape() {
		auto m = ManagedCall("AnimatedPhysicalModel", "shape");
		m.put("this", this);
		BoxShape result;
		m.check(m.call(result));
		return result;
	}

	Clip /*var-non-null*/ AnimatedPhysicalModel::clipBehavior() {
		auto m = ManagedCall("AnimatedPhysicalModel", "clipBehavior");
		m.put("this", this);
		Clip result;
		m.check(m.call(result));
		return result;
	}

	shptr<class BorderRadius> /*var-non-null*/ AnimatedPhysicalModel::borderRadius() {
		auto m = ManagedCall("AnimatedPhysicalModel", "borderRadius");
		m.put("this", this);
		shptr<class BorderRadius> result;
		m.check(m.call(result));
		return result;
	}

	double /*var-non-null*/ AnimatedPhysicalModel::elevation() {
		auto m = ManagedCall("AnimatedPhysicalModel", "elevation");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*var-non-null*/ AnimatedPhysicalModel::color() {
		auto m = ManagedCall("AnimatedPhysicalModel", "color");
		m.put("this", this);
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	bool /*var-non-null*/ AnimatedPhysicalModel::animateColor() {
		auto m = ManagedCall("AnimatedPhysicalModel", "animateColor");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*var-non-null*/ AnimatedPhysicalModel::shadowColor() {
		auto m = ManagedCall("AnimatedPhysicalModel", "shadowColor");
		m.put("this", this);
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	bool /*var-non-null*/ AnimatedPhysicalModel::animateShadowColor() {
		auto m = ManagedCall("AnimatedPhysicalModel", "animateShadowColor");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class AnimatedPhysicalModel> /*non-null*/ AnimatedPhysicalModel::ctorMain(_ctorMain p) {
		auto m = ManagedCall("AnimatedPhysicalModel", "AnimatedPhysicalModel");
		m.put("key", p.key);
		m.put("child", p.child, true);
		m.put("shape", p.shape);
		m.put("clipBehavior", p.clipBehavior);
		m.put("borderRadius", p.borderRadius, true);
		m.put("elevation", p.elevation);
		m.put("color", p.color, true);
		m.put("animateColor", p.animateColor);
		m.put("shadowColor", p.shadowColor, true);
		m.put("animateShadowColor", p.animateShadowColor);
		m.put("curve", p.curve, true);
		m.put("duration", p.duration, true);
		m.put("onEnd", p.onEnd);
		shptr<class AnimatedPhysicalModel> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Widget> /*var-nullable*/ SliverAnimatedOpacity::sliver() {
		auto m = ManagedCall("SliverAnimatedOpacity", "sliver");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	double /*var-non-null*/ SliverAnimatedOpacity::opacity() {
		auto m = ManagedCall("SliverAnimatedOpacity", "opacity");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	bool /*var-non-null*/ SliverAnimatedOpacity::alwaysIncludeSemantics() {
		auto m = ManagedCall("SliverAnimatedOpacity", "alwaysIncludeSemantics");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class SliverAnimatedOpacity> /*non-null*/ SliverAnimatedOpacity::ctorMain(_ctorMain p) {
		auto m = ManagedCall("SliverAnimatedOpacity", "SliverAnimatedOpacity");
		m.put("key", p.key);
		m.put("sliver", p.sliver);
		m.put("opacity", p.opacity);
		m.put("curve", p.curve, true);
		m.put("duration", p.duration, true);
		m.put("onEnd", p.onEnd);
		m.put("alwaysIncludeSemantics", p.alwaysIncludeSemantics);
		shptr<class SliverAnimatedOpacity> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Widget> /*var-non-null*/ AnimatedPositionedDirectional::child() {
		auto m = ManagedCall("AnimatedPositionedDirectional", "child");
		m.put("this", this);
		shptr<class Widget> result;
		m.check(m.call(result));
		return result;
	}

	stdop<double> /*var-nullable*/ AnimatedPositionedDirectional::start() {
		auto m = ManagedCall("AnimatedPositionedDirectional", "start");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ AnimatedPositionedDirectional::top() {
		auto m = ManagedCall("AnimatedPositionedDirectional", "top");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ AnimatedPositionedDirectional::end() {
		auto m = ManagedCall("AnimatedPositionedDirectional", "end");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ AnimatedPositionedDirectional::bottom() {
		auto m = ManagedCall("AnimatedPositionedDirectional", "bottom");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ AnimatedPositionedDirectional::width() {
		auto m = ManagedCall("AnimatedPositionedDirectional", "width");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ AnimatedPositionedDirectional::height() {
		auto m = ManagedCall("AnimatedPositionedDirectional", "height");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	shptr<class AnimatedPositionedDirectional> /*non-null*/ AnimatedPositionedDirectional::ctorMain(_ctorMain p) {
		auto m = ManagedCall("AnimatedPositionedDirectional", "AnimatedPositionedDirectional");
		m.put("key", p.key);
		m.put("child", p.child, true);
		m.put("start", p.start);
		m.put("top", p.top);
		m.put("end", p.end);
		m.put("bottom", p.bottom);
		m.put("width", p.width);
		m.put("height", p.height);
		m.put("curve", p.curve, true);
		m.put("duration", p.duration, true);
		m.put("onEnd", p.onEnd);
		shptr<class AnimatedPositionedDirectional> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Widget> /*var-nullable*/ AnimatedRotation::child() {
		auto m = ManagedCall("AnimatedRotation", "child");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	double /*var-non-null*/ AnimatedRotation::turns() {
		auto m = ManagedCall("AnimatedRotation", "turns");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Alignment> /*var-non-null*/ AnimatedRotation::alignment() {
		auto m = ManagedCall("AnimatedRotation", "alignment");
		m.put("this", this);
		shptr<class Alignment> result;
		m.check(m.call(result));
		return result;
	}

	stdop<FilterQuality> /*var-nullable*/ AnimatedRotation::filterQuality() {
		auto m = ManagedCall("AnimatedRotation", "filterQuality");
		m.put("this", this);
		stdop<FilterQuality> result;
		m.call(result);
		return result;
	}

	shptr<class AnimatedRotation> /*non-null*/ AnimatedRotation::ctorMain(_ctorMain p) {
		auto m = ManagedCall("AnimatedRotation", "AnimatedRotation");
		m.put("key", p.key);
		m.put("child", p.child);
		m.put("turns", p.turns);
		m.put("alignment", p.alignment, true);
		m.put("filterQuality", p.filterQuality);
		m.put("curve", p.curve, true);
		m.put("duration", p.duration, true);
		m.put("onEnd", p.onEnd);
		shptr<class AnimatedRotation> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Widget> /*var-nullable*/ AnimatedSwitcher::child() {
		auto m = ManagedCall("AnimatedSwitcher", "child");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	shptr<class Duration> /*var-non-null*/ AnimatedSwitcher::duration() {
		auto m = ManagedCall("AnimatedSwitcher", "duration");
		m.put("this", this);
		shptr<class Duration> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Duration> /*var-nullable*/ AnimatedSwitcher::reverseDuration() {
		auto m = ManagedCall("AnimatedSwitcher", "reverseDuration");
		m.put("this", this);
		shptr<class Duration> result;
		m.call(result);
		return result;
	}

	shptr<class Curve> /*var-non-null*/ AnimatedSwitcher::switchInCurve() {
		auto m = ManagedCall("AnimatedSwitcher", "switchInCurve");
		m.put("this", this);
		shptr<class Curve> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Curve> /*var-non-null*/ AnimatedSwitcher::switchOutCurve() {
		auto m = ManagedCall("AnimatedSwitcher", "switchOutCurve");
		m.put("this", this);
		shptr<class Curve> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class AnimatedSwitcher> /*non-null*/ AnimatedSwitcher::ctorMain(_ctorMain p) {
		auto m = ManagedCall("AnimatedSwitcher", "AnimatedSwitcher");
		m.put("key", p.key);
		m.put("child", p.child);
		m.put("duration", p.duration, true);
		m.put("reverseDuration", p.reverseDuration);
		m.put("switchInCurve", p.switchInCurve, true);
		m.put("switchOutCurve", p.switchOutCurve, true);
//		m.put("transitionBuilder", p.transitionBuilder, true);
//		m.put("layoutBuilder", p.layoutBuilder, true);
		shptr<class AnimatedSwitcher> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Widget> /*var-non-null*/ AnimatedCrossFade::firstChild() {
		auto m = ManagedCall("AnimatedCrossFade", "firstChild");
		m.put("this", this);
		shptr<class Widget> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Widget> /*var-non-null*/ AnimatedCrossFade::secondChild() {
		auto m = ManagedCall("AnimatedCrossFade", "secondChild");
		m.put("this", this);
		shptr<class Widget> result;
		m.check(m.call(result));
		return result;
	}

	CrossFadeState /*var-non-null*/ AnimatedCrossFade::crossFadeState() {
		auto m = ManagedCall("AnimatedCrossFade", "crossFadeState");
		m.put("this", this);
		CrossFadeState result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Duration> /*var-non-null*/ AnimatedCrossFade::duration() {
		auto m = ManagedCall("AnimatedCrossFade", "duration");
		m.put("this", this);
		shptr<class Duration> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Duration> /*var-nullable*/ AnimatedCrossFade::reverseDuration() {
		auto m = ManagedCall("AnimatedCrossFade", "reverseDuration");
		m.put("this", this);
		shptr<class Duration> result;
		m.call(result);
		return result;
	}

	shptr<class Curve> /*var-non-null*/ AnimatedCrossFade::firstCurve() {
		auto m = ManagedCall("AnimatedCrossFade", "firstCurve");
		m.put("this", this);
		shptr<class Curve> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Curve> /*var-non-null*/ AnimatedCrossFade::secondCurve() {
		auto m = ManagedCall("AnimatedCrossFade", "secondCurve");
		m.put("this", this);
		shptr<class Curve> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Curve> /*var-non-null*/ AnimatedCrossFade::sizeCurve() {
		auto m = ManagedCall("AnimatedCrossFade", "sizeCurve");
		m.put("this", this);
		shptr<class Curve> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class AlignmentGeometry> /*var-non-null*/ AnimatedCrossFade::alignment() {
		auto m = ManagedCall("AnimatedCrossFade", "alignment");
		m.put("this", this);
		shptr<class AlignmentGeometry> result;
		m.check(m.call(result));
		return result;
	}

	bool /*var-non-null*/ AnimatedCrossFade::excludeBottomFocus() {
		auto m = ManagedCall("AnimatedCrossFade", "excludeBottomFocus");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class AnimatedCrossFade> /*non-null*/ AnimatedCrossFade::ctorMain(_ctorMain p) {
		auto m = ManagedCall("AnimatedCrossFade", "AnimatedCrossFade");
		m.put("key", p.key);
		m.put("firstChild", p.firstChild, true);
		m.put("secondChild", p.secondChild, true);
		m.put("firstCurve", p.firstCurve, true);
		m.put("secondCurve", p.secondCurve, true);
		m.put("sizeCurve", p.sizeCurve, true);
		m.put("alignment", p.alignment, true);
		m.put("crossFadeState", p.crossFadeState);
		m.put("duration", p.duration, true);
		m.put("reverseDuration", p.reverseDuration);
//		m.put("layoutBuilder", p.layoutBuilder, true);
		m.put("excludeBottomFocus", p.excludeBottomFocus);
		shptr<class AnimatedCrossFade> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Widget> /*var-non-null*/ AnimatedPositioned::child() {
		auto m = ManagedCall("AnimatedPositioned", "child");
		m.put("this", this);
		shptr<class Widget> result;
		m.check(m.call(result));
		return result;
	}

	stdop<double> /*var-nullable*/ AnimatedPositioned::left() {
		auto m = ManagedCall("AnimatedPositioned", "left");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ AnimatedPositioned::top() {
		auto m = ManagedCall("AnimatedPositioned", "top");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ AnimatedPositioned::right() {
		auto m = ManagedCall("AnimatedPositioned", "right");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ AnimatedPositioned::bottom() {
		auto m = ManagedCall("AnimatedPositioned", "bottom");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ AnimatedPositioned::width() {
		auto m = ManagedCall("AnimatedPositioned", "width");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ AnimatedPositioned::height() {
		auto m = ManagedCall("AnimatedPositioned", "height");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	shptr<class AnimatedPositioned> /*non-null*/ AnimatedPositioned::ctorMain(_ctorMain p) {
		auto m = ManagedCall("AnimatedPositioned", "AnimatedPositioned");
		m.put("key", p.key);
		m.put("child", p.child, true);
		m.put("left", p.left);
		m.put("top", p.top);
		m.put("right", p.right);
		m.put("bottom", p.bottom);
		m.put("width", p.width);
		m.put("height", p.height);
		m.put("curve", p.curve, true);
		m.put("duration", p.duration, true);
		m.put("onEnd", p.onEnd);
		shptr<class AnimatedPositioned> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class AnimatedPositioned> /*non-null*/ AnimatedPositioned::fromRect(_fromRect p) {
		auto m = ManagedCall("AnimatedPositioned", "fromRect");
		m.put("key", p.key);
		m.put("child", p.child, true);
		m.put("rect", p.rect, true);
		m.put("curve", p.curve, true);
		m.put("duration", p.duration, true);
		m.put("onEnd", p.onEnd);
		shptr<class AnimatedPositioned> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Widget> /*var-nullable*/ AnimatedOpacity::child() {
		auto m = ManagedCall("AnimatedOpacity", "child");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	double /*var-non-null*/ AnimatedOpacity::opacity() {
		auto m = ManagedCall("AnimatedOpacity", "opacity");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	bool /*var-non-null*/ AnimatedOpacity::alwaysIncludeSemantics() {
		auto m = ManagedCall("AnimatedOpacity", "alwaysIncludeSemantics");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class AnimatedOpacity> /*non-null*/ AnimatedOpacity::ctorMain(_ctorMain p) {
		auto m = ManagedCall("AnimatedOpacity", "AnimatedOpacity");
		m.put("key", p.key);
		m.put("child", p.child);
		m.put("opacity", p.opacity);
		m.put("curve", p.curve, true);
		m.put("duration", p.duration, true);
		m.put("onEnd", p.onEnd);
		m.put("alwaysIncludeSemantics", p.alwaysIncludeSemantics);
		shptr<class AnimatedOpacity> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class EdgeInsetsGeometry> /*var-non-null*/ AnimatedPadding::padding() {
		auto m = ManagedCall("AnimatedPadding", "padding");
		m.put("this", this);
		shptr<class EdgeInsetsGeometry> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Widget> /*var-nullable*/ AnimatedPadding::child() {
		auto m = ManagedCall("AnimatedPadding", "child");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	shptr<class AnimatedPadding> /*non-null*/ AnimatedPadding::ctorMain(_ctorMain p) {
		auto m = ManagedCall("AnimatedPadding", "AnimatedPadding");
		m.put("key", p.key);
		m.put("padding", p.padding, true);
		m.put("child", p.child);
		m.put("curve", p.curve, true);
		m.put("duration", p.duration, true);
		m.put("onEnd", p.onEnd);
		shptr<class AnimatedPadding> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class AlignmentGeometry> /*var-non-null*/ AnimatedAlign::alignment() {
		auto m = ManagedCall("AnimatedAlign", "alignment");
		m.put("this", this);
		shptr<class AlignmentGeometry> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Widget> /*var-nullable*/ AnimatedAlign::child() {
		auto m = ManagedCall("AnimatedAlign", "child");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ AnimatedAlign::heightFactor() {
		auto m = ManagedCall("AnimatedAlign", "heightFactor");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ AnimatedAlign::widthFactor() {
		auto m = ManagedCall("AnimatedAlign", "widthFactor");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	shptr<class AnimatedAlign> /*non-null*/ AnimatedAlign::ctorMain(_ctorMain p) {
		auto m = ManagedCall("AnimatedAlign", "AnimatedAlign");
		m.put("key", p.key);
		m.put("alignment", p.alignment, true);
		m.put("child", p.child);
		m.put("heightFactor", p.heightFactor);
		m.put("widthFactor", p.widthFactor);
		m.put("curve", p.curve, true);
		m.put("duration", p.duration, true);
		m.put("onEnd", p.onEnd);
		shptr<class AnimatedAlign> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Widget> /*var-nullable*/ AnimatedSlide::child() {
		auto m = ManagedCall("AnimatedSlide", "child");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	shptr<class Offset> /*var-non-null*/ AnimatedSlide::offset() {
		auto m = ManagedCall("AnimatedSlide", "offset");
		m.put("this", this);
		shptr<class Offset> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class AnimatedSlide> /*non-null*/ AnimatedSlide::ctorMain(_ctorMain p) {
		auto m = ManagedCall("AnimatedSlide", "AnimatedSlide");
		m.put("key", p.key);
		m.put("child", p.child);
		m.put("offset", p.offset, true);
		m.put("curve", p.curve, true);
		m.put("duration", p.duration, true);
		m.put("onEnd", p.onEnd);
		shptr<class AnimatedSlide> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Widget> /*var-nullable*/ AnimatedFractionallySizedBox::child() {
		auto m = ManagedCall("AnimatedFractionallySizedBox", "child");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ AnimatedFractionallySizedBox::heightFactor() {
		auto m = ManagedCall("AnimatedFractionallySizedBox", "heightFactor");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ AnimatedFractionallySizedBox::widthFactor() {
		auto m = ManagedCall("AnimatedFractionallySizedBox", "widthFactor");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	shptr<class AlignmentGeometry> /*var-non-null*/ AnimatedFractionallySizedBox::alignment() {
		auto m = ManagedCall("AnimatedFractionallySizedBox", "alignment");
		m.put("this", this);
		shptr<class AlignmentGeometry> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class AnimatedFractionallySizedBox> /*non-null*/ AnimatedFractionallySizedBox::ctorMain(_ctorMain p) {
		auto m = ManagedCall("AnimatedFractionallySizedBox", "AnimatedFractionallySizedBox");
		m.put("key", p.key);
		m.put("alignment", p.alignment, true);
		m.put("child", p.child);
		m.put("heightFactor", p.heightFactor);
		m.put("widthFactor", p.widthFactor);
		m.put("curve", p.curve, true);
		m.put("duration", p.duration, true);
		m.put("onEnd", p.onEnd);
		shptr<class AnimatedFractionallySizedBox> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Listenable> /*get-non-null*/ AnimatedBuilder::animation() {
		auto m = ManagedCall("AnimatedBuilder", "animation");
		m.put("this", this);
		shptr<class Listenable> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Listenable> /*get-non-null*/ AnimatedBuilder::listenable() {
		auto m = ManagedCall("AnimatedBuilder", "listenable");
		m.put("this", this);
		shptr<class Listenable> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class AnimatedBuilder> /*non-null*/ AnimatedBuilder::ctorMain(_ctorMain p) {
		auto m = ManagedCall("AnimatedBuilder", "AnimatedBuilder");
		m.put("key", p.key);
		m.put("animation", p.animation, true);
		m.put("builder", p.builder, true);
		m.put("child", p.child);
		shptr<class AnimatedBuilder> result;
		m.check(m.call(result, true));
		return result;
	}

	bool /*var-non-null*/ FadeTransition::alwaysIncludeSemantics() {
		auto m = ManagedCall("FadeTransition", "alwaysIncludeSemantics");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class FadeTransition> /*non-null*/ FadeTransition::ctorMain(_ctorMain p) {
		auto m = ManagedCall("FadeTransition", "FadeTransition");
		m.put("key", p.key);
		m.put("opacity", p.opacity, true);
		m.put("alwaysIncludeSemantics", p.alwaysIncludeSemantics);
		m.put("child", p.child);
		shptr<class FadeTransition> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Duration> /*var-non-null*/ Animate::defaultDuration() {
		auto m = ManagedCall("Animate", "defaultDuration");
		shptr<class Duration> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Curve> /*var-non-null*/ Animate::defaultCurve() {
		auto m = ManagedCall("Animate", "defaultCurve");
		shptr<class Curve> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Widget> /*var-non-null*/ Animate::child() {
		auto m = ManagedCall("Animate", "child");
		m.put("this", this);
		shptr<class Widget> result;
		m.check(m.call(result));
		return result;
	}

	bool /*var-non-null*/ Animate::autoPlay() {
		auto m = ManagedCall("Animate", "autoPlay");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Duration> /*var-non-null*/ Animate::delay() {
		auto m = ManagedCall("Animate", "delay");
		m.put("this", this);
		shptr<class Duration> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class AnimationController> /*var-nullable*/ Animate::controller() {
		auto m = ManagedCall("Animate", "controller");
		m.put("this", this);
		shptr<class AnimationController> result;
		m.call(result);
		return result;
	}

	shptr<class ObjBase> /*var-nullable*/ Animate::adapter() {
		auto m = ManagedCall("Animate", "adapter");
		m.put("this", this);
		shptr<class ObjBase> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ Animate::target() {
		auto m = ManagedCall("Animate", "target");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ Animate::value() {
		auto m = ManagedCall("Animate", "value");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	shptr<class Duration> /*get-non-null*/ Animate::duration() {
		auto m = ManagedCall("Animate", "duration");
		m.put("this", this);
		shptr<class Duration> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Animate> /*non-null*/ Animate::align(_align p) {
		auto m = ManagedCall("Animate", "align");
		m.put("this", this);
		m.put("delay", p.delay);
		m.put("duration", p.duration);
		m.put("curve", p.curve);
		m.put("begin", p.begin);
		m.put("end", p.end);
		shptr<class Animate> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Animate> /*non-null*/ Animate::blur(_blur p) {
		auto m = ManagedCall("Animate", "blur");
		m.put("this", this);
		m.put("delay", p.delay);
		m.put("duration", p.duration);
		m.put("curve", p.curve);
		m.put("begin", p.begin);
		m.put("end", p.end);
		shptr<class Animate> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Animate> /*non-null*/ Animate::blurX(_blurX p) {
		auto m = ManagedCall("Animate", "blurX");
		m.put("this", this);
		m.put("delay", p.delay);
		m.put("duration", p.duration);
		m.put("curve", p.curve);
		m.put("begin", p.begin);
		m.put("end", p.end);
		shptr<class Animate> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Animate> /*non-null*/ Animate::blurY(_blurY p) {
		auto m = ManagedCall("Animate", "blurY");
		m.put("this", this);
		m.put("delay", p.delay);
		m.put("duration", p.duration);
		m.put("curve", p.curve);
		m.put("begin", p.begin);
		m.put("end", p.end);
		shptr<class Animate> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Animate> /*non-null*/ Animate::blurXY(_blurXY p) {
		auto m = ManagedCall("Animate", "blurXY");
		m.put("this", this);
		m.put("delay", p.delay);
		m.put("duration", p.duration);
		m.put("curve", p.curve);
		m.put("begin", p.begin);
		m.put("end", p.end);
		shptr<class Animate> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Animate> /*non-null*/ Animate::boxShadow(_boxShadow p) {
		auto m = ManagedCall("Animate", "boxShadow");
		m.put("this", this);
		m.put("delay", p.delay);
		m.put("duration", p.duration);
		m.put("curve", p.curve);
		m.put("begin", p.begin);
		m.put("end", p.end);
		m.put("borderRadius", p.borderRadius);
		shptr<class Animate> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Animate> /*non-null*/ Animate::callback(_callback p) {
		auto m = ManagedCall("Animate", "callback");
		m.put("this", this);
		m.put("delay", p.delay);
		m.put("duration", p.duration);
		m.put("callback", p.callback, true);
		shptr<class Animate> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Animate> /*non-null*/ Animate::color(_color p) {
		auto m = ManagedCall("Animate", "color");
		m.put("this", this);
		m.put("delay", p.delay);
		m.put("duration", p.duration);
		m.put("curve", p.curve);
		m.put("begin", p.begin);
		m.put("end", p.end);
		m.put("blendMode", p.blendMode);
		shptr<class Animate> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Animate> /*non-null*/ Animate::crossfade(_crossfade p) {
		auto m = ManagedCall("Animate", "crossfade");
		m.put("this", this);
		m.put("delay", p.delay);
		m.put("duration", p.duration);
		m.put("curve", p.curve);
		m.put("builder", p.builder, true);
		m.put("alignment", p.alignment);
		shptr<class Animate> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Animate> /*non-null*/ Animate::custom(_custom p) {
		auto m = ManagedCall("Animate", "custom");
		m.put("this", this);
		m.put("builder", p.builder, true);
		m.put("delay", p.delay);
		m.put("duration", p.duration);
		m.put("curve", p.curve);
		m.put("begin", p.begin);
		m.put("end", p.end);
		shptr<class Animate> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Animate> /*non-null*/ Animate::effect(_effect p) {
		auto m = ManagedCall("Animate", "effect");
		m.put("this", this);
		m.put("delay", p.delay);
		m.put("duration", p.duration);
		m.put("curve", p.curve);
		m.put("begin", p.begin);
		m.put("end", p.end);
		shptr<class Animate> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Animate> /*non-null*/ Animate::elevation(_elevation p) {
		auto m = ManagedCall("Animate", "elevation");
		m.put("this", this);
		m.put("delay", p.delay);
		m.put("duration", p.duration);
		m.put("curve", p.curve);
		m.put("begin", p.begin);
		m.put("end", p.end);
		m.put("color", p.color);
		m.put("borderRadius", p.borderRadius);
		shptr<class Animate> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Animate> /*non-null*/ Animate::fade(_fade p) {
		auto m = ManagedCall("Animate", "fade");
		m.put("this", this);
		m.put("delay", p.delay);
		m.put("duration", p.duration);
		m.put("curve", p.curve);
		m.put("begin", p.begin);
		m.put("end", p.end);
		shptr<class Animate> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Animate> /*non-null*/ Animate::fadeIn(_fadeIn p) {
		auto m = ManagedCall("Animate", "fadeIn");
		m.put("this", this);
		m.put("delay", p.delay);
		m.put("duration", p.duration);
		m.put("curve", p.curve);
		m.put("begin", p.begin);
		shptr<class Animate> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Animate> /*non-null*/ Animate::fadeOut(_fadeOut p) {
		auto m = ManagedCall("Animate", "fadeOut");
		m.put("this", this);
		m.put("delay", p.delay);
		m.put("duration", p.duration);
		m.put("curve", p.curve);
		m.put("begin", p.begin);
		shptr<class Animate> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Animate> /*non-null*/ Animate::flip(_flip p) {
		auto m = ManagedCall("Animate", "flip");
		m.put("this", this);
		m.put("delay", p.delay);
		m.put("duration", p.duration);
		m.put("curve", p.curve);
		m.put("begin", p.begin);
		m.put("end", p.end);
		m.put("alignment", p.alignment);
		m.put("perspective", p.perspective);
		m.put("direction", p.direction);
		shptr<class Animate> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Animate> /*non-null*/ Animate::flipH(_flipH p) {
		auto m = ManagedCall("Animate", "flipH");
		m.put("this", this);
		m.put("delay", p.delay);
		m.put("duration", p.duration);
		m.put("curve", p.curve);
		m.put("begin", p.begin);
		m.put("end", p.end);
		m.put("alignment", p.alignment);
		m.put("perspective", p.perspective);
		shptr<class Animate> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Animate> /*non-null*/ Animate::flipV(_flipV p) {
		auto m = ManagedCall("Animate", "flipV");
		m.put("this", this);
		m.put("delay", p.delay);
		m.put("duration", p.duration);
		m.put("curve", p.curve);
		m.put("begin", p.begin);
		m.put("end", p.end);
		m.put("alignment", p.alignment);
		m.put("perspective", p.perspective);
		shptr<class Animate> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Animate> /*non-null*/ Animate::followPath(_followPath p) {
		auto m = ManagedCall("Animate", "followPath");
		m.put("this", this);
		m.put("delay", p.delay);
		m.put("duration", p.duration);
		m.put("curve", p.curve);
		m.put("begin", p.begin);
		m.put("end", p.end);
		m.put("path", p.path, true);
		m.put("rotate", p.rotate);
		m.put("rotationOffset", p.rotationOffset);
		m.put("transformHitTests", p.transformHitTests);
		shptr<class Animate> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Animate> /*non-null*/ Animate::listen(_listen p) {
		auto m = ManagedCall("Animate", "listen");
		m.put("this", this);
		m.put("delay", p.delay);
		m.put("duration", p.duration);
		m.put("curve", p.curve);
		m.put("begin", p.begin);
		m.put("end", p.end);
		m.put("callback", p.callback, true);
		m.put("clamp", p.clamp);
		shptr<class Animate> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Animate> /*non-null*/ Animate::move(_move p) {
		auto m = ManagedCall("Animate", "move");
		m.put("this", this);
		m.put("delay", p.delay);
		m.put("duration", p.duration);
		m.put("curve", p.curve);
		m.put("begin", p.begin);
		m.put("end", p.end);
		m.put("transformHitTests", p.transformHitTests);
		shptr<class Animate> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Animate> /*non-null*/ Animate::moveX(_moveX p) {
		auto m = ManagedCall("Animate", "moveX");
		m.put("this", this);
		m.put("delay", p.delay);
		m.put("duration", p.duration);
		m.put("curve", p.curve);
		m.put("begin", p.begin);
		m.put("end", p.end);
		m.put("transformHitTests", p.transformHitTests);
		shptr<class Animate> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Animate> /*non-null*/ Animate::moveY(_moveY p) {
		auto m = ManagedCall("Animate", "moveY");
		m.put("this", this);
		m.put("delay", p.delay);
		m.put("duration", p.duration);
		m.put("curve", p.curve);
		m.put("begin", p.begin);
		m.put("end", p.end);
		m.put("transformHitTests", p.transformHitTests);
		shptr<class Animate> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Animate> /*non-null*/ Animate::rotate(_rotate p) {
		auto m = ManagedCall("Animate", "rotate");
		m.put("this", this);
		m.put("delay", p.delay);
		m.put("duration", p.duration);
		m.put("curve", p.curve);
		m.put("begin", p.begin);
		m.put("end", p.end);
		m.put("alignment", p.alignment);
		m.put("transformHitTests", p.transformHitTests);
		shptr<class Animate> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Animate> /*non-null*/ Animate::saturate(_saturate p) {
		auto m = ManagedCall("Animate", "saturate");
		m.put("this", this);
		m.put("delay", p.delay);
		m.put("duration", p.duration);
		m.put("curve", p.curve);
		m.put("begin", p.begin);
		m.put("end", p.end);
		shptr<class Animate> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Animate> /*non-null*/ Animate::desaturate(_desaturate p) {
		auto m = ManagedCall("Animate", "desaturate");
		m.put("this", this);
		m.put("delay", p.delay);
		m.put("duration", p.duration);
		m.put("curve", p.curve);
		m.put("begin", p.begin);
		m.put("end", p.end);
		shptr<class Animate> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Animate> /*non-null*/ Animate::scale(_scale p) {
		auto m = ManagedCall("Animate", "scale");
		m.put("this", this);
		m.put("delay", p.delay);
		m.put("duration", p.duration);
		m.put("curve", p.curve);
		m.put("begin", p.begin);
		m.put("end", p.end);
		m.put("alignment", p.alignment);
		m.put("transformHitTests", p.transformHitTests);
		shptr<class Animate> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Animate> /*non-null*/ Animate::scaleX(_scaleX p) {
		auto m = ManagedCall("Animate", "scaleX");
		m.put("this", this);
		m.put("delay", p.delay);
		m.put("duration", p.duration);
		m.put("curve", p.curve);
		m.put("begin", p.begin);
		m.put("end", p.end);
		m.put("alignment", p.alignment);
		m.put("transformHitTests", p.transformHitTests);
		shptr<class Animate> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Animate> /*non-null*/ Animate::scaleY(_scaleY p) {
		auto m = ManagedCall("Animate", "scaleY");
		m.put("this", this);
		m.put("delay", p.delay);
		m.put("duration", p.duration);
		m.put("curve", p.curve);
		m.put("begin", p.begin);
		m.put("end", p.end);
		m.put("alignment", p.alignment);
		m.put("transformHitTests", p.transformHitTests);
		shptr<class Animate> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Animate> /*non-null*/ Animate::scaleXY(_scaleXY p) {
		auto m = ManagedCall("Animate", "scaleXY");
		m.put("this", this);
		m.put("delay", p.delay);
		m.put("duration", p.duration);
		m.put("curve", p.curve);
		m.put("begin", p.begin);
		m.put("end", p.end);
		m.put("alignment", p.alignment);
		m.put("transformHitTests", p.transformHitTests);
		shptr<class Animate> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Animate> /*non-null*/ Animate::shake(_shake p) {
		auto m = ManagedCall("Animate", "shake");
		m.put("this", this);
		m.put("delay", p.delay);
		m.put("duration", p.duration);
		m.put("curve", p.curve);
		m.put("hz", p.hz);
		m.put("offset", p.offset);
		m.put("rotation", p.rotation);
		shptr<class Animate> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Animate> /*non-null*/ Animate::shakeX(_shakeX p) {
		auto m = ManagedCall("Animate", "shakeX");
		m.put("this", this);
		m.put("delay", p.delay);
		m.put("duration", p.duration);
		m.put("curve", p.curve);
		m.put("hz", p.hz);
		m.put("amount", p.amount);
		shptr<class Animate> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Animate> /*non-null*/ Animate::shakeY(_shakeY p) {
		auto m = ManagedCall("Animate", "shakeY");
		m.put("this", this);
		m.put("delay", p.delay);
		m.put("duration", p.duration);
		m.put("curve", p.curve);
		m.put("hz", p.hz);
		m.put("amount", p.amount);
		shptr<class Animate> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Animate> /*non-null*/ Animate::shimmer(_shimmer p) {
		auto m = ManagedCall("Animate", "shimmer");
		m.put("this", this);
		m.put("delay", p.delay);
		m.put("duration", p.duration);
		m.put("curve", p.curve);
		m.put("color", p.color);
		m.put("colors", p.colors);
		m.put("stops", p.stops);
		m.put("size", p.size);
		m.put("angle", p.angle);
		m.put("blendMode", p.blendMode);
		m.put("padding", p.padding);
		shptr<class Animate> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Animate> /*non-null*/ Animate::slide(_slide p) {
		auto m = ManagedCall("Animate", "slide");
		m.put("this", this);
		m.put("delay", p.delay);
		m.put("duration", p.duration);
		m.put("curve", p.curve);
		m.put("begin", p.begin);
		m.put("end", p.end);
		shptr<class Animate> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Animate> /*non-null*/ Animate::slideX(_slideX p) {
		auto m = ManagedCall("Animate", "slideX");
		m.put("this", this);
		m.put("delay", p.delay);
		m.put("duration", p.duration);
		m.put("curve", p.curve);
		m.put("begin", p.begin);
		m.put("end", p.end);
		shptr<class Animate> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Animate> /*non-null*/ Animate::slideY(_slideY p) {
		auto m = ManagedCall("Animate", "slideY");
		m.put("this", this);
		m.put("delay", p.delay);
		m.put("duration", p.duration);
		m.put("curve", p.curve);
		m.put("begin", p.begin);
		m.put("end", p.end);
		shptr<class Animate> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Animate> /*non-null*/ Animate::swap(_swap p) {
		auto m = ManagedCall("Animate", "swap");
		m.put("this", this);
		m.put("delay", p.delay);
		m.put("duration", p.duration);
		m.put("builder", p.builder, true);
		shptr<class Animate> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Animate> /*non-null*/ Animate::then(_then p) {
		auto m = ManagedCall("Animate", "then");
		m.put("this", this);
		m.put("delay", p.delay);
		m.put("duration", p.duration);
		m.put("curve", p.curve);
		shptr<class Animate> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Animate> /*non-null*/ Animate::tint(_tint p) {
		auto m = ManagedCall("Animate", "tint");
		m.put("this", this);
		m.put("delay", p.delay);
		m.put("duration", p.duration);
		m.put("curve", p.curve);
		m.put("begin", p.begin);
		m.put("end", p.end);
		m.put("color", p.color);
		shptr<class Animate> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Animate> /*non-null*/ Animate::untint(_untint p) {
		auto m = ManagedCall("Animate", "untint");
		m.put("this", this);
		m.put("delay", p.delay);
		m.put("duration", p.duration);
		m.put("curve", p.curve);
		m.put("begin", p.begin);
		m.put("end", p.end);
		m.put("color", p.color);
		shptr<class Animate> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Animate> /*non-null*/ Animate::toggle(_toggle p) {
		auto m = ManagedCall("Animate", "toggle");
		m.put("this", this);
		m.put("delay", p.delay);
		m.put("duration", p.duration);
		m.put("builder", p.builder, true);
		shptr<class Animate> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Animate> /*non-null*/ Animate::visibility(_visibility p) {
		auto m = ManagedCall("Animate", "visibility");
		m.put("this", this);
		m.put("delay", p.delay);
		m.put("duration", p.duration);
		m.put("end", p.end);
		m.put("maintain", p.maintain);
		shptr<class Animate> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Animate> /*non-null*/ Animate::show(_show p) {
		auto m = ManagedCall("Animate", "show");
		m.put("this", this);
		m.put("delay", p.delay);
		m.put("duration", p.duration);
		m.put("maintain", p.maintain);
		shptr<class Animate> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Animate> /*non-null*/ Animate::hide(_hide p) {
		auto m = ManagedCall("Animate", "hide");
		m.put("this", this);
		m.put("delay", p.delay);
		m.put("duration", p.duration);
		m.put("maintain", p.maintain);
		shptr<class Animate> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Widget> /*var-nullable*/ MaterialApp::home() {
		auto m = ManagedCall("MaterialApp", "home");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	stdop<stdstr> /*var-nullable*/ MaterialApp::initialRoute() {
		auto m = ManagedCall("MaterialApp", "initialRoute");
		m.put("this", this);
		stdop<stdstr> result;
		m.call(result);
		return result;
	}

	shptr<class RouteInformationProvider> /*var-nullable*/ MaterialApp::routeInformationProvider() {
		auto m = ManagedCall("MaterialApp", "routeInformationProvider");
		m.put("this", this);
		shptr<class RouteInformationProvider> result;
		m.call(result);
		return result;
	}

	shptr<class BackButtonDispatcher> /*var-nullable*/ MaterialApp::backButtonDispatcher() {
		auto m = ManagedCall("MaterialApp", "backButtonDispatcher");
		m.put("this", this);
		shptr<class BackButtonDispatcher> result;
		m.call(result);
		return result;
	}

	stdstr /*var-non-null*/ MaterialApp::title() {
		auto m = ManagedCall("MaterialApp", "title");
		m.put("this", this);
		stdstr result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ThemeData> /*var-nullable*/ MaterialApp::theme() {
		auto m = ManagedCall("MaterialApp", "theme");
		m.put("this", this);
		shptr<class ThemeData> result;
		m.call(result);
		return result;
	}

	shptr<class ThemeData> /*var-nullable*/ MaterialApp::darkTheme() {
		auto m = ManagedCall("MaterialApp", "darkTheme");
		m.put("this", this);
		shptr<class ThemeData> result;
		m.call(result);
		return result;
	}

	shptr<class ThemeData> /*var-nullable*/ MaterialApp::highContrastTheme() {
		auto m = ManagedCall("MaterialApp", "highContrastTheme");
		m.put("this", this);
		shptr<class ThemeData> result;
		m.call(result);
		return result;
	}

	shptr<class ThemeData> /*var-nullable*/ MaterialApp::highContrastDarkTheme() {
		auto m = ManagedCall("MaterialApp", "highContrastDarkTheme");
		m.put("this", this);
		shptr<class ThemeData> result;
		m.call(result);
		return result;
	}

	stdop<ThemeMode> /*var-nullable*/ MaterialApp::themeMode() {
		auto m = ManagedCall("MaterialApp", "themeMode");
		m.put("this", this);
		stdop<ThemeMode> result;
		m.call(result);
		return result;
	}

	shptr<class Duration> /*var-non-null*/ MaterialApp::themeAnimationDuration() {
		auto m = ManagedCall("MaterialApp", "themeAnimationDuration");
		m.put("this", this);
		shptr<class Duration> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Curve> /*var-non-null*/ MaterialApp::themeAnimationCurve() {
		auto m = ManagedCall("MaterialApp", "themeAnimationCurve");
		m.put("this", this);
		shptr<class Curve> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*var-nullable*/ MaterialApp::color() {
		auto m = ManagedCall("MaterialApp", "color");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Locale> /*var-nullable*/ MaterialApp::locale() {
		auto m = ManagedCall("MaterialApp", "locale");
		m.put("this", this);
		shptr<class Locale> result;
		m.call(result);
		return result;
	}

	bool /*var-non-null*/ MaterialApp::showPerformanceOverlay() {
		auto m = ManagedCall("MaterialApp", "showPerformanceOverlay");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	bool /*var-non-null*/ MaterialApp::checkerboardRasterCacheImages() {
		auto m = ManagedCall("MaterialApp", "checkerboardRasterCacheImages");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	bool /*var-non-null*/ MaterialApp::checkerboardOffscreenLayers() {
		auto m = ManagedCall("MaterialApp", "checkerboardOffscreenLayers");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	bool /*var-non-null*/ MaterialApp::showSemanticsDebugger() {
		auto m = ManagedCall("MaterialApp", "showSemanticsDebugger");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	bool /*var-non-null*/ MaterialApp::debugShowCheckedModeBanner() {
		auto m = ManagedCall("MaterialApp", "debugShowCheckedModeBanner");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	stdop<stdstr> /*var-nullable*/ MaterialApp::restorationScopeId() {
		auto m = ManagedCall("MaterialApp", "restorationScopeId");
		m.put("this", this);
		stdop<stdstr> result;
		m.call(result);
		return result;
	}

	shptr<class ScrollBehavior> /*var-nullable*/ MaterialApp::scrollBehavior() {
		auto m = ManagedCall("MaterialApp", "scrollBehavior");
		m.put("this", this);
		shptr<class ScrollBehavior> result;
		m.call(result);
		return result;
	}

	bool /*var-non-null*/ MaterialApp::debugShowMaterialGrid() {
		auto m = ManagedCall("MaterialApp", "debugShowMaterialGrid");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	bool /*var-non-null*/ MaterialApp::useInheritedMediaQuery() {
		auto m = ManagedCall("MaterialApp", "useInheritedMediaQuery");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class HeroController> /*non-null*/ MaterialApp::createMaterialHeroController() {
		auto m = ManagedCall("MaterialApp", "createMaterialHeroController");
		shptr<class HeroController> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class MaterialApp> /*non-null*/ MaterialApp::ctorMain(_ctorMain p) {
		auto m = ManagedCall("MaterialApp", "MaterialApp");
		m.put("key", p.key);
		m.put("navigatorKey", p.navigatorKey);
		m.put("scaffoldMessengerKey", p.scaffoldMessengerKey);
		m.put("home", p.home);
//		m.put("routes", p.routes);
		m.put("initialRoute", p.initialRoute);
//		m.put("onGenerateRoute", p.onGenerateRoute);
//		m.put("onGenerateInitialRoutes", p.onGenerateInitialRoutes);
//		m.put("onUnknownRoute", p.onUnknownRoute);
		m.put("navigatorObservers", p.navigatorObservers);
//		m.put("builder", p.builder);
		m.put("title", p.title);
//		m.put("onGenerateTitle", p.onGenerateTitle);
		m.put("color", p.color);
		m.put("theme", p.theme);
		m.put("darkTheme", p.darkTheme);
		m.put("highContrastTheme", p.highContrastTheme);
		m.put("highContrastDarkTheme", p.highContrastDarkTheme);
		m.put("themeMode", p.themeMode);
		m.put("themeAnimationDuration", p.themeAnimationDuration, true);
		m.put("themeAnimationCurve", p.themeAnimationCurve, true);
//		m.put("locale", p.locale);
//		m.put("localizationsDelegates", p.localizationsDelegates);
//		m.put("localeListResolutionCallback", p.localeListResolutionCallback);
//		m.put("localeResolutionCallback", p.localeResolutionCallback);
//		m.put("supportedLocales", p.supportedLocales, true);
		m.put("debugShowMaterialGrid", p.debugShowMaterialGrid);
		m.put("showPerformanceOverlay", p.showPerformanceOverlay);
		m.put("checkerboardRasterCacheImages", p.checkerboardRasterCacheImages);
		m.put("checkerboardOffscreenLayers", p.checkerboardOffscreenLayers);
		m.put("showSemanticsDebugger", p.showSemanticsDebugger);
		m.put("debugShowCheckedModeBanner", p.debugShowCheckedModeBanner);
//		m.put("shortcuts", p.shortcuts);
//		m.put("actions", p.actions);
		m.put("restorationScopeId", p.restorationScopeId);
		m.put("scrollBehavior", p.scrollBehavior);
//		m.put("useInheritedMediaQuery", p.useInheritedMediaQuery);
		shptr<class MaterialApp> result;
		m.check(m.call(result, true));
		return result;
	}

	bool /*var-non-null*/ Scaffold::extendBody() {
		auto m = ManagedCall("Scaffold", "extendBody");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	bool /*var-non-null*/ Scaffold::extendBodyBehindAppBar() {
		auto m = ManagedCall("Scaffold", "extendBodyBehindAppBar");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class PreferredSizeWidget> /*var-nullable*/ Scaffold::appBar() {
		auto m = ManagedCall("Scaffold", "appBar");
		m.put("this", this);
		shptr<class PreferredSizeWidget> result;
		m.call(result);
		return result;
	}

	shptr<class Widget> /*var-nullable*/ Scaffold::body() {
		auto m = ManagedCall("Scaffold", "body");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	shptr<class Widget> /*var-nullable*/ Scaffold::floatingActionButton() {
		auto m = ManagedCall("Scaffold", "floatingActionButton");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	shptr<class FloatingActionButtonLocation> /*var-nullable*/ Scaffold::floatingActionButtonLocation() {
		auto m = ManagedCall("Scaffold", "floatingActionButtonLocation");
		m.put("this", this);
		shptr<class FloatingActionButtonLocation> result;
		m.call(result);
		return result;
	}

	shptr<class FloatingActionButtonAnimator> /*var-nullable*/ Scaffold::floatingActionButtonAnimator() {
		auto m = ManagedCall("Scaffold", "floatingActionButtonAnimator");
		m.put("this", this);
		shptr<class FloatingActionButtonAnimator> result;
		m.call(result);
		return result;
	}

	shptr<class AlignmentDirectional> /*var-non-null*/ Scaffold::persistentFooterAlignment() {
		auto m = ManagedCall("Scaffold", "persistentFooterAlignment");
		m.put("this", this);
		shptr<class AlignmentDirectional> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Widget> /*var-nullable*/ Scaffold::drawer() {
		auto m = ManagedCall("Scaffold", "drawer");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	shptr<class Widget> /*var-nullable*/ Scaffold::endDrawer() {
		auto m = ManagedCall("Scaffold", "endDrawer");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ Scaffold::drawerScrimColor() {
		auto m = ManagedCall("Scaffold", "drawerScrimColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ Scaffold::backgroundColor() {
		auto m = ManagedCall("Scaffold", "backgroundColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Widget> /*var-nullable*/ Scaffold::bottomNavigationBar() {
		auto m = ManagedCall("Scaffold", "bottomNavigationBar");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	shptr<class Widget> /*var-nullable*/ Scaffold::bottomSheet() {
		auto m = ManagedCall("Scaffold", "bottomSheet");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	stdop<bool> /*var-nullable*/ Scaffold::resizeToAvoidBottomInset() {
		auto m = ManagedCall("Scaffold", "resizeToAvoidBottomInset");
		m.put("this", this);
		stdop<bool> result;
		m.call(result);
		return result;
	}

	bool /*var-non-null*/ Scaffold::primary() {
		auto m = ManagedCall("Scaffold", "primary");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	DragStartBehavior /*var-non-null*/ Scaffold::drawerDragStartBehavior() {
		auto m = ManagedCall("Scaffold", "drawerDragStartBehavior");
		m.put("this", this);
		DragStartBehavior result;
		m.check(m.call(result));
		return result;
	}

	stdop<double> /*var-nullable*/ Scaffold::drawerEdgeDragWidth() {
		auto m = ManagedCall("Scaffold", "drawerEdgeDragWidth");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	bool /*var-non-null*/ Scaffold::drawerEnableOpenDragGesture() {
		auto m = ManagedCall("Scaffold", "drawerEnableOpenDragGesture");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	bool /*var-non-null*/ Scaffold::endDrawerEnableOpenDragGesture() {
		auto m = ManagedCall("Scaffold", "endDrawerEnableOpenDragGesture");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	stdop<stdstr> /*var-nullable*/ Scaffold::restorationId() {
		auto m = ManagedCall("Scaffold", "restorationId");
		m.put("this", this);
		stdop<stdstr> result;
		m.call(result);
		return result;
	}

	shptr<class ScaffoldState> /*non-null*/ Scaffold::of(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("Scaffold", "of");
		m.put("context", context, true);
		shptr<class ScaffoldState> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ScaffoldState> /*nullable*/ Scaffold::maybeOf(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("Scaffold", "maybeOf");
		m.put("context", context, true);
		shptr<class ScaffoldState> result;
		m.call(result);
		return result;
	}

	bool /*non-null*/ Scaffold::hasDrawer(/*non-null*/ shptr<class BuildContext> context, _hasDrawer p) {
		auto m = ManagedCall("Scaffold", "hasDrawer");
		m.put("context", context, true);
		m.put("registerForUpdates", p.registerForUpdates);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Scaffold> /*non-null*/ Scaffold::ctorMain(_ctorMain p) {
		auto m = ManagedCall("Scaffold", "Scaffold");
		m.put("key", p.key);
		m.put("appBar", p.appBar);
		m.put("body", p.body);
		m.put("floatingActionButton", p.floatingActionButton);
		m.put("floatingActionButtonLocation", p.floatingActionButtonLocation);
		m.put("floatingActionButtonAnimator", p.floatingActionButtonAnimator);
		m.put("persistentFooterButtons", p.persistentFooterButtons);
		m.put("persistentFooterAlignment", p.persistentFooterAlignment, true);
		m.put("drawer", p.drawer);
		m.put("onDrawerChanged", p.onDrawerChanged);
		m.put("endDrawer", p.endDrawer);
		m.put("onEndDrawerChanged", p.onEndDrawerChanged);
		m.put("bottomNavigationBar", p.bottomNavigationBar);
		m.put("bottomSheet", p.bottomSheet);
		m.put("backgroundColor", p.backgroundColor);
		m.put("resizeToAvoidBottomInset", p.resizeToAvoidBottomInset);
		m.put("primary", p.primary);
		m.put("drawerDragStartBehavior", p.drawerDragStartBehavior);
		m.put("extendBody", p.extendBody);
		m.put("extendBodyBehindAppBar", p.extendBodyBehindAppBar);
		m.put("drawerScrimColor", p.drawerScrimColor);
		m.put("drawerEdgeDragWidth", p.drawerEdgeDragWidth);
		m.put("drawerEnableOpenDragGesture", p.drawerEnableOpenDragGesture);
		m.put("endDrawerEnableOpenDragGesture", p.endDrawerEnableOpenDragGesture);
		m.put("restorationId", p.restorationId);
		shptr<class Scaffold> result;
		m.check(m.call(result, true));
		return result;
	}

	bool /*get-non-null*/ ScaffoldState::hasAppBar() {
		auto m = ManagedCall("ScaffoldState", "hasAppBar");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	bool /*get-non-null*/ ScaffoldState::hasDrawer() {
		auto m = ManagedCall("ScaffoldState", "hasDrawer");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	bool /*get-non-null*/ ScaffoldState::hasEndDrawer() {
		auto m = ManagedCall("ScaffoldState", "hasEndDrawer");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	bool /*get-non-null*/ ScaffoldState::hasFloatingActionButton() {
		auto m = ManagedCall("ScaffoldState", "hasFloatingActionButton");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	stdop<double> /*get-nullable*/ ScaffoldState::appBarMaxHeight() {
		auto m = ManagedCall("ScaffoldState", "appBarMaxHeight");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	bool /*get-non-null*/ ScaffoldState::isDrawerOpen() {
		auto m = ManagedCall("ScaffoldState", "isDrawerOpen");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	bool /*get-non-null*/ ScaffoldState::isEndDrawerOpen() {
		auto m = ManagedCall("ScaffoldState", "isEndDrawerOpen");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	void ScaffoldState::openDrawer() {
		auto m = ManagedCall("ScaffoldState", "openDrawer");
		m.put("this", this);
		m.call();
	}

	void ScaffoldState::openEndDrawer() {
		auto m = ManagedCall("ScaffoldState", "openEndDrawer");
		m.put("this", this);
		m.call();
	}

	void ScaffoldState::closeDrawer() {
		auto m = ManagedCall("ScaffoldState", "closeDrawer");
		m.put("this", this);
		m.call();
	}

	void ScaffoldState::closeEndDrawer() {
		auto m = ManagedCall("ScaffoldState", "closeEndDrawer");
		m.put("this", this);
		m.call();
	}

	shptr<class Widget> /*var-nullable*/ AppBar::leading() {
		auto m = ManagedCall("AppBar", "leading");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	bool /*var-non-null*/ AppBar::automaticallyImplyLeading() {
		auto m = ManagedCall("AppBar", "automaticallyImplyLeading");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Widget> /*var-nullable*/ AppBar::title() {
		auto m = ManagedCall("AppBar", "title");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	shptr<class Widget> /*var-nullable*/ AppBar::flexibleSpace() {
		auto m = ManagedCall("AppBar", "flexibleSpace");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	shptr<class PreferredSizeWidget> /*var-nullable*/ AppBar::bottom() {
		auto m = ManagedCall("AppBar", "bottom");
		m.put("this", this);
		shptr<class PreferredSizeWidget> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ AppBar::elevation() {
		auto m = ManagedCall("AppBar", "elevation");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ AppBar::scrolledUnderElevation() {
		auto m = ManagedCall("AppBar", "scrolledUnderElevation");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ AppBar::shadowColor() {
		auto m = ManagedCall("AppBar", "shadowColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ AppBar::surfaceTintColor() {
		auto m = ManagedCall("AppBar", "surfaceTintColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class ShapeBorder> /*var-nullable*/ AppBar::shape() {
		auto m = ManagedCall("AppBar", "shape");
		m.put("this", this);
		shptr<class ShapeBorder> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ AppBar::backgroundColor() {
		auto m = ManagedCall("AppBar", "backgroundColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ AppBar::foregroundColor() {
		auto m = ManagedCall("AppBar", "foregroundColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class IconThemeData> /*var-nullable*/ AppBar::iconTheme() {
		auto m = ManagedCall("AppBar", "iconTheme");
		m.put("this", this);
		shptr<class IconThemeData> result;
		m.call(result);
		return result;
	}

	shptr<class IconThemeData> /*var-nullable*/ AppBar::actionsIconTheme() {
		auto m = ManagedCall("AppBar", "actionsIconTheme");
		m.put("this", this);
		shptr<class IconThemeData> result;
		m.call(result);
		return result;
	}

	bool /*var-non-null*/ AppBar::primary() {
		auto m = ManagedCall("AppBar", "primary");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	stdop<bool> /*var-nullable*/ AppBar::centerTitle() {
		auto m = ManagedCall("AppBar", "centerTitle");
		m.put("this", this);
		stdop<bool> result;
		m.call(result);
		return result;
	}

	bool /*var-non-null*/ AppBar::excludeHeaderSemantics() {
		auto m = ManagedCall("AppBar", "excludeHeaderSemantics");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	stdop<double> /*var-nullable*/ AppBar::titleSpacing() {
		auto m = ManagedCall("AppBar", "titleSpacing");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	double /*var-non-null*/ AppBar::toolbarOpacity() {
		auto m = ManagedCall("AppBar", "toolbarOpacity");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	double /*var-non-null*/ AppBar::bottomOpacity() {
		auto m = ManagedCall("AppBar", "bottomOpacity");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Size> /*var-non-null*/ AppBar::preferredSize() {
		auto m = ManagedCall("AppBar", "preferredSize");
		m.put("this", this);
		shptr<class Size> result;
		m.check(m.call(result));
		return result;
	}

	stdop<double> /*var-nullable*/ AppBar::toolbarHeight() {
		auto m = ManagedCall("AppBar", "toolbarHeight");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ AppBar::leadingWidth() {
		auto m = ManagedCall("AppBar", "leadingWidth");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	shptr<class TextStyle> /*var-nullable*/ AppBar::toolbarTextStyle() {
		auto m = ManagedCall("AppBar", "toolbarTextStyle");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.call(result);
		return result;
	}

	shptr<class TextStyle> /*var-nullable*/ AppBar::titleTextStyle() {
		auto m = ManagedCall("AppBar", "titleTextStyle");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.call(result);
		return result;
	}

	shptr<class SystemUiOverlayStyle> /*var-nullable*/ AppBar::systemOverlayStyle() {
		auto m = ManagedCall("AppBar", "systemOverlayStyle");
		m.put("this", this);
		shptr<class SystemUiOverlayStyle> result;
		m.call(result);
		return result;
	}

	bool /*var-non-null*/ AppBar::forceMaterialTransparency() {
		auto m = ManagedCall("AppBar", "forceMaterialTransparency");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	stdop<Clip> /*var-nullable*/ AppBar::clipBehavior() {
		auto m = ManagedCall("AppBar", "clipBehavior");
		m.put("this", this);
		stdop<Clip> result;
		m.call(result);
		return result;
	}

	double /*non-null*/ AppBar::preferredHeightFor(/*non-null*/ shptr<class BuildContext> context, /*non-null*/ shptr<class Size> preferredSize) {
		auto m = ManagedCall("AppBar", "preferredHeightFor");
		m.put("context", context, true);
		m.put("preferredSize", preferredSize, true);
		double result;
		m.check(m.call(result));
		return result;
	}

	shptr<class AppBar> /*non-null*/ AppBar::ctorMain(_ctorMain p) {
		auto m = ManagedCall("AppBar", "AppBar");
		m.put("key", p.key);
		m.put("leading", p.leading);
		m.put("automaticallyImplyLeading", p.automaticallyImplyLeading);
		m.put("title", p.title);
		m.put("actions", p.actions);
		m.put("flexibleSpace", p.flexibleSpace);
		m.put("bottom", p.bottom);
		m.put("elevation", p.elevation);
		m.put("scrolledUnderElevation", p.scrolledUnderElevation);
//		m.put("notificationPredicate", p.notificationPredicate, true);
		m.put("shadowColor", p.shadowColor);
		m.put("surfaceTintColor", p.surfaceTintColor);
		m.put("shape", p.shape);
		m.put("backgroundColor", p.backgroundColor);
		m.put("foregroundColor", p.foregroundColor);
		m.put("iconTheme", p.iconTheme);
		m.put("actionsIconTheme", p.actionsIconTheme);
		m.put("primary", p.primary);
		m.put("centerTitle", p.centerTitle);
		m.put("excludeHeaderSemantics", p.excludeHeaderSemantics);
		m.put("titleSpacing", p.titleSpacing);
		m.put("toolbarOpacity", p.toolbarOpacity);
		m.put("bottomOpacity", p.bottomOpacity);
		m.put("toolbarHeight", p.toolbarHeight);
		m.put("leadingWidth", p.leadingWidth);
		m.put("toolbarTextStyle", p.toolbarTextStyle);
		m.put("titleTextStyle", p.titleTextStyle);
		m.put("systemOverlayStyle", p.systemOverlayStyle);
		m.put("forceMaterialTransparency", p.forceMaterialTransparency);
		m.put("clipBehavior", p.clipBehavior);
		shptr<class AppBar> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Widget> /*var-nullable*/ SliverAppBar::leading() {
		auto m = ManagedCall("SliverAppBar", "leading");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	bool /*var-non-null*/ SliverAppBar::automaticallyImplyLeading() {
		auto m = ManagedCall("SliverAppBar", "automaticallyImplyLeading");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Widget> /*var-nullable*/ SliverAppBar::title() {
		auto m = ManagedCall("SliverAppBar", "title");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	shptr<class Widget> /*var-nullable*/ SliverAppBar::flexibleSpace() {
		auto m = ManagedCall("SliverAppBar", "flexibleSpace");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	shptr<class PreferredSizeWidget> /*var-nullable*/ SliverAppBar::bottom() {
		auto m = ManagedCall("SliverAppBar", "bottom");
		m.put("this", this);
		shptr<class PreferredSizeWidget> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ SliverAppBar::elevation() {
		auto m = ManagedCall("SliverAppBar", "elevation");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ SliverAppBar::scrolledUnderElevation() {
		auto m = ManagedCall("SliverAppBar", "scrolledUnderElevation");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ SliverAppBar::shadowColor() {
		auto m = ManagedCall("SliverAppBar", "shadowColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ SliverAppBar::surfaceTintColor() {
		auto m = ManagedCall("SliverAppBar", "surfaceTintColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	bool /*var-non-null*/ SliverAppBar::forceElevated() {
		auto m = ManagedCall("SliverAppBar", "forceElevated");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*var-nullable*/ SliverAppBar::backgroundColor() {
		auto m = ManagedCall("SliverAppBar", "backgroundColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ SliverAppBar::foregroundColor() {
		auto m = ManagedCall("SliverAppBar", "foregroundColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class IconThemeData> /*var-nullable*/ SliverAppBar::iconTheme() {
		auto m = ManagedCall("SliverAppBar", "iconTheme");
		m.put("this", this);
		shptr<class IconThemeData> result;
		m.call(result);
		return result;
	}

	shptr<class IconThemeData> /*var-nullable*/ SliverAppBar::actionsIconTheme() {
		auto m = ManagedCall("SliverAppBar", "actionsIconTheme");
		m.put("this", this);
		shptr<class IconThemeData> result;
		m.call(result);
		return result;
	}

	bool /*var-non-null*/ SliverAppBar::primary() {
		auto m = ManagedCall("SliverAppBar", "primary");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	stdop<bool> /*var-nullable*/ SliverAppBar::centerTitle() {
		auto m = ManagedCall("SliverAppBar", "centerTitle");
		m.put("this", this);
		stdop<bool> result;
		m.call(result);
		return result;
	}

	bool /*var-non-null*/ SliverAppBar::excludeHeaderSemantics() {
		auto m = ManagedCall("SliverAppBar", "excludeHeaderSemantics");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	stdop<double> /*var-nullable*/ SliverAppBar::titleSpacing() {
		auto m = ManagedCall("SliverAppBar", "titleSpacing");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ SliverAppBar::collapsedHeight() {
		auto m = ManagedCall("SliverAppBar", "collapsedHeight");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ SliverAppBar::expandedHeight() {
		auto m = ManagedCall("SliverAppBar", "expandedHeight");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	bool /*var-non-null*/ SliverAppBar::floating() {
		auto m = ManagedCall("SliverAppBar", "floating");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	bool /*var-non-null*/ SliverAppBar::pinned() {
		auto m = ManagedCall("SliverAppBar", "pinned");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ShapeBorder> /*var-nullable*/ SliverAppBar::shape() {
		auto m = ManagedCall("SliverAppBar", "shape");
		m.put("this", this);
		shptr<class ShapeBorder> result;
		m.call(result);
		return result;
	}

	bool /*var-non-null*/ SliverAppBar::snap() {
		auto m = ManagedCall("SliverAppBar", "snap");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	bool /*var-non-null*/ SliverAppBar::stretch() {
		auto m = ManagedCall("SliverAppBar", "stretch");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	double /*var-non-null*/ SliverAppBar::stretchTriggerOffset() {
		auto m = ManagedCall("SliverAppBar", "stretchTriggerOffset");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	double /*var-non-null*/ SliverAppBar::toolbarHeight() {
		auto m = ManagedCall("SliverAppBar", "toolbarHeight");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	stdop<double> /*var-nullable*/ SliverAppBar::leadingWidth() {
		auto m = ManagedCall("SliverAppBar", "leadingWidth");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	shptr<class TextStyle> /*var-nullable*/ SliverAppBar::toolbarTextStyle() {
		auto m = ManagedCall("SliverAppBar", "toolbarTextStyle");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.call(result);
		return result;
	}

	shptr<class TextStyle> /*var-nullable*/ SliverAppBar::titleTextStyle() {
		auto m = ManagedCall("SliverAppBar", "titleTextStyle");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.call(result);
		return result;
	}

	shptr<class SystemUiOverlayStyle> /*var-nullable*/ SliverAppBar::systemOverlayStyle() {
		auto m = ManagedCall("SliverAppBar", "systemOverlayStyle");
		m.put("this", this);
		shptr<class SystemUiOverlayStyle> result;
		m.call(result);
		return result;
	}

	bool /*var-non-null*/ SliverAppBar::forceMaterialTransparency() {
		auto m = ManagedCall("SliverAppBar", "forceMaterialTransparency");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	stdop<Clip> /*var-nullable*/ SliverAppBar::clipBehavior() {
		auto m = ManagedCall("SliverAppBar", "clipBehavior");
		m.put("this", this);
		stdop<Clip> result;
		m.call(result);
		return result;
	}

	shptr<class SliverAppBar> /*non-null*/ SliverAppBar::ctorMain(_ctorMain p) {
		auto m = ManagedCall("SliverAppBar", "SliverAppBar");
		m.put("key", p.key);
		m.put("leading", p.leading);
		m.put("automaticallyImplyLeading", p.automaticallyImplyLeading);
		m.put("title", p.title);
		m.put("actions", p.actions);
		m.put("flexibleSpace", p.flexibleSpace);
		m.put("bottom", p.bottom);
		m.put("elevation", p.elevation);
		m.put("scrolledUnderElevation", p.scrolledUnderElevation);
		m.put("shadowColor", p.shadowColor);
		m.put("surfaceTintColor", p.surfaceTintColor);
		m.put("forceElevated", p.forceElevated);
		m.put("backgroundColor", p.backgroundColor);
		m.put("foregroundColor", p.foregroundColor);
		m.put("iconTheme", p.iconTheme);
		m.put("actionsIconTheme", p.actionsIconTheme);
		m.put("primary", p.primary);
		m.put("centerTitle", p.centerTitle);
		m.put("excludeHeaderSemantics", p.excludeHeaderSemantics);
		m.put("titleSpacing", p.titleSpacing);
		m.put("collapsedHeight", p.collapsedHeight);
		m.put("expandedHeight", p.expandedHeight);
		m.put("floating", p.floating);
		m.put("pinned", p.pinned);
		m.put("snap", p.snap);
		m.put("stretch", p.stretch);
		m.put("stretchTriggerOffset", p.stretchTriggerOffset);
//		m.put("onStretchTrigger", p.onStretchTrigger);
		m.put("shape", p.shape);
		m.put("toolbarHeight", p.toolbarHeight);
		m.put("leadingWidth", p.leadingWidth);
		m.put("toolbarTextStyle", p.toolbarTextStyle);
		m.put("titleTextStyle", p.titleTextStyle);
		m.put("systemOverlayStyle", p.systemOverlayStyle);
		m.put("forceMaterialTransparency", p.forceMaterialTransparency);
		m.put("clipBehavior", p.clipBehavior);
		shptr<class SliverAppBar> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class SliverAppBar> /*non-null*/ SliverAppBar::medium(_medium p) {
		auto m = ManagedCall("SliverAppBar", "medium");
		m.put("key", p.key);
		m.put("leading", p.leading);
		m.put("automaticallyImplyLeading", p.automaticallyImplyLeading);
		m.put("title", p.title);
		m.put("actions", p.actions);
		m.put("flexibleSpace", p.flexibleSpace);
		m.put("bottom", p.bottom);
		m.put("elevation", p.elevation);
		m.put("scrolledUnderElevation", p.scrolledUnderElevation);
		m.put("shadowColor", p.shadowColor);
		m.put("surfaceTintColor", p.surfaceTintColor);
		m.put("forceElevated", p.forceElevated);
		m.put("backgroundColor", p.backgroundColor);
		m.put("foregroundColor", p.foregroundColor);
		m.put("iconTheme", p.iconTheme);
		m.put("actionsIconTheme", p.actionsIconTheme);
		m.put("primary", p.primary);
		m.put("centerTitle", p.centerTitle);
		m.put("excludeHeaderSemantics", p.excludeHeaderSemantics);
		m.put("titleSpacing", p.titleSpacing);
		m.put("collapsedHeight", p.collapsedHeight);
		m.put("expandedHeight", p.expandedHeight);
		m.put("floating", p.floating);
		m.put("pinned", p.pinned);
		m.put("snap", p.snap);
		m.put("stretch", p.stretch);
		m.put("stretchTriggerOffset", p.stretchTriggerOffset);
//		m.put("onStretchTrigger", p.onStretchTrigger);
		m.put("shape", p.shape);
		m.put("toolbarHeight", p.toolbarHeight);
		m.put("leadingWidth", p.leadingWidth);
		m.put("toolbarTextStyle", p.toolbarTextStyle);
		m.put("titleTextStyle", p.titleTextStyle);
		m.put("systemOverlayStyle", p.systemOverlayStyle);
		m.put("forceMaterialTransparency", p.forceMaterialTransparency);
		m.put("clipBehavior", p.clipBehavior);
		shptr<class SliverAppBar> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class SliverAppBar> /*non-null*/ SliverAppBar::large(_large p) {
		auto m = ManagedCall("SliverAppBar", "large");
		m.put("key", p.key);
		m.put("leading", p.leading);
		m.put("automaticallyImplyLeading", p.automaticallyImplyLeading);
		m.put("title", p.title);
		m.put("actions", p.actions);
		m.put("flexibleSpace", p.flexibleSpace);
		m.put("bottom", p.bottom);
		m.put("elevation", p.elevation);
		m.put("scrolledUnderElevation", p.scrolledUnderElevation);
		m.put("shadowColor", p.shadowColor);
		m.put("surfaceTintColor", p.surfaceTintColor);
		m.put("forceElevated", p.forceElevated);
		m.put("backgroundColor", p.backgroundColor);
		m.put("foregroundColor", p.foregroundColor);
		m.put("iconTheme", p.iconTheme);
		m.put("actionsIconTheme", p.actionsIconTheme);
		m.put("primary", p.primary);
		m.put("centerTitle", p.centerTitle);
		m.put("excludeHeaderSemantics", p.excludeHeaderSemantics);
		m.put("titleSpacing", p.titleSpacing);
		m.put("collapsedHeight", p.collapsedHeight);
		m.put("expandedHeight", p.expandedHeight);
		m.put("floating", p.floating);
		m.put("pinned", p.pinned);
		m.put("snap", p.snap);
		m.put("stretch", p.stretch);
		m.put("stretchTriggerOffset", p.stretchTriggerOffset);
//		m.put("onStretchTrigger", p.onStretchTrigger);
		m.put("shape", p.shape);
		m.put("toolbarHeight", p.toolbarHeight);
		m.put("leadingWidth", p.leadingWidth);
		m.put("toolbarTextStyle", p.toolbarTextStyle);
		m.put("titleTextStyle", p.titleTextStyle);
		m.put("systemOverlayStyle", p.systemOverlayStyle);
		m.put("forceMaterialTransparency", p.forceMaterialTransparency);
		m.put("clipBehavior", p.clipBehavior);
		shptr<class SliverAppBar> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Widget> /*var-nullable*/ FlexibleSpaceBar::title() {
		auto m = ManagedCall("FlexibleSpaceBar", "title");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	shptr<class Widget> /*var-nullable*/ FlexibleSpaceBar::background() {
		auto m = ManagedCall("FlexibleSpaceBar", "background");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	stdop<bool> /*var-nullable*/ FlexibleSpaceBar::centerTitle() {
		auto m = ManagedCall("FlexibleSpaceBar", "centerTitle");
		m.put("this", this);
		stdop<bool> result;
		m.call(result);
		return result;
	}

	CollapseMode /*var-non-null*/ FlexibleSpaceBar::collapseMode() {
		auto m = ManagedCall("FlexibleSpaceBar", "collapseMode");
		m.put("this", this);
		CollapseMode result;
		m.check(m.call(result));
		return result;
	}

	shptr<class EdgeInsetsGeometry> /*var-nullable*/ FlexibleSpaceBar::titlePadding() {
		auto m = ManagedCall("FlexibleSpaceBar", "titlePadding");
		m.put("this", this);
		shptr<class EdgeInsetsGeometry> result;
		m.call(result);
		return result;
	}

	double /*var-non-null*/ FlexibleSpaceBar::expandedTitleScale() {
		auto m = ManagedCall("FlexibleSpaceBar", "expandedTitleScale");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Widget> /*non-null*/ FlexibleSpaceBar::createSettings(_createSettings p) {
		auto m = ManagedCall("FlexibleSpaceBar", "createSettings");
		m.put("toolbarOpacity", p.toolbarOpacity);
		m.put("minExtent", p.minExtent);
		m.put("maxExtent", p.maxExtent);
		m.put("isScrolledUnder", p.isScrolledUnder);
		m.put("currentExtent", p.currentExtent);
		m.put("child", p.child, true);
		shptr<class Widget> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class FlexibleSpaceBar> /*non-null*/ FlexibleSpaceBar::ctorMain(_ctorMain p) {
		auto m = ManagedCall("FlexibleSpaceBar", "FlexibleSpaceBar");
		m.put("key", p.key);
		m.put("title", p.title);
		m.put("background", p.background);
		m.put("centerTitle", p.centerTitle);
		m.put("titlePadding", p.titlePadding);
		m.put("collapseMode", p.collapseMode);
		m.put("stretchModes", p.stretchModes);
		m.put("expandedTitleScale", p.expandedTitleScale);
		shptr<class FlexibleSpaceBar> result;
		m.check(m.call(result, true));
		return result;
	}

	double /*var-non-null*/ FlexibleSpaceBarSettings::toolbarOpacity() {
		auto m = ManagedCall("FlexibleSpaceBarSettings", "toolbarOpacity");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	double /*var-non-null*/ FlexibleSpaceBarSettings::minExtent() {
		auto m = ManagedCall("FlexibleSpaceBarSettings", "minExtent");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	double /*var-non-null*/ FlexibleSpaceBarSettings::maxExtent() {
		auto m = ManagedCall("FlexibleSpaceBarSettings", "maxExtent");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	double /*var-non-null*/ FlexibleSpaceBarSettings::currentExtent() {
		auto m = ManagedCall("FlexibleSpaceBarSettings", "currentExtent");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	stdop<bool> /*var-nullable*/ FlexibleSpaceBarSettings::isScrolledUnder() {
		auto m = ManagedCall("FlexibleSpaceBarSettings", "isScrolledUnder");
		m.put("this", this);
		stdop<bool> result;
		m.call(result);
		return result;
	}

	bool /*non-null*/ FlexibleSpaceBarSettings::updateShouldNotify(/*non-null*/ shptr<class FlexibleSpaceBarSettings> oldWidget) {
		auto m = ManagedCall("FlexibleSpaceBarSettings", "updateShouldNotify");
		m.put("this", this);
		m.put("oldWidget", oldWidget, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class FlexibleSpaceBarSettings> /*non-null*/ FlexibleSpaceBarSettings::ctorMain(_ctorMain p) {
		auto m = ManagedCall("FlexibleSpaceBarSettings", "FlexibleSpaceBarSettings");
		m.put("key", p.key);
		m.put("toolbarOpacity", p.toolbarOpacity);
		m.put("minExtent", p.minExtent);
		m.put("maxExtent", p.maxExtent);
		m.put("currentExtent", p.currentExtent);
		m.put("child", p.child, true);
		m.put("isScrolledUnder", p.isScrolledUnder);
		shptr<class FlexibleSpaceBarSettings> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Widget> /*var-non-null*/ BottomNavigationBarItem::icon() {
		auto m = ManagedCall("BottomNavigationBarItem", "icon");
		m.put("this", this);
		shptr<class Widget> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Widget> /*var-non-null*/ BottomNavigationBarItem::activeIcon() {
		auto m = ManagedCall("BottomNavigationBarItem", "activeIcon");
		m.put("this", this);
		shptr<class Widget> result;
		m.check(m.call(result));
		return result;
	}

	stdop<stdstr> /*var-nullable*/ BottomNavigationBarItem::label() {
		auto m = ManagedCall("BottomNavigationBarItem", "label");
		m.put("this", this);
		stdop<stdstr> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ BottomNavigationBarItem::backgroundColor() {
		auto m = ManagedCall("BottomNavigationBarItem", "backgroundColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	stdop<stdstr> /*var-nullable*/ BottomNavigationBarItem::tooltip() {
		auto m = ManagedCall("BottomNavigationBarItem", "tooltip");
		m.put("this", this);
		stdop<stdstr> result;
		m.call(result);
		return result;
	}

	shptr<class BottomNavigationBarItem> /*non-null*/ BottomNavigationBarItem::ctorMain(_ctorMain p) {
		auto m = ManagedCall("BottomNavigationBarItem", "BottomNavigationBarItem");
		m.put("icon", p.icon, true);
		m.put("label", p.label);
		m.put("activeIcon", p.activeIcon);
		m.put("backgroundColor", p.backgroundColor);
		m.put("tooltip", p.tooltip);
		shptr<class BottomNavigationBarItem> result;
		m.check(m.call(result, true));
		return result;
	}

	int64 /*var-non-null*/ BottomNavigationBar::currentIndex() {
		auto m = ManagedCall("BottomNavigationBar", "currentIndex");
		m.put("this", this);
		int64 result;
		m.check(m.call(result));
		return result;
	}

	stdop<double> /*var-nullable*/ BottomNavigationBar::elevation() {
		auto m = ManagedCall("BottomNavigationBar", "elevation");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	stdop<BottomNavigationBarType> /*var-nullable*/ BottomNavigationBar::type() {
		auto m = ManagedCall("BottomNavigationBar", "type");
		m.put("this", this);
		stdop<BottomNavigationBarType> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ BottomNavigationBar::backgroundColor() {
		auto m = ManagedCall("BottomNavigationBar", "backgroundColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	double /*var-non-null*/ BottomNavigationBar::iconSize() {
		auto m = ManagedCall("BottomNavigationBar", "iconSize");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*var-nullable*/ BottomNavigationBar::selectedItemColor() {
		auto m = ManagedCall("BottomNavigationBar", "selectedItemColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ BottomNavigationBar::unselectedItemColor() {
		auto m = ManagedCall("BottomNavigationBar", "unselectedItemColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class IconThemeData> /*var-nullable*/ BottomNavigationBar::selectedIconTheme() {
		auto m = ManagedCall("BottomNavigationBar", "selectedIconTheme");
		m.put("this", this);
		shptr<class IconThemeData> result;
		m.call(result);
		return result;
	}

	shptr<class IconThemeData> /*var-nullable*/ BottomNavigationBar::unselectedIconTheme() {
		auto m = ManagedCall("BottomNavigationBar", "unselectedIconTheme");
		m.put("this", this);
		shptr<class IconThemeData> result;
		m.call(result);
		return result;
	}

	shptr<class TextStyle> /*var-nullable*/ BottomNavigationBar::selectedLabelStyle() {
		auto m = ManagedCall("BottomNavigationBar", "selectedLabelStyle");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.call(result);
		return result;
	}

	shptr<class TextStyle> /*var-nullable*/ BottomNavigationBar::unselectedLabelStyle() {
		auto m = ManagedCall("BottomNavigationBar", "unselectedLabelStyle");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.call(result);
		return result;
	}

	double /*var-non-null*/ BottomNavigationBar::selectedFontSize() {
		auto m = ManagedCall("BottomNavigationBar", "selectedFontSize");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	double /*var-non-null*/ BottomNavigationBar::unselectedFontSize() {
		auto m = ManagedCall("BottomNavigationBar", "unselectedFontSize");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	stdop<bool> /*var-nullable*/ BottomNavigationBar::showUnselectedLabels() {
		auto m = ManagedCall("BottomNavigationBar", "showUnselectedLabels");
		m.put("this", this);
		stdop<bool> result;
		m.call(result);
		return result;
	}

	stdop<bool> /*var-nullable*/ BottomNavigationBar::showSelectedLabels() {
		auto m = ManagedCall("BottomNavigationBar", "showSelectedLabels");
		m.put("this", this);
		stdop<bool> result;
		m.call(result);
		return result;
	}

	shptr<class MouseCursor> /*var-nullable*/ BottomNavigationBar::mouseCursor() {
		auto m = ManagedCall("BottomNavigationBar", "mouseCursor");
		m.put("this", this);
		shptr<class MouseCursor> result;
		m.call(result);
		return result;
	}

	stdop<bool> /*var-nullable*/ BottomNavigationBar::enableFeedback() {
		auto m = ManagedCall("BottomNavigationBar", "enableFeedback");
		m.put("this", this);
		stdop<bool> result;
		m.call(result);
		return result;
	}

	stdop<BottomNavigationBarLandscapeLayout> /*var-nullable*/ BottomNavigationBar::landscapeLayout() {
		auto m = ManagedCall("BottomNavigationBar", "landscapeLayout");
		m.put("this", this);
		stdop<BottomNavigationBarLandscapeLayout> result;
		m.call(result);
		return result;
	}

	bool /*var-non-null*/ BottomNavigationBar::useLegacyColorScheme() {
		auto m = ManagedCall("BottomNavigationBar", "useLegacyColorScheme");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*get-nullable*/ BottomNavigationBar::fixedColor() {
		auto m = ManagedCall("BottomNavigationBar", "fixedColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class BottomNavigationBar> /*non-null*/ BottomNavigationBar::ctorMain(_ctorMain p) {
		auto m = ManagedCall("BottomNavigationBar", "BottomNavigationBar");
		m.put("key", p.key);
		m.put("items", p.items);
		m.put("onTap", p.onTap);
		m.put("currentIndex", p.currentIndex);
		m.put("elevation", p.elevation);
		m.put("type", p.type);
		m.put("fixedColor", p.fixedColor);
		m.put("backgroundColor", p.backgroundColor);
		m.put("iconSize", p.iconSize);
		m.put("selectedItemColor", p.selectedItemColor);
		m.put("unselectedItemColor", p.unselectedItemColor);
		m.put("selectedIconTheme", p.selectedIconTheme);
		m.put("unselectedIconTheme", p.unselectedIconTheme);
		m.put("selectedFontSize", p.selectedFontSize);
		m.put("unselectedFontSize", p.unselectedFontSize);
		m.put("selectedLabelStyle", p.selectedLabelStyle);
		m.put("unselectedLabelStyle", p.unselectedLabelStyle);
		m.put("showSelectedLabels", p.showSelectedLabels);
		m.put("showUnselectedLabels", p.showUnselectedLabels);
		m.put("mouseCursor", p.mouseCursor);
		m.put("enableFeedback", p.enableFeedback);
		m.put("landscapeLayout", p.landscapeLayout);
		m.put("useLegacyColorScheme", p.useLegacyColorScheme);
		shptr<class BottomNavigationBar> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class InputBorder> /*var-non-null*/ InputBorder::none() {
		auto m = ManagedCall("InputBorder", "none");
		shptr<class InputBorder> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class BorderSide> /*var-non-null*/ InputBorder::borderSide() {
		auto m = ManagedCall("InputBorder", "borderSide");
		m.put("this", this);
		shptr<class BorderSide> result;
		m.check(m.call(result));
		return result;
	}

	bool /*get-non-null*/ InputBorder::isOutline() {
		auto m = ManagedCall("InputBorder", "isOutline");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class InputBorder> /*non-null*/ InputBorder::copyWith(_copyWith p) {
		auto m = ManagedCall("InputBorder", "copyWith");
		m.put("this", this);
		m.put("borderSide", p.borderSide);
		shptr<class InputBorder> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class BorderRadius> /*var-non-null*/ UnderlineInputBorder::borderRadius() {
		auto m = ManagedCall("UnderlineInputBorder", "borderRadius");
		m.put("this", this);
		shptr<class BorderRadius> result;
		m.check(m.call(result));
		return result;
	}

	bool /*get-non-null*/ UnderlineInputBorder::isOutline() {
		auto m = ManagedCall("UnderlineInputBorder", "isOutline");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class EdgeInsetsGeometry> /*get-non-null*/ UnderlineInputBorder::dimensions() {
		auto m = ManagedCall("UnderlineInputBorder", "dimensions");
		m.put("this", this);
		shptr<class EdgeInsetsGeometry> result;
		m.check(m.call(result));
		return result;
	}

	bool /*get-non-null*/ UnderlineInputBorder::preferPaintInterior() {
		auto m = ManagedCall("UnderlineInputBorder", "preferPaintInterior");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class UnderlineInputBorder> /*non-null*/ UnderlineInputBorder::copyWith(_copyWith p) {
		auto m = ManagedCall("UnderlineInputBorder", "copyWith");
		m.put("this", this);
		m.put("borderSide", p.borderSide);
		m.put("borderRadius", p.borderRadius);
		shptr<class UnderlineInputBorder> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class UnderlineInputBorder> /*non-null*/ UnderlineInputBorder::scale(/*non-null*/ double t) {
		auto m = ManagedCall("UnderlineInputBorder", "scale");
		m.put("this", this);
		m.put("t", t);
		shptr<class UnderlineInputBorder> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Path> /*non-null*/ UnderlineInputBorder::getInnerPath(/*non-null*/ shptr<class Rect> rect, _getInnerPath p) {
		auto m = ManagedCall("UnderlineInputBorder", "getInnerPath");
		m.put("this", this);
		m.put("rect", rect, true);
		m.put("textDirection", p.textDirection);
		shptr<class Path> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Path> /*non-null*/ UnderlineInputBorder::getOuterPath(/*non-null*/ shptr<class Rect> rect, _getOuterPath p) {
		auto m = ManagedCall("UnderlineInputBorder", "getOuterPath");
		m.put("this", this);
		m.put("rect", rect, true);
		m.put("textDirection", p.textDirection);
		shptr<class Path> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ShapeBorder> /*nullable*/ UnderlineInputBorder::lerpFrom(/*nullable*/ shptr<class ShapeBorder> a, /*non-null*/ double t) {
		auto m = ManagedCall("UnderlineInputBorder", "lerpFrom");
		m.put("this", this);
		m.put("a", a);
		m.put("t", t);
		shptr<class ShapeBorder> result;
		m.call(result);
		return result;
	}

	shptr<class ShapeBorder> /*nullable*/ UnderlineInputBorder::lerpTo(/*nullable*/ shptr<class ShapeBorder> b, /*non-null*/ double t) {
		auto m = ManagedCall("UnderlineInputBorder", "lerpTo");
		m.put("this", this);
		m.put("b", b);
		m.put("t", t);
		shptr<class ShapeBorder> result;
		m.call(result);
		return result;
	}

	bool /*non-null*/ UnderlineInputBorder::equals(/*non-null*/ shptr<class ObjBase> other) {
		auto m = ManagedCall("UnderlineInputBorder", "==");
		m.put("this", this);
		m.put("other", other, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class UnderlineInputBorder> /*non-null*/ UnderlineInputBorder::ctorMain(_ctorMain p) {
		auto m = ManagedCall("UnderlineInputBorder", "UnderlineInputBorder");
		m.put("borderSide", p.borderSide, true);
		m.put("borderRadius", p.borderRadius, true);
		shptr<class UnderlineInputBorder> result;
		m.check(m.call(result, true));
		return result;
	}

	double /*var-non-null*/ OutlineInputBorder::gapPadding() {
		auto m = ManagedCall("OutlineInputBorder", "gapPadding");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	shptr<class BorderRadius> /*var-non-null*/ OutlineInputBorder::borderRadius() {
		auto m = ManagedCall("OutlineInputBorder", "borderRadius");
		m.put("this", this);
		shptr<class BorderRadius> result;
		m.check(m.call(result));
		return result;
	}

	bool /*get-non-null*/ OutlineInputBorder::isOutline() {
		auto m = ManagedCall("OutlineInputBorder", "isOutline");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class EdgeInsetsGeometry> /*get-non-null*/ OutlineInputBorder::dimensions() {
		auto m = ManagedCall("OutlineInputBorder", "dimensions");
		m.put("this", this);
		shptr<class EdgeInsetsGeometry> result;
		m.check(m.call(result));
		return result;
	}

	bool /*get-non-null*/ OutlineInputBorder::preferPaintInterior() {
		auto m = ManagedCall("OutlineInputBorder", "preferPaintInterior");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class OutlineInputBorder> /*non-null*/ OutlineInputBorder::copyWith(_copyWith p) {
		auto m = ManagedCall("OutlineInputBorder", "copyWith");
		m.put("this", this);
		m.put("borderSide", p.borderSide);
		m.put("borderRadius", p.borderRadius);
		m.put("gapPadding", p.gapPadding);
		shptr<class OutlineInputBorder> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class OutlineInputBorder> /*non-null*/ OutlineInputBorder::scale(/*non-null*/ double t) {
		auto m = ManagedCall("OutlineInputBorder", "scale");
		m.put("this", this);
		m.put("t", t);
		shptr<class OutlineInputBorder> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ShapeBorder> /*nullable*/ OutlineInputBorder::lerpFrom(/*nullable*/ shptr<class ShapeBorder> a, /*non-null*/ double t) {
		auto m = ManagedCall("OutlineInputBorder", "lerpFrom");
		m.put("this", this);
		m.put("a", a);
		m.put("t", t);
		shptr<class ShapeBorder> result;
		m.call(result);
		return result;
	}

	shptr<class ShapeBorder> /*nullable*/ OutlineInputBorder::lerpTo(/*nullable*/ shptr<class ShapeBorder> b, /*non-null*/ double t) {
		auto m = ManagedCall("OutlineInputBorder", "lerpTo");
		m.put("this", this);
		m.put("b", b);
		m.put("t", t);
		shptr<class ShapeBorder> result;
		m.call(result);
		return result;
	}

	shptr<class Path> /*non-null*/ OutlineInputBorder::getInnerPath(/*non-null*/ shptr<class Rect> rect, _getInnerPath p) {
		auto m = ManagedCall("OutlineInputBorder", "getInnerPath");
		m.put("this", this);
		m.put("rect", rect, true);
		m.put("textDirection", p.textDirection);
		shptr<class Path> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Path> /*non-null*/ OutlineInputBorder::getOuterPath(/*non-null*/ shptr<class Rect> rect, _getOuterPath p) {
		auto m = ManagedCall("OutlineInputBorder", "getOuterPath");
		m.put("this", this);
		m.put("rect", rect, true);
		m.put("textDirection", p.textDirection);
		shptr<class Path> result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ OutlineInputBorder::equals(/*non-null*/ shptr<class ObjBase> other) {
		auto m = ManagedCall("OutlineInputBorder", "==");
		m.put("this", this);
		m.put("other", other, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class OutlineInputBorder> /*non-null*/ OutlineInputBorder::ctorMain(_ctorMain p) {
		auto m = ManagedCall("OutlineInputBorder", "OutlineInputBorder");
		m.put("borderSide", p.borderSide, true);
		m.put("borderRadius", p.borderRadius, true);
		m.put("gapPadding", p.gapPadding);
		shptr<class OutlineInputBorder> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Widget> /*var-nullable*/ InputDecoration::icon() {
		auto m = ManagedCall("InputDecoration", "icon");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ InputDecoration::iconColor() {
		auto m = ManagedCall("InputDecoration", "iconColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Widget> /*var-nullable*/ InputDecoration::label() {
		auto m = ManagedCall("InputDecoration", "label");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	stdop<stdstr> /*var-nullable*/ InputDecoration::labelText() {
		auto m = ManagedCall("InputDecoration", "labelText");
		m.put("this", this);
		stdop<stdstr> result;
		m.call(result);
		return result;
	}

	shptr<class TextStyle> /*var-nullable*/ InputDecoration::labelStyle() {
		auto m = ManagedCall("InputDecoration", "labelStyle");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.call(result);
		return result;
	}

	shptr<class TextStyle> /*var-nullable*/ InputDecoration::floatingLabelStyle() {
		auto m = ManagedCall("InputDecoration", "floatingLabelStyle");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.call(result);
		return result;
	}

	stdop<stdstr> /*var-nullable*/ InputDecoration::helperText() {
		auto m = ManagedCall("InputDecoration", "helperText");
		m.put("this", this);
		stdop<stdstr> result;
		m.call(result);
		return result;
	}

	shptr<class TextStyle> /*var-nullable*/ InputDecoration::helperStyle() {
		auto m = ManagedCall("InputDecoration", "helperStyle");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.call(result);
		return result;
	}

	stdop<int64> /*var-nullable*/ InputDecoration::helperMaxLines() {
		auto m = ManagedCall("InputDecoration", "helperMaxLines");
		m.put("this", this);
		stdop<int64> result;
		m.call(result);
		return result;
	}

	stdop<stdstr> /*var-nullable*/ InputDecoration::hintText() {
		auto m = ManagedCall("InputDecoration", "hintText");
		m.put("this", this);
		stdop<stdstr> result;
		m.call(result);
		return result;
	}

	shptr<class TextStyle> /*var-nullable*/ InputDecoration::hintStyle() {
		auto m = ManagedCall("InputDecoration", "hintStyle");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.call(result);
		return result;
	}

	stdop<TextDirection> /*var-nullable*/ InputDecoration::hintTextDirection() {
		auto m = ManagedCall("InputDecoration", "hintTextDirection");
		m.put("this", this);
		stdop<TextDirection> result;
		m.call(result);
		return result;
	}

	stdop<int64> /*var-nullable*/ InputDecoration::hintMaxLines() {
		auto m = ManagedCall("InputDecoration", "hintMaxLines");
		m.put("this", this);
		stdop<int64> result;
		m.call(result);
		return result;
	}

	shptr<class Widget> /*var-nullable*/ InputDecoration::error() {
		auto m = ManagedCall("InputDecoration", "error");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	stdop<stdstr> /*var-nullable*/ InputDecoration::errorText() {
		auto m = ManagedCall("InputDecoration", "errorText");
		m.put("this", this);
		stdop<stdstr> result;
		m.call(result);
		return result;
	}

	shptr<class TextStyle> /*var-nullable*/ InputDecoration::errorStyle() {
		auto m = ManagedCall("InputDecoration", "errorStyle");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.call(result);
		return result;
	}

	stdop<int64> /*var-nullable*/ InputDecoration::errorMaxLines() {
		auto m = ManagedCall("InputDecoration", "errorMaxLines");
		m.put("this", this);
		stdop<int64> result;
		m.call(result);
		return result;
	}

	stdop<FloatingLabelBehavior> /*var-nullable*/ InputDecoration::floatingLabelBehavior() {
		auto m = ManagedCall("InputDecoration", "floatingLabelBehavior");
		m.put("this", this);
		stdop<FloatingLabelBehavior> result;
		m.call(result);
		return result;
	}

	shptr<class FloatingLabelAlignment> /*var-nullable*/ InputDecoration::floatingLabelAlignment() {
		auto m = ManagedCall("InputDecoration", "floatingLabelAlignment");
		m.put("this", this);
		shptr<class FloatingLabelAlignment> result;
		m.call(result);
		return result;
	}

	stdop<bool> /*var-nullable*/ InputDecoration::isDense() {
		auto m = ManagedCall("InputDecoration", "isDense");
		m.put("this", this);
		stdop<bool> result;
		m.call(result);
		return result;
	}

	shptr<class EdgeInsetsGeometry> /*var-nullable*/ InputDecoration::contentPadding() {
		auto m = ManagedCall("InputDecoration", "contentPadding");
		m.put("this", this);
		shptr<class EdgeInsetsGeometry> result;
		m.call(result);
		return result;
	}

	bool /*var-non-null*/ InputDecoration::isCollapsed() {
		auto m = ManagedCall("InputDecoration", "isCollapsed");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Widget> /*var-nullable*/ InputDecoration::prefixIcon() {
		auto m = ManagedCall("InputDecoration", "prefixIcon");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	shptr<class BoxConstraints> /*var-nullable*/ InputDecoration::prefixIconConstraints() {
		auto m = ManagedCall("InputDecoration", "prefixIconConstraints");
		m.put("this", this);
		shptr<class BoxConstraints> result;
		m.call(result);
		return result;
	}

	shptr<class Widget> /*var-nullable*/ InputDecoration::prefix() {
		auto m = ManagedCall("InputDecoration", "prefix");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	stdop<stdstr> /*var-nullable*/ InputDecoration::prefixText() {
		auto m = ManagedCall("InputDecoration", "prefixText");
		m.put("this", this);
		stdop<stdstr> result;
		m.call(result);
		return result;
	}

	shptr<class TextStyle> /*var-nullable*/ InputDecoration::prefixStyle() {
		auto m = ManagedCall("InputDecoration", "prefixStyle");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ InputDecoration::prefixIconColor() {
		auto m = ManagedCall("InputDecoration", "prefixIconColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Widget> /*var-nullable*/ InputDecoration::suffixIcon() {
		auto m = ManagedCall("InputDecoration", "suffixIcon");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	shptr<class Widget> /*var-nullable*/ InputDecoration::suffix() {
		auto m = ManagedCall("InputDecoration", "suffix");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	stdop<stdstr> /*var-nullable*/ InputDecoration::suffixText() {
		auto m = ManagedCall("InputDecoration", "suffixText");
		m.put("this", this);
		stdop<stdstr> result;
		m.call(result);
		return result;
	}

	shptr<class TextStyle> /*var-nullable*/ InputDecoration::suffixStyle() {
		auto m = ManagedCall("InputDecoration", "suffixStyle");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ InputDecoration::suffixIconColor() {
		auto m = ManagedCall("InputDecoration", "suffixIconColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class BoxConstraints> /*var-nullable*/ InputDecoration::suffixIconConstraints() {
		auto m = ManagedCall("InputDecoration", "suffixIconConstraints");
		m.put("this", this);
		shptr<class BoxConstraints> result;
		m.call(result);
		return result;
	}

	stdop<stdstr> /*var-nullable*/ InputDecoration::counterText() {
		auto m = ManagedCall("InputDecoration", "counterText");
		m.put("this", this);
		stdop<stdstr> result;
		m.call(result);
		return result;
	}

	shptr<class Widget> /*var-nullable*/ InputDecoration::counter() {
		auto m = ManagedCall("InputDecoration", "counter");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	shptr<class TextStyle> /*var-nullable*/ InputDecoration::counterStyle() {
		auto m = ManagedCall("InputDecoration", "counterStyle");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.call(result);
		return result;
	}

	stdop<bool> /*var-nullable*/ InputDecoration::filled() {
		auto m = ManagedCall("InputDecoration", "filled");
		m.put("this", this);
		stdop<bool> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ InputDecoration::fillColor() {
		auto m = ManagedCall("InputDecoration", "fillColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ InputDecoration::focusColor() {
		auto m = ManagedCall("InputDecoration", "focusColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ InputDecoration::hoverColor() {
		auto m = ManagedCall("InputDecoration", "hoverColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class InputBorder> /*var-nullable*/ InputDecoration::errorBorder() {
		auto m = ManagedCall("InputDecoration", "errorBorder");
		m.put("this", this);
		shptr<class InputBorder> result;
		m.call(result);
		return result;
	}

	shptr<class InputBorder> /*var-nullable*/ InputDecoration::focusedBorder() {
		auto m = ManagedCall("InputDecoration", "focusedBorder");
		m.put("this", this);
		shptr<class InputBorder> result;
		m.call(result);
		return result;
	}

	shptr<class InputBorder> /*var-nullable*/ InputDecoration::focusedErrorBorder() {
		auto m = ManagedCall("InputDecoration", "focusedErrorBorder");
		m.put("this", this);
		shptr<class InputBorder> result;
		m.call(result);
		return result;
	}

	shptr<class InputBorder> /*var-nullable*/ InputDecoration::disabledBorder() {
		auto m = ManagedCall("InputDecoration", "disabledBorder");
		m.put("this", this);
		shptr<class InputBorder> result;
		m.call(result);
		return result;
	}

	shptr<class InputBorder> /*var-nullable*/ InputDecoration::enabledBorder() {
		auto m = ManagedCall("InputDecoration", "enabledBorder");
		m.put("this", this);
		shptr<class InputBorder> result;
		m.call(result);
		return result;
	}

	shptr<class InputBorder> /*var-nullable*/ InputDecoration::border() {
		auto m = ManagedCall("InputDecoration", "border");
		m.put("this", this);
		shptr<class InputBorder> result;
		m.call(result);
		return result;
	}

	bool /*var-non-null*/ InputDecoration::enabled() {
		auto m = ManagedCall("InputDecoration", "enabled");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	stdop<stdstr> /*var-nullable*/ InputDecoration::semanticCounterText() {
		auto m = ManagedCall("InputDecoration", "semanticCounterText");
		m.put("this", this);
		stdop<stdstr> result;
		m.call(result);
		return result;
	}

	stdop<bool> /*var-nullable*/ InputDecoration::alignLabelWithHint() {
		auto m = ManagedCall("InputDecoration", "alignLabelWithHint");
		m.put("this", this);
		stdop<bool> result;
		m.call(result);
		return result;
	}

	shptr<class BoxConstraints> /*var-nullable*/ InputDecoration::constraints() {
		auto m = ManagedCall("InputDecoration", "constraints");
		m.put("this", this);
		shptr<class BoxConstraints> result;
		m.call(result);
		return result;
	}

	shptr<class InputDecoration> /*non-null*/ InputDecoration::copyWith(_copyWith p) {
		auto m = ManagedCall("InputDecoration", "copyWith");
		m.put("this", this);
		m.put("icon", p.icon);
		m.put("iconColor", p.iconColor);
		m.put("label", p.label);
		m.put("labelText", p.labelText);
		m.put("labelStyle", p.labelStyle);
		m.put("floatingLabelStyle", p.floatingLabelStyle);
		m.put("helperText", p.helperText);
		m.put("helperStyle", p.helperStyle);
		m.put("helperMaxLines", p.helperMaxLines);
		m.put("hintText", p.hintText);
		m.put("hintStyle", p.hintStyle);
		m.put("hintTextDirection", p.hintTextDirection);
		m.put("hintMaxLines", p.hintMaxLines);
		m.put("error", p.error);
		m.put("errorText", p.errorText);
		m.put("errorStyle", p.errorStyle);
		m.put("errorMaxLines", p.errorMaxLines);
		m.put("floatingLabelBehavior", p.floatingLabelBehavior);
		m.put("floatingLabelAlignment", p.floatingLabelAlignment);
		m.put("isCollapsed", p.isCollapsed);
		m.put("isDense", p.isDense);
		m.put("contentPadding", p.contentPadding);
		m.put("prefixIcon", p.prefixIcon);
		m.put("prefix", p.prefix);
		m.put("prefixText", p.prefixText);
		m.put("prefixIconConstraints", p.prefixIconConstraints);
		m.put("prefixStyle", p.prefixStyle);
		m.put("prefixIconColor", p.prefixIconColor);
		m.put("suffixIcon", p.suffixIcon);
		m.put("suffix", p.suffix);
		m.put("suffixText", p.suffixText);
		m.put("suffixStyle", p.suffixStyle);
		m.put("suffixIconColor", p.suffixIconColor);
		m.put("suffixIconConstraints", p.suffixIconConstraints);
		m.put("counter", p.counter);
		m.put("counterText", p.counterText);
		m.put("counterStyle", p.counterStyle);
		m.put("filled", p.filled);
		m.put("fillColor", p.fillColor);
		m.put("focusColor", p.focusColor);
		m.put("hoverColor", p.hoverColor);
		m.put("errorBorder", p.errorBorder);
		m.put("focusedBorder", p.focusedBorder);
		m.put("focusedErrorBorder", p.focusedErrorBorder);
		m.put("disabledBorder", p.disabledBorder);
		m.put("enabledBorder", p.enabledBorder);
		m.put("border", p.border);
		m.put("enabled", p.enabled);
		m.put("semanticCounterText", p.semanticCounterText);
		m.put("alignLabelWithHint", p.alignLabelWithHint);
		m.put("constraints", p.constraints);
		shptr<class InputDecoration> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class InputDecoration> /*non-null*/ InputDecoration::applyDefaults(/*non-null*/ shptr<class InputDecorationTheme> theme) {
		auto m = ManagedCall("InputDecoration", "applyDefaults");
		m.put("this", this);
		m.put("theme", theme, true);
		shptr<class InputDecoration> result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ InputDecoration::equals(/*non-null*/ shptr<class ObjBase> other) {
		auto m = ManagedCall("InputDecoration", "==");
		m.put("this", this);
		m.put("other", other, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class InputDecoration> /*non-null*/ InputDecoration::ctorMain(_ctorMain p) {
		auto m = ManagedCall("InputDecoration", "InputDecoration");
		m.put("icon", p.icon);
		m.put("iconColor", p.iconColor);
		m.put("label", p.label);
		m.put("labelText", p.labelText);
		m.put("labelStyle", p.labelStyle);
		m.put("floatingLabelStyle", p.floatingLabelStyle);
		m.put("helperText", p.helperText);
		m.put("helperStyle", p.helperStyle);
		m.put("helperMaxLines", p.helperMaxLines);
		m.put("hintText", p.hintText);
		m.put("hintStyle", p.hintStyle);
		m.put("hintTextDirection", p.hintTextDirection);
		m.put("hintMaxLines", p.hintMaxLines);
		m.put("error", p.error);
		m.put("errorText", p.errorText);
		m.put("errorStyle", p.errorStyle);
		m.put("errorMaxLines", p.errorMaxLines);
		m.put("floatingLabelBehavior", p.floatingLabelBehavior);
		m.put("floatingLabelAlignment", p.floatingLabelAlignment);
		m.put("isCollapsed", p.isCollapsed);
		m.put("isDense", p.isDense);
		m.put("contentPadding", p.contentPadding);
		m.put("prefixIcon", p.prefixIcon);
		m.put("prefixIconConstraints", p.prefixIconConstraints);
		m.put("prefix", p.prefix);
		m.put("prefixText", p.prefixText);
		m.put("prefixStyle", p.prefixStyle);
		m.put("prefixIconColor", p.prefixIconColor);
		m.put("suffixIcon", p.suffixIcon);
		m.put("suffix", p.suffix);
		m.put("suffixText", p.suffixText);
		m.put("suffixStyle", p.suffixStyle);
		m.put("suffixIconColor", p.suffixIconColor);
		m.put("suffixIconConstraints", p.suffixIconConstraints);
		m.put("counter", p.counter);
		m.put("counterText", p.counterText);
		m.put("counterStyle", p.counterStyle);
		m.put("filled", p.filled);
		m.put("fillColor", p.fillColor);
		m.put("focusColor", p.focusColor);
		m.put("hoverColor", p.hoverColor);
		m.put("errorBorder", p.errorBorder);
		m.put("focusedBorder", p.focusedBorder);
		m.put("focusedErrorBorder", p.focusedErrorBorder);
		m.put("disabledBorder", p.disabledBorder);
		m.put("enabledBorder", p.enabledBorder);
		m.put("border", p.border);
		m.put("enabled", p.enabled);
		m.put("semanticCounterText", p.semanticCounterText);
		m.put("alignLabelWithHint", p.alignLabelWithHint);
		m.put("constraints", p.constraints);
		shptr<class InputDecoration> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class InputDecoration> /*non-null*/ InputDecoration::collapsed(_collapsed p) {
		auto m = ManagedCall("InputDecoration", "collapsed");
		m.put("hintText", p.hintText);
		m.put("floatingLabelBehavior", p.floatingLabelBehavior);
		m.put("floatingLabelAlignment", p.floatingLabelAlignment);
		m.put("hintStyle", p.hintStyle);
		m.put("hintTextDirection", p.hintTextDirection);
		m.put("filled", p.filled);
		m.put("fillColor", p.fillColor);
		m.put("focusColor", p.focusColor);
		m.put("hoverColor", p.hoverColor);
		m.put("border", p.border);
		m.put("enabled", p.enabled);
		shptr<class InputDecoration> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class TextMagnifierConfiguration> /*var-nullable*/ TextField::magnifierConfiguration() {
		auto m = ManagedCall("TextField", "magnifierConfiguration");
		m.put("this", this);
		shptr<class TextMagnifierConfiguration> result;
		m.call(result);
		return result;
	}

	shptr<class TextEditingController> /*var-nullable*/ TextField::controller() {
		auto m = ManagedCall("TextField", "controller");
		m.put("this", this);
		shptr<class TextEditingController> result;
		m.call(result);
		return result;
	}

	shptr<class FocusNode> /*var-nullable*/ TextField::focusNode() {
		auto m = ManagedCall("TextField", "focusNode");
		m.put("this", this);
		shptr<class FocusNode> result;
		m.call(result);
		return result;
	}

	shptr<class InputDecoration> /*var-nullable*/ TextField::decoration() {
		auto m = ManagedCall("TextField", "decoration");
		m.put("this", this);
		shptr<class InputDecoration> result;
		m.call(result);
		return result;
	}

	shptr<class TextInputType> /*var-non-null*/ TextField::keyboardType() {
		auto m = ManagedCall("TextField", "keyboardType");
		m.put("this", this);
		shptr<class TextInputType> result;
		m.check(m.call(result));
		return result;
	}

	stdop<TextInputAction> /*var-nullable*/ TextField::textInputAction() {
		auto m = ManagedCall("TextField", "textInputAction");
		m.put("this", this);
		stdop<TextInputAction> result;
		m.call(result);
		return result;
	}

	TextCapitalization /*var-non-null*/ TextField::textCapitalization() {
		auto m = ManagedCall("TextField", "textCapitalization");
		m.put("this", this);
		TextCapitalization result;
		m.check(m.call(result));
		return result;
	}

	shptr<class TextStyle> /*var-nullable*/ TextField::style() {
		auto m = ManagedCall("TextField", "style");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.call(result);
		return result;
	}

	shptr<class StrutStyle> /*var-nullable*/ TextField::strutStyle() {
		auto m = ManagedCall("TextField", "strutStyle");
		m.put("this", this);
		shptr<class StrutStyle> result;
		m.call(result);
		return result;
	}

	TextAlign /*var-non-null*/ TextField::textAlign() {
		auto m = ManagedCall("TextField", "textAlign");
		m.put("this", this);
		TextAlign result;
		m.check(m.call(result));
		return result;
	}

	shptr<class TextAlignVertical> /*var-nullable*/ TextField::textAlignVertical() {
		auto m = ManagedCall("TextField", "textAlignVertical");
		m.put("this", this);
		shptr<class TextAlignVertical> result;
		m.call(result);
		return result;
	}

	stdop<TextDirection> /*var-nullable*/ TextField::textDirection() {
		auto m = ManagedCall("TextField", "textDirection");
		m.put("this", this);
		stdop<TextDirection> result;
		m.call(result);
		return result;
	}

	bool /*var-non-null*/ TextField::autofocus() {
		auto m = ManagedCall("TextField", "autofocus");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	stdstr /*var-non-null*/ TextField::obscuringCharacter() {
		auto m = ManagedCall("TextField", "obscuringCharacter");
		m.put("this", this);
		stdstr result;
		m.check(m.call(result));
		return result;
	}

	bool /*var-non-null*/ TextField::obscureText() {
		auto m = ManagedCall("TextField", "obscureText");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	bool /*var-non-null*/ TextField::autocorrect() {
		auto m = ManagedCall("TextField", "autocorrect");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	SmartDashesType /*var-non-null*/ TextField::smartDashesType() {
		auto m = ManagedCall("TextField", "smartDashesType");
		m.put("this", this);
		SmartDashesType result;
		m.check(m.call(result));
		return result;
	}

	SmartQuotesType /*var-non-null*/ TextField::smartQuotesType() {
		auto m = ManagedCall("TextField", "smartQuotesType");
		m.put("this", this);
		SmartQuotesType result;
		m.check(m.call(result));
		return result;
	}

	bool /*var-non-null*/ TextField::enableSuggestions() {
		auto m = ManagedCall("TextField", "enableSuggestions");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	stdop<int64> /*var-nullable*/ TextField::maxLines() {
		auto m = ManagedCall("TextField", "maxLines");
		m.put("this", this);
		stdop<int64> result;
		m.call(result);
		return result;
	}

	stdop<int64> /*var-nullable*/ TextField::minLines() {
		auto m = ManagedCall("TextField", "minLines");
		m.put("this", this);
		stdop<int64> result;
		m.call(result);
		return result;
	}

	bool /*var-non-null*/ TextField::expands() {
		auto m = ManagedCall("TextField", "expands");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	bool /*var-non-null*/ TextField::readOnly() {
		auto m = ManagedCall("TextField", "readOnly");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ToolbarOptions> /*var-nullable*/ TextField::toolbarOptions() {
		auto m = ManagedCall("TextField", "toolbarOptions");
		m.put("this", this);
		shptr<class ToolbarOptions> result;
		m.call(result);
		return result;
	}

	stdop<bool> /*var-nullable*/ TextField::showCursor() {
		auto m = ManagedCall("TextField", "showCursor");
		m.put("this", this);
		stdop<bool> result;
		m.call(result);
		return result;
	}

	int64 /*var-non-null*/ TextField::noMaxLength() {
		auto m = ManagedCall("TextField", "noMaxLength");
		int64 result;
		m.check(m.call(result));
		return result;
	}

	stdop<int64> /*var-nullable*/ TextField::maxLength() {
		auto m = ManagedCall("TextField", "maxLength");
		m.put("this", this);
		stdop<int64> result;
		m.call(result);
		return result;
	}

	stdop<MaxLengthEnforcement> /*var-nullable*/ TextField::maxLengthEnforcement() {
		auto m = ManagedCall("TextField", "maxLengthEnforcement");
		m.put("this", this);
		stdop<MaxLengthEnforcement> result;
		m.call(result);
		return result;
	}

	stdop<bool> /*var-nullable*/ TextField::enabled() {
		auto m = ManagedCall("TextField", "enabled");
		m.put("this", this);
		stdop<bool> result;
		m.call(result);
		return result;
	}

	double /*var-non-null*/ TextField::cursorWidth() {
		auto m = ManagedCall("TextField", "cursorWidth");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	stdop<double> /*var-nullable*/ TextField::cursorHeight() {
		auto m = ManagedCall("TextField", "cursorHeight");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	shptr<class Radius> /*var-nullable*/ TextField::cursorRadius() {
		auto m = ManagedCall("TextField", "cursorRadius");
		m.put("this", this);
		shptr<class Radius> result;
		m.call(result);
		return result;
	}

	stdop<bool> /*var-nullable*/ TextField::cursorOpacityAnimates() {
		auto m = ManagedCall("TextField", "cursorOpacityAnimates");
		m.put("this", this);
		stdop<bool> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ TextField::cursorColor() {
		auto m = ManagedCall("TextField", "cursorColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	BoxHeightStyle /*var-non-null*/ TextField::selectionHeightStyle() {
		auto m = ManagedCall("TextField", "selectionHeightStyle");
		m.put("this", this);
		BoxHeightStyle result;
		m.check(m.call(result));
		return result;
	}

	BoxWidthStyle /*var-non-null*/ TextField::selectionWidthStyle() {
		auto m = ManagedCall("TextField", "selectionWidthStyle");
		m.put("this", this);
		BoxWidthStyle result;
		m.check(m.call(result));
		return result;
	}

	stdop<Brightness> /*var-nullable*/ TextField::keyboardAppearance() {
		auto m = ManagedCall("TextField", "keyboardAppearance");
		m.put("this", this);
		stdop<Brightness> result;
		m.call(result);
		return result;
	}

	shptr<class EdgeInsets> /*var-non-null*/ TextField::scrollPadding() {
		auto m = ManagedCall("TextField", "scrollPadding");
		m.put("this", this);
		shptr<class EdgeInsets> result;
		m.check(m.call(result));
		return result;
	}

	bool /*var-non-null*/ TextField::enableInteractiveSelection() {
		auto m = ManagedCall("TextField", "enableInteractiveSelection");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class TextSelectionControls> /*var-nullable*/ TextField::selectionControls() {
		auto m = ManagedCall("TextField", "selectionControls");
		m.put("this", this);
		shptr<class TextSelectionControls> result;
		m.call(result);
		return result;
	}

	DragStartBehavior /*var-non-null*/ TextField::dragStartBehavior() {
		auto m = ManagedCall("TextField", "dragStartBehavior");
		m.put("this", this);
		DragStartBehavior result;
		m.check(m.call(result));
		return result;
	}

	shptr<class MouseCursor> /*var-nullable*/ TextField::mouseCursor() {
		auto m = ManagedCall("TextField", "mouseCursor");
		m.put("this", this);
		shptr<class MouseCursor> result;
		m.call(result);
		return result;
	}

	shptr<class ScrollPhysics> /*var-nullable*/ TextField::scrollPhysics() {
		auto m = ManagedCall("TextField", "scrollPhysics");
		m.put("this", this);
		shptr<class ScrollPhysics> result;
		m.call(result);
		return result;
	}

	shptr<class ScrollController> /*var-nullable*/ TextField::scrollController() {
		auto m = ManagedCall("TextField", "scrollController");
		m.put("this", this);
		shptr<class ScrollController> result;
		m.call(result);
		return result;
	}

	Clip /*var-non-null*/ TextField::clipBehavior() {
		auto m = ManagedCall("TextField", "clipBehavior");
		m.put("this", this);
		Clip result;
		m.check(m.call(result));
		return result;
	}

	stdop<stdstr> /*var-nullable*/ TextField::restorationId() {
		auto m = ManagedCall("TextField", "restorationId");
		m.put("this", this);
		stdop<stdstr> result;
		m.call(result);
		return result;
	}

	bool /*var-non-null*/ TextField::scribbleEnabled() {
		auto m = ManagedCall("TextField", "scribbleEnabled");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	bool /*var-non-null*/ TextField::enableIMEPersonalizedLearning() {
		auto m = ManagedCall("TextField", "enableIMEPersonalizedLearning");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ContentInsertionConfiguration> /*var-nullable*/ TextField::contentInsertionConfiguration() {
		auto m = ManagedCall("TextField", "contentInsertionConfiguration");
		m.put("this", this);
		shptr<class ContentInsertionConfiguration> result;
		m.call(result);
		return result;
	}

	bool /*var-non-null*/ TextField::canRequestFocus() {
		auto m = ManagedCall("TextField", "canRequestFocus");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class UndoHistoryController> /*var-nullable*/ TextField::undoController() {
		auto m = ManagedCall("TextField", "undoController");
		m.put("this", this);
		shptr<class UndoHistoryController> result;
		m.call(result);
		return result;
	}

	shptr<class SpellCheckConfiguration> /*var-nullable*/ TextField::spellCheckConfiguration() {
		auto m = ManagedCall("TextField", "spellCheckConfiguration");
		m.put("this", this);
		shptr<class SpellCheckConfiguration> result;
		m.call(result);
		return result;
	}

	shptr<class TextStyle> /*var-non-null*/ TextField::materialMisspelledTextStyle() {
		auto m = ManagedCall("TextField", "materialMisspelledTextStyle");
		shptr<class TextStyle> result;
		m.check(m.call(result));
		return result;
	}

	bool /*get-non-null*/ TextField::selectionEnabled() {
		auto m = ManagedCall("TextField", "selectionEnabled");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Widget> /*non-null*/ TextField::defaultSpellCheckSuggestionsToolbarBuilder(/*non-null*/ shptr<class BuildContext> context, /*non-null*/ shptr<class EditableTextState> editableTextState) {
		auto m = ManagedCall("TextField", "defaultSpellCheckSuggestionsToolbarBuilder");
		m.put("context", context, true);
		m.put("editableTextState", editableTextState, true);
		shptr<class Widget> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class SpellCheckConfiguration> /*non-null*/ TextField::inferAndroidSpellCheckConfiguration(/*nullable*/ shptr<class SpellCheckConfiguration> configuration) {
		auto m = ManagedCall("TextField", "inferAndroidSpellCheckConfiguration");
		m.put("configuration", configuration);
		shptr<class SpellCheckConfiguration> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class TextField> /*non-null*/ TextField::ctorMain(_ctorMain p) {
		auto m = ManagedCall("TextField", "TextField");
		m.put("key", p.key);
		m.put("controller", p.controller);
		m.put("focusNode", p.focusNode);
		m.put("undoController", p.undoController);
		m.put("decoration", p.decoration);
		m.put("keyboardType", p.keyboardType);
		m.put("textInputAction", p.textInputAction);
		m.put("textCapitalization", p.textCapitalization);
		m.put("style", p.style);
		m.put("strutStyle", p.strutStyle);
		m.put("textAlign", p.textAlign);
		m.put("textAlignVertical", p.textAlignVertical);
		m.put("textDirection", p.textDirection);
		m.put("readOnly", p.readOnly);
		m.put("toolbarOptions", p.toolbarOptions);
		m.put("showCursor", p.showCursor);
		m.put("autofocus", p.autofocus);
		m.put("obscuringCharacter", p.obscuringCharacter);
		m.put("obscureText", p.obscureText);
		m.put("autocorrect", p.autocorrect);
		m.put("smartDashesType", p.smartDashesType);
		m.put("smartQuotesType", p.smartQuotesType);
		m.put("enableSuggestions", p.enableSuggestions);
		m.put("maxLines", p.maxLines);
		m.put("minLines", p.minLines);
		m.put("expands", p.expands);
		m.put("maxLength", p.maxLength);
		m.put("maxLengthEnforcement", p.maxLengthEnforcement);
		m.put("onChanged", p.onChanged);
		m.put("onEditingComplete", p.onEditingComplete);
		m.put("onSubmitted", p.onSubmitted);
//		m.put("onAppPrivateCommand", p.onAppPrivateCommand);
		m.put("inputFormatters", p.inputFormatters);
		m.put("enabled", p.enabled);
		m.put("cursorWidth", p.cursorWidth);
		m.put("cursorHeight", p.cursorHeight);
		m.put("cursorRadius", p.cursorRadius);
		m.put("cursorOpacityAnimates", p.cursorOpacityAnimates);
		m.put("cursorColor", p.cursorColor);
		m.put("selectionHeightStyle", p.selectionHeightStyle);
		m.put("selectionWidthStyle", p.selectionWidthStyle);
		m.put("keyboardAppearance", p.keyboardAppearance);
		m.put("scrollPadding", p.scrollPadding, true);
		m.put("dragStartBehavior", p.dragStartBehavior);
		m.put("enableInteractiveSelection", p.enableInteractiveSelection);
		m.put("selectionControls", p.selectionControls);
		m.put("onTap", p.onTap);
		m.put("onTapOutside", p.onTapOutside);
		m.put("mouseCursor", p.mouseCursor);
//		m.put("buildCounter", p.buildCounter);
		m.put("scrollController", p.scrollController);
		m.put("scrollPhysics", p.scrollPhysics);
		m.put("autofillHints", p.autofillHints);
		m.put("contentInsertionConfiguration", p.contentInsertionConfiguration);
		m.put("clipBehavior", p.clipBehavior);
		m.put("restorationId", p.restorationId);
		m.put("scribbleEnabled", p.scribbleEnabled);
		m.put("enableIMEPersonalizedLearning", p.enableIMEPersonalizedLearning);
		m.put("contextMenuBuilder", p.contextMenuBuilder);
		m.put("canRequestFocus", p.canRequestFocus);
		m.put("spellCheckConfiguration", p.spellCheckConfiguration);
		m.put("magnifierConfiguration", p.magnifierConfiguration);
		shptr<class TextField> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class FloatingActionButtonLocation> /*var-non-null*/ FloatingActionButtonLocation::startTop() {
		auto m = ManagedCall("FloatingActionButtonLocation", "startTop");
		shptr<class FloatingActionButtonLocation> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class FloatingActionButtonLocation> /*var-non-null*/ FloatingActionButtonLocation::miniStartTop() {
		auto m = ManagedCall("FloatingActionButtonLocation", "miniStartTop");
		shptr<class FloatingActionButtonLocation> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class FloatingActionButtonLocation> /*var-non-null*/ FloatingActionButtonLocation::centerTop() {
		auto m = ManagedCall("FloatingActionButtonLocation", "centerTop");
		shptr<class FloatingActionButtonLocation> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class FloatingActionButtonLocation> /*var-non-null*/ FloatingActionButtonLocation::miniCenterTop() {
		auto m = ManagedCall("FloatingActionButtonLocation", "miniCenterTop");
		shptr<class FloatingActionButtonLocation> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class FloatingActionButtonLocation> /*var-non-null*/ FloatingActionButtonLocation::endTop() {
		auto m = ManagedCall("FloatingActionButtonLocation", "endTop");
		shptr<class FloatingActionButtonLocation> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class FloatingActionButtonLocation> /*var-non-null*/ FloatingActionButtonLocation::miniEndTop() {
		auto m = ManagedCall("FloatingActionButtonLocation", "miniEndTop");
		shptr<class FloatingActionButtonLocation> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class FloatingActionButtonLocation> /*var-non-null*/ FloatingActionButtonLocation::startFloat() {
		auto m = ManagedCall("FloatingActionButtonLocation", "startFloat");
		shptr<class FloatingActionButtonLocation> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class FloatingActionButtonLocation> /*var-non-null*/ FloatingActionButtonLocation::miniStartFloat() {
		auto m = ManagedCall("FloatingActionButtonLocation", "miniStartFloat");
		shptr<class FloatingActionButtonLocation> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class FloatingActionButtonLocation> /*var-non-null*/ FloatingActionButtonLocation::centerFloat() {
		auto m = ManagedCall("FloatingActionButtonLocation", "centerFloat");
		shptr<class FloatingActionButtonLocation> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class FloatingActionButtonLocation> /*var-non-null*/ FloatingActionButtonLocation::miniCenterFloat() {
		auto m = ManagedCall("FloatingActionButtonLocation", "miniCenterFloat");
		shptr<class FloatingActionButtonLocation> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class FloatingActionButtonLocation> /*var-non-null*/ FloatingActionButtonLocation::endFloat() {
		auto m = ManagedCall("FloatingActionButtonLocation", "endFloat");
		shptr<class FloatingActionButtonLocation> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class FloatingActionButtonLocation> /*var-non-null*/ FloatingActionButtonLocation::miniEndFloat() {
		auto m = ManagedCall("FloatingActionButtonLocation", "miniEndFloat");
		shptr<class FloatingActionButtonLocation> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class FloatingActionButtonLocation> /*var-non-null*/ FloatingActionButtonLocation::startDocked() {
		auto m = ManagedCall("FloatingActionButtonLocation", "startDocked");
		shptr<class FloatingActionButtonLocation> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class FloatingActionButtonLocation> /*var-non-null*/ FloatingActionButtonLocation::miniStartDocked() {
		auto m = ManagedCall("FloatingActionButtonLocation", "miniStartDocked");
		shptr<class FloatingActionButtonLocation> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class FloatingActionButtonLocation> /*var-non-null*/ FloatingActionButtonLocation::centerDocked() {
		auto m = ManagedCall("FloatingActionButtonLocation", "centerDocked");
		shptr<class FloatingActionButtonLocation> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class FloatingActionButtonLocation> /*var-non-null*/ FloatingActionButtonLocation::miniCenterDocked() {
		auto m = ManagedCall("FloatingActionButtonLocation", "miniCenterDocked");
		shptr<class FloatingActionButtonLocation> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class FloatingActionButtonLocation> /*var-non-null*/ FloatingActionButtonLocation::endDocked() {
		auto m = ManagedCall("FloatingActionButtonLocation", "endDocked");
		shptr<class FloatingActionButtonLocation> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class FloatingActionButtonLocation> /*var-non-null*/ FloatingActionButtonLocation::miniEndDocked() {
		auto m = ManagedCall("FloatingActionButtonLocation", "miniEndDocked");
		shptr<class FloatingActionButtonLocation> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class FloatingActionButtonLocation> /*var-non-null*/ FloatingActionButtonLocation::endContained() {
		auto m = ManagedCall("FloatingActionButtonLocation", "endContained");
		shptr<class FloatingActionButtonLocation> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Widget> /*var-nullable*/ FloatingActionButton::child() {
		auto m = ManagedCall("FloatingActionButton", "child");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	stdop<stdstr> /*var-nullable*/ FloatingActionButton::tooltip() {
		auto m = ManagedCall("FloatingActionButton", "tooltip");
		m.put("this", this);
		stdop<stdstr> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ FloatingActionButton::foregroundColor() {
		auto m = ManagedCall("FloatingActionButton", "foregroundColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ FloatingActionButton::backgroundColor() {
		auto m = ManagedCall("FloatingActionButton", "backgroundColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ FloatingActionButton::focusColor() {
		auto m = ManagedCall("FloatingActionButton", "focusColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ FloatingActionButton::hoverColor() {
		auto m = ManagedCall("FloatingActionButton", "hoverColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ FloatingActionButton::splashColor() {
		auto m = ManagedCall("FloatingActionButton", "splashColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class ObjBase> /*var-nullable*/ FloatingActionButton::heroTag() {
		auto m = ManagedCall("FloatingActionButton", "heroTag");
		m.put("this", this);
		shptr<class ObjBase> result;
		m.call(result);
		return result;
	}

	shptr<class MouseCursor> /*var-nullable*/ FloatingActionButton::mouseCursor() {
		auto m = ManagedCall("FloatingActionButton", "mouseCursor");
		m.put("this", this);
		shptr<class MouseCursor> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ FloatingActionButton::elevation() {
		auto m = ManagedCall("FloatingActionButton", "elevation");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ FloatingActionButton::focusElevation() {
		auto m = ManagedCall("FloatingActionButton", "focusElevation");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ FloatingActionButton::hoverElevation() {
		auto m = ManagedCall("FloatingActionButton", "hoverElevation");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ FloatingActionButton::highlightElevation() {
		auto m = ManagedCall("FloatingActionButton", "highlightElevation");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ FloatingActionButton::disabledElevation() {
		auto m = ManagedCall("FloatingActionButton", "disabledElevation");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	bool /*var-non-null*/ FloatingActionButton::mini() {
		auto m = ManagedCall("FloatingActionButton", "mini");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ShapeBorder> /*var-nullable*/ FloatingActionButton::shape() {
		auto m = ManagedCall("FloatingActionButton", "shape");
		m.put("this", this);
		shptr<class ShapeBorder> result;
		m.call(result);
		return result;
	}

	Clip /*var-non-null*/ FloatingActionButton::clipBehavior() {
		auto m = ManagedCall("FloatingActionButton", "clipBehavior");
		m.put("this", this);
		Clip result;
		m.check(m.call(result));
		return result;
	}

	bool /*var-non-null*/ FloatingActionButton::isExtended() {
		auto m = ManagedCall("FloatingActionButton", "isExtended");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class FocusNode> /*var-nullable*/ FloatingActionButton::focusNode() {
		auto m = ManagedCall("FloatingActionButton", "focusNode");
		m.put("this", this);
		shptr<class FocusNode> result;
		m.call(result);
		return result;
	}

	bool /*var-non-null*/ FloatingActionButton::autofocus() {
		auto m = ManagedCall("FloatingActionButton", "autofocus");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	stdop<MaterialTapTargetSize> /*var-nullable*/ FloatingActionButton::materialTapTargetSize() {
		auto m = ManagedCall("FloatingActionButton", "materialTapTargetSize");
		m.put("this", this);
		stdop<MaterialTapTargetSize> result;
		m.call(result);
		return result;
	}

	stdop<bool> /*var-nullable*/ FloatingActionButton::enableFeedback() {
		auto m = ManagedCall("FloatingActionButton", "enableFeedback");
		m.put("this", this);
		stdop<bool> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ FloatingActionButton::extendedIconLabelSpacing() {
		auto m = ManagedCall("FloatingActionButton", "extendedIconLabelSpacing");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	shptr<class EdgeInsetsGeometry> /*var-nullable*/ FloatingActionButton::extendedPadding() {
		auto m = ManagedCall("FloatingActionButton", "extendedPadding");
		m.put("this", this);
		shptr<class EdgeInsetsGeometry> result;
		m.call(result);
		return result;
	}

	shptr<class TextStyle> /*var-nullable*/ FloatingActionButton::extendedTextStyle() {
		auto m = ManagedCall("FloatingActionButton", "extendedTextStyle");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.call(result);
		return result;
	}

	shptr<class FloatingActionButton> /*non-null*/ FloatingActionButton::ctorMain(_ctorMain p) {
		auto m = ManagedCall("FloatingActionButton", "FloatingActionButton");
		m.put("key", p.key);
		m.put("child", p.child);
		m.put("tooltip", p.tooltip);
		m.put("foregroundColor", p.foregroundColor);
		m.put("backgroundColor", p.backgroundColor);
		m.put("focusColor", p.focusColor);
		m.put("hoverColor", p.hoverColor);
		m.put("splashColor", p.splashColor);
//		m.put("heroTag", p.heroTag);
		m.put("elevation", p.elevation);
		m.put("focusElevation", p.focusElevation);
		m.put("hoverElevation", p.hoverElevation);
		m.put("highlightElevation", p.highlightElevation);
		m.put("disabledElevation", p.disabledElevation);
		m.put("onPressed", p.onPressed);
		m.put("mouseCursor", p.mouseCursor);
		m.put("mini", p.mini);
		m.put("shape", p.shape);
		m.put("clipBehavior", p.clipBehavior);
		m.put("focusNode", p.focusNode);
		m.put("autofocus", p.autofocus);
		m.put("materialTapTargetSize", p.materialTapTargetSize);
		m.put("isExtended", p.isExtended);
		m.put("enableFeedback", p.enableFeedback);
		shptr<class FloatingActionButton> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class FloatingActionButton> /*non-null*/ FloatingActionButton::small_(_small p) {
		auto m = ManagedCall("FloatingActionButton", "small");
		m.put("key", p.key);
		m.put("child", p.child);
		m.put("tooltip", p.tooltip);
		m.put("foregroundColor", p.foregroundColor);
		m.put("backgroundColor", p.backgroundColor);
		m.put("focusColor", p.focusColor);
		m.put("hoverColor", p.hoverColor);
		m.put("splashColor", p.splashColor);
//		m.put("heroTag", p.heroTag);
		m.put("elevation", p.elevation);
		m.put("focusElevation", p.focusElevation);
		m.put("hoverElevation", p.hoverElevation);
		m.put("highlightElevation", p.highlightElevation);
		m.put("disabledElevation", p.disabledElevation);
		m.put("onPressed", p.onPressed);
		m.put("mouseCursor", p.mouseCursor);
		m.put("shape", p.shape);
		m.put("clipBehavior", p.clipBehavior);
		m.put("focusNode", p.focusNode);
		m.put("autofocus", p.autofocus);
		m.put("materialTapTargetSize", p.materialTapTargetSize);
		m.put("enableFeedback", p.enableFeedback);
		shptr<class FloatingActionButton> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class FloatingActionButton> /*non-null*/ FloatingActionButton::large(_large p) {
		auto m = ManagedCall("FloatingActionButton", "large");
		m.put("key", p.key);
		m.put("child", p.child);
		m.put("tooltip", p.tooltip);
		m.put("foregroundColor", p.foregroundColor);
		m.put("backgroundColor", p.backgroundColor);
		m.put("focusColor", p.focusColor);
		m.put("hoverColor", p.hoverColor);
		m.put("splashColor", p.splashColor);
//		m.put("heroTag", p.heroTag);
		m.put("elevation", p.elevation);
		m.put("focusElevation", p.focusElevation);
		m.put("hoverElevation", p.hoverElevation);
		m.put("highlightElevation", p.highlightElevation);
		m.put("disabledElevation", p.disabledElevation);
		m.put("onPressed", p.onPressed);
		m.put("mouseCursor", p.mouseCursor);
		m.put("shape", p.shape);
		m.put("clipBehavior", p.clipBehavior);
		m.put("focusNode", p.focusNode);
		m.put("autofocus", p.autofocus);
		m.put("materialTapTargetSize", p.materialTapTargetSize);
		m.put("enableFeedback", p.enableFeedback);
		shptr<class FloatingActionButton> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class FloatingActionButton> /*non-null*/ FloatingActionButton::extended(_extended p) {
		auto m = ManagedCall("FloatingActionButton", "extended");
		m.put("key", p.key);
		m.put("tooltip", p.tooltip);
		m.put("foregroundColor", p.foregroundColor);
		m.put("backgroundColor", p.backgroundColor);
		m.put("focusColor", p.focusColor);
		m.put("hoverColor", p.hoverColor);
//		m.put("heroTag", p.heroTag);
		m.put("elevation", p.elevation);
		m.put("focusElevation", p.focusElevation);
		m.put("hoverElevation", p.hoverElevation);
		m.put("splashColor", p.splashColor);
		m.put("highlightElevation", p.highlightElevation);
		m.put("disabledElevation", p.disabledElevation);
		m.put("onPressed", p.onPressed);
		m.put("mouseCursor", p.mouseCursor);
		m.put("shape", p.shape);
		m.put("isExtended", p.isExtended);
		m.put("materialTapTargetSize", p.materialTapTargetSize);
		m.put("clipBehavior", p.clipBehavior);
		m.put("focusNode", p.focusNode);
		m.put("autofocus", p.autofocus);
		m.put("extendedIconLabelSpacing", p.extendedIconLabelSpacing);
		m.put("extendedPadding", p.extendedPadding);
		m.put("extendedTextStyle", p.extendedTextStyle);
		m.put("icon", p.icon);
		m.put("label", p.label, true);
		m.put("enableFeedback", p.enableFeedback);
		shptr<class FloatingActionButton> result;
		m.check(m.call(result, true));
		return result;
	}

	stdop<double> /*var-nullable*/ IconButton::iconSize() {
		auto m = ManagedCall("IconButton", "iconSize");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	shptr<class VisualDensity> /*var-nullable*/ IconButton::visualDensity() {
		auto m = ManagedCall("IconButton", "visualDensity");
		m.put("this", this);
		shptr<class VisualDensity> result;
		m.call(result);
		return result;
	}

	shptr<class EdgeInsetsGeometry> /*var-nullable*/ IconButton::padding() {
		auto m = ManagedCall("IconButton", "padding");
		m.put("this", this);
		shptr<class EdgeInsetsGeometry> result;
		m.call(result);
		return result;
	}

	shptr<class AlignmentGeometry> /*var-nullable*/ IconButton::alignment() {
		auto m = ManagedCall("IconButton", "alignment");
		m.put("this", this);
		shptr<class AlignmentGeometry> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ IconButton::splashRadius() {
		auto m = ManagedCall("IconButton", "splashRadius");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	shptr<class Widget> /*var-non-null*/ IconButton::icon() {
		auto m = ManagedCall("IconButton", "icon");
		m.put("this", this);
		shptr<class Widget> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*var-nullable*/ IconButton::focusColor() {
		auto m = ManagedCall("IconButton", "focusColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ IconButton::hoverColor() {
		auto m = ManagedCall("IconButton", "hoverColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ IconButton::color() {
		auto m = ManagedCall("IconButton", "color");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ IconButton::splashColor() {
		auto m = ManagedCall("IconButton", "splashColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ IconButton::highlightColor() {
		auto m = ManagedCall("IconButton", "highlightColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ IconButton::disabledColor() {
		auto m = ManagedCall("IconButton", "disabledColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class MouseCursor> /*var-nullable*/ IconButton::mouseCursor() {
		auto m = ManagedCall("IconButton", "mouseCursor");
		m.put("this", this);
		shptr<class MouseCursor> result;
		m.call(result);
		return result;
	}

	shptr<class FocusNode> /*var-nullable*/ IconButton::focusNode() {
		auto m = ManagedCall("IconButton", "focusNode");
		m.put("this", this);
		shptr<class FocusNode> result;
		m.call(result);
		return result;
	}

	bool /*var-non-null*/ IconButton::autofocus() {
		auto m = ManagedCall("IconButton", "autofocus");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	stdop<stdstr> /*var-nullable*/ IconButton::tooltip() {
		auto m = ManagedCall("IconButton", "tooltip");
		m.put("this", this);
		stdop<stdstr> result;
		m.call(result);
		return result;
	}

	stdop<bool> /*var-nullable*/ IconButton::enableFeedback() {
		auto m = ManagedCall("IconButton", "enableFeedback");
		m.put("this", this);
		stdop<bool> result;
		m.call(result);
		return result;
	}

	shptr<class BoxConstraints> /*var-nullable*/ IconButton::constraints() {
		auto m = ManagedCall("IconButton", "constraints");
		m.put("this", this);
		shptr<class BoxConstraints> result;
		m.call(result);
		return result;
	}

	shptr<class ButtonStyle> /*var-nullable*/ IconButton::style() {
		auto m = ManagedCall("IconButton", "style");
		m.put("this", this);
		shptr<class ButtonStyle> result;
		m.call(result);
		return result;
	}

	stdop<bool> /*var-nullable*/ IconButton::isSelected() {
		auto m = ManagedCall("IconButton", "isSelected");
		m.put("this", this);
		stdop<bool> result;
		m.call(result);
		return result;
	}

	shptr<class Widget> /*var-nullable*/ IconButton::selectedIcon() {
		auto m = ManagedCall("IconButton", "selectedIcon");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	shptr<class ButtonStyle> /*non-null*/ IconButton::styleFrom(_styleFrom p) {
		auto m = ManagedCall("IconButton", "styleFrom");
		m.put("foregroundColor", p.foregroundColor);
		m.put("backgroundColor", p.backgroundColor);
		m.put("disabledForegroundColor", p.disabledForegroundColor);
		m.put("disabledBackgroundColor", p.disabledBackgroundColor);
		m.put("focusColor", p.focusColor);
		m.put("hoverColor", p.hoverColor);
		m.put("highlightColor", p.highlightColor);
		m.put("shadowColor", p.shadowColor);
		m.put("surfaceTintColor", p.surfaceTintColor);
		m.put("elevation", p.elevation);
		m.put("minimumSize", p.minimumSize);
		m.put("fixedSize", p.fixedSize);
		m.put("maximumSize", p.maximumSize);
		m.put("iconSize", p.iconSize);
		m.put("side", p.side);
		m.put("shape", p.shape);
		m.put("padding", p.padding);
		m.put("enabledMouseCursor", p.enabledMouseCursor);
		m.put("disabledMouseCursor", p.disabledMouseCursor);
		m.put("visualDensity", p.visualDensity);
		m.put("tapTargetSize", p.tapTargetSize);
		m.put("animationDuration", p.animationDuration);
		m.put("enableFeedback", p.enableFeedback);
		m.put("alignment", p.alignment);
		m.put("splashFactory", p.splashFactory);
		shptr<class ButtonStyle> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class IconButton> /*non-null*/ IconButton::ctorMain(_ctorMain p) {
		auto m = ManagedCall("IconButton", "IconButton");
		m.put("key", p.key);
		m.put("iconSize", p.iconSize);
		m.put("visualDensity", p.visualDensity);
		m.put("padding", p.padding);
		m.put("alignment", p.alignment);
		m.put("splashRadius", p.splashRadius);
		m.put("color", p.color);
		m.put("focusColor", p.focusColor);
		m.put("hoverColor", p.hoverColor);
		m.put("highlightColor", p.highlightColor);
		m.put("splashColor", p.splashColor);
		m.put("disabledColor", p.disabledColor);
		m.put("onPressed", p.onPressed);
		m.put("mouseCursor", p.mouseCursor);
		m.put("focusNode", p.focusNode);
		m.put("autofocus", p.autofocus);
		m.put("tooltip", p.tooltip);
		m.put("enableFeedback", p.enableFeedback);
		m.put("constraints", p.constraints);
		m.put("style", p.style);
		m.put("isSelected", p.isSelected);
		m.put("selectedIcon", p.selectedIcon);
		m.put("icon", p.icon, true);
		shptr<class IconButton> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class IconButton> /*non-null*/ IconButton::filled(_filled p) {
		auto m = ManagedCall("IconButton", "filled");
		m.put("key", p.key);
		m.put("iconSize", p.iconSize);
		m.put("visualDensity", p.visualDensity);
		m.put("padding", p.padding);
		m.put("alignment", p.alignment);
		m.put("splashRadius", p.splashRadius);
		m.put("color", p.color);
		m.put("focusColor", p.focusColor);
		m.put("hoverColor", p.hoverColor);
		m.put("highlightColor", p.highlightColor);
		m.put("splashColor", p.splashColor);
		m.put("disabledColor", p.disabledColor);
		m.put("onPressed", p.onPressed);
		m.put("mouseCursor", p.mouseCursor);
		m.put("focusNode", p.focusNode);
		m.put("autofocus", p.autofocus);
		m.put("tooltip", p.tooltip);
		m.put("enableFeedback", p.enableFeedback);
		m.put("constraints", p.constraints);
		m.put("style", p.style);
		m.put("isSelected", p.isSelected);
		m.put("selectedIcon", p.selectedIcon);
		m.put("icon", p.icon, true);
		shptr<class IconButton> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class IconButton> /*non-null*/ IconButton::filledTonal(_filledTonal p) {
		auto m = ManagedCall("IconButton", "filledTonal");
		m.put("key", p.key);
		m.put("iconSize", p.iconSize);
		m.put("visualDensity", p.visualDensity);
		m.put("padding", p.padding);
		m.put("alignment", p.alignment);
		m.put("splashRadius", p.splashRadius);
		m.put("color", p.color);
		m.put("focusColor", p.focusColor);
		m.put("hoverColor", p.hoverColor);
		m.put("highlightColor", p.highlightColor);
		m.put("splashColor", p.splashColor);
		m.put("disabledColor", p.disabledColor);
		m.put("onPressed", p.onPressed);
		m.put("mouseCursor", p.mouseCursor);
		m.put("focusNode", p.focusNode);
		m.put("autofocus", p.autofocus);
		m.put("tooltip", p.tooltip);
		m.put("enableFeedback", p.enableFeedback);
		m.put("constraints", p.constraints);
		m.put("style", p.style);
		m.put("isSelected", p.isSelected);
		m.put("selectedIcon", p.selectedIcon);
		m.put("icon", p.icon, true);
		shptr<class IconButton> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class IconButton> /*non-null*/ IconButton::outlined(_outlined p) {
		auto m = ManagedCall("IconButton", "outlined");
		m.put("key", p.key);
		m.put("iconSize", p.iconSize);
		m.put("visualDensity", p.visualDensity);
		m.put("padding", p.padding);
		m.put("alignment", p.alignment);
		m.put("splashRadius", p.splashRadius);
		m.put("color", p.color);
		m.put("focusColor", p.focusColor);
		m.put("hoverColor", p.hoverColor);
		m.put("highlightColor", p.highlightColor);
		m.put("splashColor", p.splashColor);
		m.put("disabledColor", p.disabledColor);
		m.put("onPressed", p.onPressed);
		m.put("mouseCursor", p.mouseCursor);
		m.put("focusNode", p.focusNode);
		m.put("autofocus", p.autofocus);
		m.put("tooltip", p.tooltip);
		m.put("enableFeedback", p.enableFeedback);
		m.put("constraints", p.constraints);
		m.put("style", p.style);
		m.put("isSelected", p.isSelected);
		m.put("selectedIcon", p.selectedIcon);
		m.put("icon", p.icon, true);
		shptr<class IconButton> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Widget> /*var-nullable*/ InkResponse::child() {
		auto m = ManagedCall("InkResponse", "child");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	shptr<class MouseCursor> /*var-nullable*/ InkResponse::mouseCursor() {
		auto m = ManagedCall("InkResponse", "mouseCursor");
		m.put("this", this);
		shptr<class MouseCursor> result;
		m.call(result);
		return result;
	}

	bool /*var-non-null*/ InkResponse::containedInkWell() {
		auto m = ManagedCall("InkResponse", "containedInkWell");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	BoxShape /*var-non-null*/ InkResponse::highlightShape() {
		auto m = ManagedCall("InkResponse", "highlightShape");
		m.put("this", this);
		BoxShape result;
		m.check(m.call(result));
		return result;
	}

	stdop<double> /*var-nullable*/ InkResponse::radius() {
		auto m = ManagedCall("InkResponse", "radius");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	shptr<class BorderRadius> /*var-nullable*/ InkResponse::borderRadius() {
		auto m = ManagedCall("InkResponse", "borderRadius");
		m.put("this", this);
		shptr<class BorderRadius> result;
		m.call(result);
		return result;
	}

	shptr<class ShapeBorder> /*var-nullable*/ InkResponse::customBorder() {
		auto m = ManagedCall("InkResponse", "customBorder");
		m.put("this", this);
		shptr<class ShapeBorder> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ InkResponse::focusColor() {
		auto m = ManagedCall("InkResponse", "focusColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ InkResponse::hoverColor() {
		auto m = ManagedCall("InkResponse", "hoverColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ InkResponse::highlightColor() {
		auto m = ManagedCall("InkResponse", "highlightColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ InkResponse::splashColor() {
		auto m = ManagedCall("InkResponse", "splashColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class InteractiveInkFeatureFactory> /*var-nullable*/ InkResponse::splashFactory() {
		auto m = ManagedCall("InkResponse", "splashFactory");
		m.put("this", this);
		shptr<class InteractiveInkFeatureFactory> result;
		m.call(result);
		return result;
	}

	bool /*var-non-null*/ InkResponse::enableFeedback() {
		auto m = ManagedCall("InkResponse", "enableFeedback");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	bool /*var-non-null*/ InkResponse::excludeFromSemantics() {
		auto m = ManagedCall("InkResponse", "excludeFromSemantics");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	bool /*var-non-null*/ InkResponse::autofocus() {
		auto m = ManagedCall("InkResponse", "autofocus");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class FocusNode> /*var-nullable*/ InkResponse::focusNode() {
		auto m = ManagedCall("InkResponse", "focusNode");
		m.put("this", this);
		shptr<class FocusNode> result;
		m.call(result);
		return result;
	}

	bool /*var-non-null*/ InkResponse::canRequestFocus() {
		auto m = ManagedCall("InkResponse", "canRequestFocus");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class MaterialStatesController> /*var-nullable*/ InkResponse::statesController() {
		auto m = ManagedCall("InkResponse", "statesController");
		m.put("this", this);
		shptr<class MaterialStatesController> result;
		m.call(result);
		return result;
	}

	shptr<class InkResponse> /*non-null*/ InkResponse::ctorMain(_ctorMain p) {
		auto m = ManagedCall("InkResponse", "InkResponse");
		m.put("key", p.key);
		m.put("child", p.child);
		m.put("onTap", p.onTap);
		m.put("onTapDown", p.onTapDown);
		m.put("onTapUp", p.onTapUp);
		m.put("onTapCancel", p.onTapCancel);
		m.put("onDoubleTap", p.onDoubleTap);
		m.put("onLongPress", p.onLongPress);
		m.put("onSecondaryTap", p.onSecondaryTap);
		m.put("onSecondaryTapUp", p.onSecondaryTapUp);
		m.put("onSecondaryTapDown", p.onSecondaryTapDown);
		m.put("onSecondaryTapCancel", p.onSecondaryTapCancel);
		m.put("onHighlightChanged", p.onHighlightChanged);
		m.put("onHover", p.onHover);
		m.put("mouseCursor", p.mouseCursor);
		m.put("containedInkWell", p.containedInkWell);
		m.put("highlightShape", p.highlightShape);
		m.put("radius", p.radius);
		m.put("borderRadius", p.borderRadius);
		m.put("customBorder", p.customBorder);
		m.put("focusColor", p.focusColor);
		m.put("hoverColor", p.hoverColor);
		m.put("highlightColor", p.highlightColor);
		m.put("overlayColor", p.overlayColor);
		m.put("splashColor", p.splashColor);
		m.put("splashFactory", p.splashFactory);
		m.put("enableFeedback", p.enableFeedback);
		m.put("excludeFromSemantics", p.excludeFromSemantics);
		m.put("focusNode", p.focusNode);
		m.put("canRequestFocus", p.canRequestFocus);
		m.put("onFocusChange", p.onFocusChange);
		m.put("autofocus", p.autofocus);
		m.put("statesController", p.statesController);
		shptr<class InkResponse> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class InkWell> /*non-null*/ InkWell::ctorMain(_ctorMain p) {
		auto m = ManagedCall("InkWell", "InkWell");
		m.put("key", p.key);
		m.put("child", p.child);
		m.put("onTap", p.onTap);
		m.put("onDoubleTap", p.onDoubleTap);
		m.put("onLongPress", p.onLongPress);
		m.put("onTapDown", p.onTapDown);
		m.put("onTapUp", p.onTapUp);
		m.put("onTapCancel", p.onTapCancel);
		m.put("onSecondaryTap", p.onSecondaryTap);
		m.put("onSecondaryTapUp", p.onSecondaryTapUp);
		m.put("onSecondaryTapDown", p.onSecondaryTapDown);
		m.put("onSecondaryTapCancel", p.onSecondaryTapCancel);
		m.put("onHighlightChanged", p.onHighlightChanged);
		m.put("onHover", p.onHover);
		m.put("mouseCursor", p.mouseCursor);
		m.put("focusColor", p.focusColor);
		m.put("hoverColor", p.hoverColor);
		m.put("highlightColor", p.highlightColor);
		m.put("overlayColor", p.overlayColor);
		m.put("splashColor", p.splashColor);
		m.put("splashFactory", p.splashFactory);
		m.put("radius", p.radius);
		m.put("borderRadius", p.borderRadius);
		m.put("customBorder", p.customBorder);
		m.put("enableFeedback", p.enableFeedback);
		m.put("excludeFromSemantics", p.excludeFromSemantics);
		m.put("focusNode", p.focusNode);
		m.put("canRequestFocus", p.canRequestFocus);
		m.put("onFocusChange", p.onFocusChange);
		m.put("autofocus", p.autofocus);
		m.put("statesController", p.statesController);
		shptr<class InkWell> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Widget> /*var-nullable*/ Ink::child() {
		auto m = ManagedCall("Ink", "child");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	shptr<class EdgeInsetsGeometry> /*var-nullable*/ Ink::padding() {
		auto m = ManagedCall("Ink", "padding");
		m.put("this", this);
		shptr<class EdgeInsetsGeometry> result;
		m.call(result);
		return result;
	}

	shptr<class Decoration> /*var-nullable*/ Ink::decoration() {
		auto m = ManagedCall("Ink", "decoration");
		m.put("this", this);
		shptr<class Decoration> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ Ink::width() {
		auto m = ManagedCall("Ink", "width");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ Ink::height() {
		auto m = ManagedCall("Ink", "height");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	shptr<class Ink> /*non-null*/ Ink::ctorMain(_ctorMain p) {
		auto m = ManagedCall("Ink", "Ink");
		m.put("key", p.key);
		m.put("padding", p.padding);
		m.put("color", p.color);
		m.put("decoration", p.decoration);
		m.put("width", p.width);
		m.put("height", p.height);
		m.put("child", p.child);
		shptr<class Ink> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Ink> /*non-null*/ Ink::image(_image p) {
		auto m = ManagedCall("Ink", "image");
		m.put("key", p.key);
		m.put("padding", p.padding);
		m.put("image", p.image, true);
		m.put("onImageError", p.onImageError);
		m.put("colorFilter", p.colorFilter);
		m.put("fit", p.fit);
		m.put("alignment", p.alignment, true);
		m.put("centerSlice", p.centerSlice);
		m.put("repeat", p.repeat);
		m.put("matchTextDirection", p.matchTextDirection);
		m.put("width", p.width);
		m.put("height", p.height);
		m.put("child", p.child);
		shptr<class Ink> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class VisualDensity> /*var-nullable*/ ButtonStyle::visualDensity() {
		auto m = ManagedCall("ButtonStyle", "visualDensity");
		m.put("this", this);
		shptr<class VisualDensity> result;
		m.call(result);
		return result;
	}

	stdop<MaterialTapTargetSize> /*var-nullable*/ ButtonStyle::tapTargetSize() {
		auto m = ManagedCall("ButtonStyle", "tapTargetSize");
		m.put("this", this);
		stdop<MaterialTapTargetSize> result;
		m.call(result);
		return result;
	}

	shptr<class Duration> /*var-nullable*/ ButtonStyle::animationDuration() {
		auto m = ManagedCall("ButtonStyle", "animationDuration");
		m.put("this", this);
		shptr<class Duration> result;
		m.call(result);
		return result;
	}

	stdop<bool> /*var-nullable*/ ButtonStyle::enableFeedback() {
		auto m = ManagedCall("ButtonStyle", "enableFeedback");
		m.put("this", this);
		stdop<bool> result;
		m.call(result);
		return result;
	}

	shptr<class AlignmentGeometry> /*var-nullable*/ ButtonStyle::alignment() {
		auto m = ManagedCall("ButtonStyle", "alignment");
		m.put("this", this);
		shptr<class AlignmentGeometry> result;
		m.call(result);
		return result;
	}

	shptr<class InteractiveInkFeatureFactory> /*var-nullable*/ ButtonStyle::splashFactory() {
		auto m = ManagedCall("ButtonStyle", "splashFactory");
		m.put("this", this);
		shptr<class InteractiveInkFeatureFactory> result;
		m.call(result);
		return result;
	}

	shptr<class ButtonStyle> /*non-null*/ ButtonStyle::copyWith(_copyWith p) {
		auto m = ManagedCall("ButtonStyle", "copyWith");
		m.put("this", this);
		m.put("textStyle", p.textStyle);
		m.put("backgroundColor", p.backgroundColor);
		m.put("foregroundColor", p.foregroundColor);
		m.put("overlayColor", p.overlayColor);
		m.put("shadowColor", p.shadowColor);
		m.put("surfaceTintColor", p.surfaceTintColor);
		m.put("elevation", p.elevation);
		m.put("padding", p.padding);
		m.put("minimumSize", p.minimumSize);
		m.put("fixedSize", p.fixedSize);
		m.put("maximumSize", p.maximumSize);
		m.put("iconColor", p.iconColor);
		m.put("iconSize", p.iconSize);
		m.put("side", p.side);
		m.put("shape", p.shape);
		m.put("mouseCursor", p.mouseCursor);
		m.put("visualDensity", p.visualDensity);
		m.put("tapTargetSize", p.tapTargetSize);
		m.put("animationDuration", p.animationDuration);
		m.put("enableFeedback", p.enableFeedback);
		m.put("alignment", p.alignment);
		m.put("splashFactory", p.splashFactory);
		shptr<class ButtonStyle> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ButtonStyle> /*non-null*/ ButtonStyle::merge(/*nullable*/ shptr<class ButtonStyle> style) {
		auto m = ManagedCall("ButtonStyle", "merge");
		m.put("this", this);
		m.put("style", style);
		shptr<class ButtonStyle> result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ ButtonStyle::equals(/*non-null*/ shptr<class ObjBase> other) {
		auto m = ManagedCall("ButtonStyle", "==");
		m.put("this", this);
		m.put("other", other, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ButtonStyle> /*nullable*/ ButtonStyle::lerp(/*nullable*/ shptr<class ButtonStyle> a, /*nullable*/ shptr<class ButtonStyle> b, /*non-null*/ double t) {
		auto m = ManagedCall("ButtonStyle", "lerp");
		m.put("a", a);
		m.put("b", b);
		m.put("t", t);
		shptr<class ButtonStyle> result;
		m.call(result);
		return result;
	}

	shptr<class ButtonStyle> /*non-null*/ ButtonStyle::ctorMain(_ctorMain p) {
		auto m = ManagedCall("ButtonStyle", "ButtonStyle");
		m.put("textStyle", p.textStyle);
		m.put("backgroundColor", p.backgroundColor);
		m.put("foregroundColor", p.foregroundColor);
		m.put("overlayColor", p.overlayColor);
		m.put("shadowColor", p.shadowColor);
		m.put("surfaceTintColor", p.surfaceTintColor);
		m.put("elevation", p.elevation);
		m.put("padding", p.padding);
		m.put("minimumSize", p.minimumSize);
		m.put("fixedSize", p.fixedSize);
		m.put("maximumSize", p.maximumSize);
		m.put("iconColor", p.iconColor);
		m.put("iconSize", p.iconSize);
		m.put("side", p.side);
		m.put("shape", p.shape);
		m.put("mouseCursor", p.mouseCursor);
		m.put("visualDensity", p.visualDensity);
		m.put("tapTargetSize", p.tapTargetSize);
		m.put("animationDuration", p.animationDuration);
		m.put("enableFeedback", p.enableFeedback);
		m.put("alignment", p.alignment);
		m.put("splashFactory", p.splashFactory);
		shptr<class ButtonStyle> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class ButtonStyle> /*non-null*/ TextButton::styleFrom(_styleFrom p) {
		auto m = ManagedCall("TextButton", "styleFrom");
		m.put("foregroundColor", p.foregroundColor);
		m.put("backgroundColor", p.backgroundColor);
		m.put("disabledForegroundColor", p.disabledForegroundColor);
		m.put("disabledBackgroundColor", p.disabledBackgroundColor);
		m.put("shadowColor", p.shadowColor);
		m.put("surfaceTintColor", p.surfaceTintColor);
		m.put("iconColor", p.iconColor);
		m.put("disabledIconColor", p.disabledIconColor);
		m.put("elevation", p.elevation);
		m.put("textStyle", p.textStyle);
		m.put("padding", p.padding);
		m.put("minimumSize", p.minimumSize);
		m.put("fixedSize", p.fixedSize);
		m.put("maximumSize", p.maximumSize);
		m.put("side", p.side);
		m.put("shape", p.shape);
		m.put("enabledMouseCursor", p.enabledMouseCursor);
		m.put("disabledMouseCursor", p.disabledMouseCursor);
		m.put("visualDensity", p.visualDensity);
		m.put("tapTargetSize", p.tapTargetSize);
		m.put("animationDuration", p.animationDuration);
		m.put("enableFeedback", p.enableFeedback);
		m.put("alignment", p.alignment);
		m.put("splashFactory", p.splashFactory);
		m.put("primary", p.primary);
		m.put("onSurface", p.onSurface);
		shptr<class ButtonStyle> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ButtonStyle> /*non-null*/ TextButton::defaultStyleOf(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("TextButton", "defaultStyleOf");
		m.put("this", this);
		m.put("context", context, true);
		shptr<class ButtonStyle> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ButtonStyle> /*nullable*/ TextButton::themeStyleOf(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("TextButton", "themeStyleOf");
		m.put("this", this);
		m.put("context", context, true);
		shptr<class ButtonStyle> result;
		m.call(result);
		return result;
	}

	shptr<class TextButton> /*non-null*/ TextButton::ctorMain(_ctorMain p) {
		auto m = ManagedCall("TextButton", "TextButton");
		m.put("key", p.key);
		m.put("onPressed", p.onPressed);
		m.put("onLongPress", p.onLongPress);
		m.put("onHover", p.onHover);
		m.put("onFocusChange", p.onFocusChange);
		m.put("style", p.style);
		m.put("focusNode", p.focusNode);
		m.put("autofocus", p.autofocus);
		m.put("clipBehavior", p.clipBehavior);
		m.put("statesController", p.statesController);
		m.put("isSemanticButton", p.isSemanticButton);
		m.put("child", p.child, true);
		shptr<class TextButton> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class TextButton> /*non-null*/ TextButton::icon(_icon p) {
		auto m = ManagedCall("TextButton", "icon");
		m.put("key", p.key);
		m.put("onPressed", p.onPressed);
		m.put("onLongPress", p.onLongPress);
		m.put("onHover", p.onHover);
		m.put("onFocusChange", p.onFocusChange);
		m.put("style", p.style);
		m.put("focusNode", p.focusNode);
		m.put("autofocus", p.autofocus);
		m.put("clipBehavior", p.clipBehavior);
		m.put("statesController", p.statesController);
		m.put("icon", p.icon, true);
		m.put("label", p.label, true);
		shptr<class TextButton> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Widget> /*var-nullable*/ Material::child() {
		auto m = ManagedCall("Material", "child");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	MaterialType /*var-non-null*/ Material::type() {
		auto m = ManagedCall("Material", "type");
		m.put("this", this);
		MaterialType result;
		m.check(m.call(result));
		return result;
	}

	double /*var-non-null*/ Material::elevation() {
		auto m = ManagedCall("Material", "elevation");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*var-nullable*/ Material::color() {
		auto m = ManagedCall("Material", "color");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ Material::shadowColor() {
		auto m = ManagedCall("Material", "shadowColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ Material::surfaceTintColor() {
		auto m = ManagedCall("Material", "surfaceTintColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class TextStyle> /*var-nullable*/ Material::textStyle() {
		auto m = ManagedCall("Material", "textStyle");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.call(result);
		return result;
	}

	shptr<class ShapeBorder> /*var-nullable*/ Material::shape() {
		auto m = ManagedCall("Material", "shape");
		m.put("this", this);
		shptr<class ShapeBorder> result;
		m.call(result);
		return result;
	}

	bool /*var-non-null*/ Material::borderOnForeground() {
		auto m = ManagedCall("Material", "borderOnForeground");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	Clip /*var-non-null*/ Material::clipBehavior() {
		auto m = ManagedCall("Material", "clipBehavior");
		m.put("this", this);
		Clip result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Duration> /*var-non-null*/ Material::animationDuration() {
		auto m = ManagedCall("Material", "animationDuration");
		m.put("this", this);
		shptr<class Duration> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class BorderRadiusGeometry> /*var-nullable*/ Material::borderRadius() {
		auto m = ManagedCall("Material", "borderRadius");
		m.put("this", this);
		shptr<class BorderRadiusGeometry> result;
		m.call(result);
		return result;
	}

	double /*var-non-null*/ Material::defaultSplashRadius() {
		auto m = ManagedCall("Material", "defaultSplashRadius");
		double result;
		m.check(m.call(result));
		return result;
	}

	shptr<class MaterialInkController> /*nullable*/ Material::maybeOf(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("Material", "maybeOf");
		m.put("context", context, true);
		shptr<class MaterialInkController> result;
		m.call(result);
		return result;
	}

	shptr<class MaterialInkController> /*non-null*/ Material::of(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("Material", "of");
		m.put("context", context, true);
		shptr<class MaterialInkController> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Material> /*non-null*/ Material::ctorMain(_ctorMain p) {
		auto m = ManagedCall("Material", "Material");
		m.put("key", p.key);
		m.put("type", p.type);
		m.put("elevation", p.elevation);
		m.put("color", p.color);
		m.put("shadowColor", p.shadowColor);
		m.put("surfaceTintColor", p.surfaceTintColor);
		m.put("textStyle", p.textStyle);
		m.put("borderRadius", p.borderRadius);
		m.put("shape", p.shape);
		m.put("borderOnForeground", p.borderOnForeground);
		m.put("clipBehavior", p.clipBehavior);
		m.put("animationDuration", p.animationDuration, true);
		m.put("child", p.child);
		shptr<class Material> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class MouseCursor> /*var-nullable*/ MaterialButton::mouseCursor() {
		auto m = ManagedCall("MaterialButton", "mouseCursor");
		m.put("this", this);
		shptr<class MouseCursor> result;
		m.call(result);
		return result;
	}

	stdop<ButtonTextTheme> /*var-nullable*/ MaterialButton::textTheme() {
		auto m = ManagedCall("MaterialButton", "textTheme");
		m.put("this", this);
		stdop<ButtonTextTheme> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ MaterialButton::textColor() {
		auto m = ManagedCall("MaterialButton", "textColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ MaterialButton::disabledTextColor() {
		auto m = ManagedCall("MaterialButton", "disabledTextColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ MaterialButton::color() {
		auto m = ManagedCall("MaterialButton", "color");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ MaterialButton::disabledColor() {
		auto m = ManagedCall("MaterialButton", "disabledColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ MaterialButton::splashColor() {
		auto m = ManagedCall("MaterialButton", "splashColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ MaterialButton::focusColor() {
		auto m = ManagedCall("MaterialButton", "focusColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ MaterialButton::hoverColor() {
		auto m = ManagedCall("MaterialButton", "hoverColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ MaterialButton::highlightColor() {
		auto m = ManagedCall("MaterialButton", "highlightColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ MaterialButton::elevation() {
		auto m = ManagedCall("MaterialButton", "elevation");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ MaterialButton::hoverElevation() {
		auto m = ManagedCall("MaterialButton", "hoverElevation");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ MaterialButton::focusElevation() {
		auto m = ManagedCall("MaterialButton", "focusElevation");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ MaterialButton::highlightElevation() {
		auto m = ManagedCall("MaterialButton", "highlightElevation");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ MaterialButton::disabledElevation() {
		auto m = ManagedCall("MaterialButton", "disabledElevation");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	stdop<Brightness> /*var-nullable*/ MaterialButton::colorBrightness() {
		auto m = ManagedCall("MaterialButton", "colorBrightness");
		m.put("this", this);
		stdop<Brightness> result;
		m.call(result);
		return result;
	}

	shptr<class Widget> /*var-nullable*/ MaterialButton::child() {
		auto m = ManagedCall("MaterialButton", "child");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	shptr<class EdgeInsetsGeometry> /*var-nullable*/ MaterialButton::padding() {
		auto m = ManagedCall("MaterialButton", "padding");
		m.put("this", this);
		shptr<class EdgeInsetsGeometry> result;
		m.call(result);
		return result;
	}

	shptr<class VisualDensity> /*var-nullable*/ MaterialButton::visualDensity() {
		auto m = ManagedCall("MaterialButton", "visualDensity");
		m.put("this", this);
		shptr<class VisualDensity> result;
		m.call(result);
		return result;
	}

	shptr<class ShapeBorder> /*var-nullable*/ MaterialButton::shape() {
		auto m = ManagedCall("MaterialButton", "shape");
		m.put("this", this);
		shptr<class ShapeBorder> result;
		m.call(result);
		return result;
	}

	Clip /*var-non-null*/ MaterialButton::clipBehavior() {
		auto m = ManagedCall("MaterialButton", "clipBehavior");
		m.put("this", this);
		Clip result;
		m.check(m.call(result));
		return result;
	}

	shptr<class FocusNode> /*var-nullable*/ MaterialButton::focusNode() {
		auto m = ManagedCall("MaterialButton", "focusNode");
		m.put("this", this);
		shptr<class FocusNode> result;
		m.call(result);
		return result;
	}

	bool /*var-non-null*/ MaterialButton::autofocus() {
		auto m = ManagedCall("MaterialButton", "autofocus");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Duration> /*var-nullable*/ MaterialButton::animationDuration() {
		auto m = ManagedCall("MaterialButton", "animationDuration");
		m.put("this", this);
		shptr<class Duration> result;
		m.call(result);
		return result;
	}

	stdop<MaterialTapTargetSize> /*var-nullable*/ MaterialButton::materialTapTargetSize() {
		auto m = ManagedCall("MaterialButton", "materialTapTargetSize");
		m.put("this", this);
		stdop<MaterialTapTargetSize> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ MaterialButton::minWidth() {
		auto m = ManagedCall("MaterialButton", "minWidth");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ MaterialButton::height() {
		auto m = ManagedCall("MaterialButton", "height");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	bool /*var-non-null*/ MaterialButton::enableFeedback() {
		auto m = ManagedCall("MaterialButton", "enableFeedback");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	bool /*get-non-null*/ MaterialButton::enabled() {
		auto m = ManagedCall("MaterialButton", "enabled");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class MaterialButton> /*non-null*/ MaterialButton::ctorMain(_ctorMain p) {
		auto m = ManagedCall("MaterialButton", "MaterialButton");
		m.put("key", p.key);
		m.put("onPressed", p.onPressed);
		m.put("onLongPress", p.onLongPress);
		m.put("onHighlightChanged", p.onHighlightChanged);
		m.put("mouseCursor", p.mouseCursor);
		m.put("textTheme", p.textTheme);
		m.put("textColor", p.textColor);
		m.put("disabledTextColor", p.disabledTextColor);
		m.put("color", p.color);
		m.put("disabledColor", p.disabledColor);
		m.put("focusColor", p.focusColor);
		m.put("hoverColor", p.hoverColor);
		m.put("highlightColor", p.highlightColor);
		m.put("splashColor", p.splashColor);
		m.put("colorBrightness", p.colorBrightness);
		m.put("elevation", p.elevation);
		m.put("focusElevation", p.focusElevation);
		m.put("hoverElevation", p.hoverElevation);
		m.put("highlightElevation", p.highlightElevation);
		m.put("disabledElevation", p.disabledElevation);
		m.put("padding", p.padding);
		m.put("visualDensity", p.visualDensity);
		m.put("shape", p.shape);
		m.put("clipBehavior", p.clipBehavior);
		m.put("focusNode", p.focusNode);
		m.put("autofocus", p.autofocus);
		m.put("materialTapTargetSize", p.materialTapTargetSize);
		m.put("animationDuration", p.animationDuration);
		m.put("minWidth", p.minWidth);
		m.put("height", p.height);
		m.put("enableFeedback", p.enableFeedback);
		m.put("child", p.child);
		shptr<class MaterialButton> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Widget> /*var-nullable*/ CircleAvatar::child() {
		auto m = ManagedCall("CircleAvatar", "child");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ CircleAvatar::backgroundColor() {
		auto m = ManagedCall("CircleAvatar", "backgroundColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ CircleAvatar::foregroundColor() {
		auto m = ManagedCall("CircleAvatar", "foregroundColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ CircleAvatar::radius() {
		auto m = ManagedCall("CircleAvatar", "radius");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ CircleAvatar::minRadius() {
		auto m = ManagedCall("CircleAvatar", "minRadius");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ CircleAvatar::maxRadius() {
		auto m = ManagedCall("CircleAvatar", "maxRadius");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	shptr<class CircleAvatar> /*non-null*/ CircleAvatar::ctorMain(_ctorMain p) {
		auto m = ManagedCall("CircleAvatar", "CircleAvatar");
		m.put("key", p.key);
		m.put("child", p.child);
		m.put("backgroundColor", p.backgroundColor);
		m.put("backgroundImage", p.backgroundImage);
		m.put("foregroundImage", p.foregroundImage);
		m.put("onBackgroundImageError", p.onBackgroundImageError);
		m.put("onForegroundImageError", p.onForegroundImageError);
		m.put("foregroundColor", p.foregroundColor);
		m.put("radius", p.radius);
		m.put("minRadius", p.minRadius);
		m.put("maxRadius", p.maxRadius);
		shptr<class CircleAvatar> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Color> /*var-nullable*/ Card::color() {
		auto m = ManagedCall("Card", "color");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ Card::shadowColor() {
		auto m = ManagedCall("Card", "shadowColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ Card::surfaceTintColor() {
		auto m = ManagedCall("Card", "surfaceTintColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ Card::elevation() {
		auto m = ManagedCall("Card", "elevation");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	shptr<class ShapeBorder> /*var-nullable*/ Card::shape() {
		auto m = ManagedCall("Card", "shape");
		m.put("this", this);
		shptr<class ShapeBorder> result;
		m.call(result);
		return result;
	}

	bool /*var-non-null*/ Card::borderOnForeground() {
		auto m = ManagedCall("Card", "borderOnForeground");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	stdop<Clip> /*var-nullable*/ Card::clipBehavior() {
		auto m = ManagedCall("Card", "clipBehavior");
		m.put("this", this);
		stdop<Clip> result;
		m.call(result);
		return result;
	}

	shptr<class EdgeInsetsGeometry> /*var-nullable*/ Card::margin() {
		auto m = ManagedCall("Card", "margin");
		m.put("this", this);
		shptr<class EdgeInsetsGeometry> result;
		m.call(result);
		return result;
	}

	bool /*var-non-null*/ Card::semanticContainer() {
		auto m = ManagedCall("Card", "semanticContainer");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Widget> /*var-nullable*/ Card::child() {
		auto m = ManagedCall("Card", "child");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	shptr<class Card> /*non-null*/ Card::ctorMain(_ctorMain p) {
		auto m = ManagedCall("Card", "Card");
		m.put("key", p.key);
		m.put("color", p.color);
		m.put("shadowColor", p.shadowColor);
		m.put("surfaceTintColor", p.surfaceTintColor);
		m.put("elevation", p.elevation);
		m.put("shape", p.shape);
		m.put("borderOnForeground", p.borderOnForeground);
		m.put("margin", p.margin);
		m.put("clipBehavior", p.clipBehavior);
		m.put("child", p.child);
		m.put("semanticContainer", p.semanticContainer);
		shptr<class Card> result;
		m.check(m.call(result, true));
		return result;
	}

	stdop<bool> /*var-nullable*/ Checkbox::value() {
		auto m = ManagedCall("Checkbox", "value");
		m.put("this", this);
		stdop<bool> result;
		m.call(result);
		return result;
	}

	shptr<class MouseCursor> /*var-nullable*/ Checkbox::mouseCursor() {
		auto m = ManagedCall("Checkbox", "mouseCursor");
		m.put("this", this);
		shptr<class MouseCursor> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ Checkbox::activeColor() {
		auto m = ManagedCall("Checkbox", "activeColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ Checkbox::checkColor() {
		auto m = ManagedCall("Checkbox", "checkColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	bool /*var-non-null*/ Checkbox::tristate() {
		auto m = ManagedCall("Checkbox", "tristate");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	stdop<MaterialTapTargetSize> /*var-nullable*/ Checkbox::materialTapTargetSize() {
		auto m = ManagedCall("Checkbox", "materialTapTargetSize");
		m.put("this", this);
		stdop<MaterialTapTargetSize> result;
		m.call(result);
		return result;
	}

	shptr<class VisualDensity> /*var-nullable*/ Checkbox::visualDensity() {
		auto m = ManagedCall("Checkbox", "visualDensity");
		m.put("this", this);
		shptr<class VisualDensity> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ Checkbox::focusColor() {
		auto m = ManagedCall("Checkbox", "focusColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ Checkbox::hoverColor() {
		auto m = ManagedCall("Checkbox", "hoverColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ Checkbox::splashRadius() {
		auto m = ManagedCall("Checkbox", "splashRadius");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	shptr<class FocusNode> /*var-nullable*/ Checkbox::focusNode() {
		auto m = ManagedCall("Checkbox", "focusNode");
		m.put("this", this);
		shptr<class FocusNode> result;
		m.call(result);
		return result;
	}

	bool /*var-non-null*/ Checkbox::autofocus() {
		auto m = ManagedCall("Checkbox", "autofocus");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class OutlinedBorder> /*var-nullable*/ Checkbox::shape() {
		auto m = ManagedCall("Checkbox", "shape");
		m.put("this", this);
		shptr<class OutlinedBorder> result;
		m.call(result);
		return result;
	}

	shptr<class BorderSide> /*var-nullable*/ Checkbox::side() {
		auto m = ManagedCall("Checkbox", "side");
		m.put("this", this);
		shptr<class BorderSide> result;
		m.call(result);
		return result;
	}

	bool /*var-non-null*/ Checkbox::isError() {
		auto m = ManagedCall("Checkbox", "isError");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	stdop<stdstr> /*var-nullable*/ Checkbox::semanticLabel() {
		auto m = ManagedCall("Checkbox", "semanticLabel");
		m.put("this", this);
		stdop<stdstr> result;
		m.call(result);
		return result;
	}

	double /*var-non-null*/ Checkbox::width() {
		auto m = ManagedCall("Checkbox", "width");
		double result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Checkbox> /*non-null*/ Checkbox::ctorMain(_ctorMain p) {
		auto m = ManagedCall("Checkbox", "Checkbox");
		m.put("key", p.key);
		m.put("value", p.value);
		m.put("tristate", p.tristate);
		m.put("onChanged", p.onChanged);
		m.put("mouseCursor", p.mouseCursor);
		m.put("activeColor", p.activeColor);
		m.put("fillColor", p.fillColor);
		m.put("checkColor", p.checkColor);
		m.put("focusColor", p.focusColor);
		m.put("hoverColor", p.hoverColor);
		m.put("overlayColor", p.overlayColor);
		m.put("splashRadius", p.splashRadius);
		m.put("materialTapTargetSize", p.materialTapTargetSize);
		m.put("visualDensity", p.visualDensity);
		m.put("focusNode", p.focusNode);
		m.put("autofocus", p.autofocus);
		m.put("shape", p.shape);
		m.put("side", p.side);
		m.put("isError", p.isError);
		m.put("semanticLabel", p.semanticLabel);
		shptr<class Checkbox> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Checkbox> /*non-null*/ Checkbox::adaptive(_adaptive p) {
		auto m = ManagedCall("Checkbox", "adaptive");
		m.put("key", p.key);
		m.put("value", p.value);
		m.put("tristate", p.tristate);
		m.put("onChanged", p.onChanged);
		m.put("mouseCursor", p.mouseCursor);
		m.put("activeColor", p.activeColor);
		m.put("fillColor", p.fillColor);
		m.put("checkColor", p.checkColor);
		m.put("focusColor", p.focusColor);
		m.put("hoverColor", p.hoverColor);
		m.put("overlayColor", p.overlayColor);
		m.put("splashRadius", p.splashRadius);
		m.put("materialTapTargetSize", p.materialTapTargetSize);
		m.put("visualDensity", p.visualDensity);
		m.put("focusNode", p.focusNode);
		m.put("autofocus", p.autofocus);
		m.put("shape", p.shape);
		m.put("side", p.side);
		m.put("isError", p.isError);
		m.put("semanticLabel", p.semanticLabel);
		shptr<class Checkbox> result;
		m.check(m.call(result, true));
		return result;
	}

	int64 /*var-non-null*/ Radio::value() {
		auto m = ManagedCall("Radio", "value");
		m.put("this", this);
		int64 result;
		m.check(m.call(result));
		return result;
	}

	stdop<int64> /*var-nullable*/ Radio::groupValue() {
		auto m = ManagedCall("Radio", "groupValue");
		m.put("this", this);
		stdop<int64> result;
		m.call(result);
		return result;
	}

	shptr<class MouseCursor> /*var-nullable*/ Radio::mouseCursor() {
		auto m = ManagedCall("Radio", "mouseCursor");
		m.put("this", this);
		shptr<class MouseCursor> result;
		m.call(result);
		return result;
	}

	bool /*var-non-null*/ Radio::toggleable() {
		auto m = ManagedCall("Radio", "toggleable");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*var-nullable*/ Radio::activeColor() {
		auto m = ManagedCall("Radio", "activeColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	stdop<MaterialTapTargetSize> /*var-nullable*/ Radio::materialTapTargetSize() {
		auto m = ManagedCall("Radio", "materialTapTargetSize");
		m.put("this", this);
		stdop<MaterialTapTargetSize> result;
		m.call(result);
		return result;
	}

	shptr<class VisualDensity> /*var-nullable*/ Radio::visualDensity() {
		auto m = ManagedCall("Radio", "visualDensity");
		m.put("this", this);
		shptr<class VisualDensity> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ Radio::focusColor() {
		auto m = ManagedCall("Radio", "focusColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ Radio::hoverColor() {
		auto m = ManagedCall("Radio", "hoverColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ Radio::splashRadius() {
		auto m = ManagedCall("Radio", "splashRadius");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	shptr<class FocusNode> /*var-nullable*/ Radio::focusNode() {
		auto m = ManagedCall("Radio", "focusNode");
		m.put("this", this);
		shptr<class FocusNode> result;
		m.call(result);
		return result;
	}

	bool /*var-non-null*/ Radio::autofocus() {
		auto m = ManagedCall("Radio", "autofocus");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	bool /*var-non-null*/ Radio::useCupertinoCheckmarkStyle() {
		auto m = ManagedCall("Radio", "useCupertinoCheckmarkStyle");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Radio> /*non-null*/ Radio::ctorMain(_ctorMain p) {
		auto m = ManagedCall("Radio", "Radio");
		m.put("key", p.key);
		m.put("value", p.value);
		m.put("groupValue", p.groupValue);
		m.put("onChanged", p.onChanged);
		m.put("mouseCursor", p.mouseCursor);
		m.put("toggleable", p.toggleable);
		m.put("activeColor", p.activeColor);
		m.put("fillColor", p.fillColor);
		m.put("focusColor", p.focusColor);
		m.put("hoverColor", p.hoverColor);
		m.put("overlayColor", p.overlayColor);
		m.put("splashRadius", p.splashRadius);
		m.put("materialTapTargetSize", p.materialTapTargetSize);
		m.put("visualDensity", p.visualDensity);
		m.put("focusNode", p.focusNode);
		m.put("autofocus", p.autofocus);
		shptr<class Radio> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Radio> /*non-null*/ Radio::adaptive(_adaptive p) {
		auto m = ManagedCall("Radio", "adaptive");
		m.put("key", p.key);
		m.put("value", p.value);
		m.put("groupValue", p.groupValue);
		m.put("onChanged", p.onChanged);
		m.put("mouseCursor", p.mouseCursor);
		m.put("toggleable", p.toggleable);
		m.put("activeColor", p.activeColor);
		m.put("fillColor", p.fillColor);
		m.put("focusColor", p.focusColor);
		m.put("hoverColor", p.hoverColor);
		m.put("overlayColor", p.overlayColor);
		m.put("splashRadius", p.splashRadius);
		m.put("materialTapTargetSize", p.materialTapTargetSize);
		m.put("visualDensity", p.visualDensity);
		m.put("focusNode", p.focusNode);
		m.put("autofocus", p.autofocus);
		m.put("useCupertinoCheckmarkStyle", p.useCupertinoCheckmarkStyle);
		shptr<class Radio> result;
		m.check(m.call(result, true));
		return result;
	}

	double /*var-non-null*/ Slider::value() {
		auto m = ManagedCall("Slider", "value");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	stdop<double> /*var-nullable*/ Slider::secondaryTrackValue() {
		auto m = ManagedCall("Slider", "secondaryTrackValue");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	double /*var-non-null*/ Slider::minimal() {
		auto m = ManagedCall("Slider", "min");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	double /*var-non-null*/ Slider::maximal() {
		auto m = ManagedCall("Slider", "max");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	stdop<int64> /*var-nullable*/ Slider::divisions() {
		auto m = ManagedCall("Slider", "divisions");
		m.put("this", this);
		stdop<int64> result;
		m.call(result);
		return result;
	}

	stdop<stdstr> /*var-nullable*/ Slider::label() {
		auto m = ManagedCall("Slider", "label");
		m.put("this", this);
		stdop<stdstr> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ Slider::activeColor() {
		auto m = ManagedCall("Slider", "activeColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ Slider::inactiveColor() {
		auto m = ManagedCall("Slider", "inactiveColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ Slider::secondaryActiveColor() {
		auto m = ManagedCall("Slider", "secondaryActiveColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ Slider::thumbColor() {
		auto m = ManagedCall("Slider", "thumbColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class MouseCursor> /*var-nullable*/ Slider::mouseCursor() {
		auto m = ManagedCall("Slider", "mouseCursor");
		m.put("this", this);
		shptr<class MouseCursor> result;
		m.call(result);
		return result;
	}

	shptr<class FocusNode> /*var-nullable*/ Slider::focusNode() {
		auto m = ManagedCall("Slider", "focusNode");
		m.put("this", this);
		shptr<class FocusNode> result;
		m.call(result);
		return result;
	}

	bool /*var-non-null*/ Slider::autofocus() {
		auto m = ManagedCall("Slider", "autofocus");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	stdop<SliderInteraction> /*var-nullable*/ Slider::allowedInteraction() {
		auto m = ManagedCall("Slider", "allowedInteraction");
		m.put("this", this);
		stdop<SliderInteraction> result;
		m.call(result);
		return result;
	}

	shptr<class Slider> /*non-null*/ Slider::ctorMain(_ctorMain p) {
		auto m = ManagedCall("Slider", "Slider");
		m.put("key", p.key);
		m.put("value", p.value);
		m.put("secondaryTrackValue", p.secondaryTrackValue);
		m.put("onChanged", p.onChanged);
		m.put("onChangeStart", p.onChangeStart);
		m.put("onChangeEnd", p.onChangeEnd);
		m.put("min", p.min);
		m.put("max", p.max);
		m.put("divisions", p.divisions);
		m.put("label", p.label);
		m.put("activeColor", p.activeColor);
		m.put("inactiveColor", p.inactiveColor);
		m.put("secondaryActiveColor", p.secondaryActiveColor);
		m.put("thumbColor", p.thumbColor);
		m.put("overlayColor", p.overlayColor);
		m.put("mouseCursor", p.mouseCursor);
//		m.put("semanticFormatterCallback", p.semanticFormatterCallback);
		m.put("focusNode", p.focusNode);
		m.put("autofocus", p.autofocus);
		m.put("allowedInteraction", p.allowedInteraction);
		shptr<class Slider> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Slider> /*non-null*/ Slider::adaptive(_adaptive p) {
		auto m = ManagedCall("Slider", "adaptive");
		m.put("key", p.key);
		m.put("value", p.value);
		m.put("secondaryTrackValue", p.secondaryTrackValue);
		m.put("onChanged", p.onChanged);
		m.put("onChangeStart", p.onChangeStart);
		m.put("onChangeEnd", p.onChangeEnd);
		m.put("min", p.min);
		m.put("max", p.max);
		m.put("divisions", p.divisions);
		m.put("label", p.label);
		m.put("mouseCursor", p.mouseCursor);
		m.put("activeColor", p.activeColor);
		m.put("inactiveColor", p.inactiveColor);
		m.put("secondaryActiveColor", p.secondaryActiveColor);
		m.put("thumbColor", p.thumbColor);
		m.put("overlayColor", p.overlayColor);
//		m.put("semanticFormatterCallback", p.semanticFormatterCallback);
		m.put("focusNode", p.focusNode);
		m.put("autofocus", p.autofocus);
		m.put("allowedInteraction", p.allowedInteraction);
		shptr<class Slider> result;
		m.check(m.call(result, true));
		return result;
	}

	double /*var-non-null*/ RangeValues::start() {
		auto m = ManagedCall("RangeValues", "start");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	double /*var-non-null*/ RangeValues::end() {
		auto m = ManagedCall("RangeValues", "end");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ RangeValues::equals(/*non-null*/ shptr<class ObjBase> other) {
		auto m = ManagedCall("RangeValues", "==");
		m.put("this", this);
		m.put("other", other, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class RangeValues> /*non-null*/ RangeValues::ctorMain(/*non-null*/ double start, /*non-null*/ double end) {
		auto m = ManagedCall("RangeValues", "RangeValues");
		m.put("start", start);
		m.put("end", end);
		shptr<class RangeValues> result;
		m.check(m.call(result, true));
		return result;
	}

	stdstr /*var-non-null*/ RangeLabels::start() {
		auto m = ManagedCall("RangeLabels", "start");
		m.put("this", this);
		stdstr result;
		m.check(m.call(result));
		return result;
	}

	stdstr /*var-non-null*/ RangeLabels::end() {
		auto m = ManagedCall("RangeLabels", "end");
		m.put("this", this);
		stdstr result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ RangeLabels::equals(/*non-null*/ shptr<class ObjBase> other) {
		auto m = ManagedCall("RangeLabels", "==");
		m.put("this", this);
		m.put("other", other, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class RangeLabels> /*non-null*/ RangeLabels::ctorMain(/*non-null*/ stdstr start, /*non-null*/ stdstr end) {
		auto m = ManagedCall("RangeLabels", "RangeLabels");
		m.put("start", start);
		m.put("end", end);
		shptr<class RangeLabels> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class RangeValues> /*var-non-null*/ RangeSlider::values() {
		auto m = ManagedCall("RangeSlider", "values");
		m.put("this", this);
		shptr<class RangeValues> result;
		m.check(m.call(result));
		return result;
	}

	double /*var-non-null*/ RangeSlider::minimal() {
		auto m = ManagedCall("RangeSlider", "min");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	double /*var-non-null*/ RangeSlider::maximal() {
		auto m = ManagedCall("RangeSlider", "max");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	stdop<int64> /*var-nullable*/ RangeSlider::divisions() {
		auto m = ManagedCall("RangeSlider", "divisions");
		m.put("this", this);
		stdop<int64> result;
		m.call(result);
		return result;
	}

	shptr<class RangeLabels> /*var-nullable*/ RangeSlider::labels() {
		auto m = ManagedCall("RangeSlider", "labels");
		m.put("this", this);
		shptr<class RangeLabels> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ RangeSlider::activeColor() {
		auto m = ManagedCall("RangeSlider", "activeColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ RangeSlider::inactiveColor() {
		auto m = ManagedCall("RangeSlider", "inactiveColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class RangeSlider> /*non-null*/ RangeSlider::ctorMain(_ctorMain p) {
		auto m = ManagedCall("RangeSlider", "RangeSlider");
		m.put("key", p.key);
		m.put("values", p.values, true);
		m.put("onChanged", p.onChanged);
		m.put("onChangeStart", p.onChangeStart);
		m.put("onChangeEnd", p.onChangeEnd);
		m.put("min", p.min);
		m.put("max", p.max);
		m.put("divisions", p.divisions);
		m.put("labels", p.labels);
		m.put("activeColor", p.activeColor);
		m.put("inactiveColor", p.inactiveColor);
		m.put("overlayColor", p.overlayColor);
		m.put("mouseCursor", p.mouseCursor);
//		m.put("semanticFormatterCallback", p.semanticFormatterCallback);
		shptr<class RangeSlider> result;
		m.check(m.call(result, true));
		return result;
	}

	bool /*var-non-null*/ Switch::value() {
		auto m = ManagedCall("Switch", "value");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*var-nullable*/ Switch::activeColor() {
		auto m = ManagedCall("Switch", "activeColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ Switch::activeTrackColor() {
		auto m = ManagedCall("Switch", "activeTrackColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ Switch::inactiveThumbColor() {
		auto m = ManagedCall("Switch", "inactiveThumbColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ Switch::inactiveTrackColor() {
		auto m = ManagedCall("Switch", "inactiveTrackColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	stdop<MaterialTapTargetSize> /*var-nullable*/ Switch::materialTapTargetSize() {
		auto m = ManagedCall("Switch", "materialTapTargetSize");
		m.put("this", this);
		stdop<MaterialTapTargetSize> result;
		m.call(result);
		return result;
	}

	stdop<bool> /*var-nullable*/ Switch::applyCupertinoTheme() {
		auto m = ManagedCall("Switch", "applyCupertinoTheme");
		m.put("this", this);
		stdop<bool> result;
		m.call(result);
		return result;
	}

	DragStartBehavior /*var-non-null*/ Switch::dragStartBehavior() {
		auto m = ManagedCall("Switch", "dragStartBehavior");
		m.put("this", this);
		DragStartBehavior result;
		m.check(m.call(result));
		return result;
	}

	shptr<class MouseCursor> /*var-nullable*/ Switch::mouseCursor() {
		auto m = ManagedCall("Switch", "mouseCursor");
		m.put("this", this);
		shptr<class MouseCursor> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ Switch::focusColor() {
		auto m = ManagedCall("Switch", "focusColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ Switch::hoverColor() {
		auto m = ManagedCall("Switch", "hoverColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ Switch::splashRadius() {
		auto m = ManagedCall("Switch", "splashRadius");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	shptr<class FocusNode> /*var-nullable*/ Switch::focusNode() {
		auto m = ManagedCall("Switch", "focusNode");
		m.put("this", this);
		shptr<class FocusNode> result;
		m.call(result);
		return result;
	}

	bool /*var-non-null*/ Switch::autofocus() {
		auto m = ManagedCall("Switch", "autofocus");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Switch> /*non-null*/ Switch::ctorMain(_ctorMain p) {
		auto m = ManagedCall("Switch", "Switch");
		m.put("key", p.key);
		m.put("value", p.value);
		m.put("onChanged", p.onChanged);
		m.put("activeColor", p.activeColor);
		m.put("activeTrackColor", p.activeTrackColor);
		m.put("inactiveThumbColor", p.inactiveThumbColor);
		m.put("inactiveTrackColor", p.inactiveTrackColor);
		m.put("activeThumbImage", p.activeThumbImage);
//		m.put("onActiveThumbImageError", p.onActiveThumbImageError);
		m.put("inactiveThumbImage", p.inactiveThumbImage);
//		m.put("onInactiveThumbImageError", p.onInactiveThumbImageError);
		m.put("thumbColor", p.thumbColor);
		m.put("trackColor", p.trackColor);
		m.put("trackOutlineColor", p.trackOutlineColor);
		m.put("trackOutlineWidth", p.trackOutlineWidth);
		m.put("thumbIcon", p.thumbIcon);
		m.put("materialTapTargetSize", p.materialTapTargetSize);
		m.put("dragStartBehavior", p.dragStartBehavior);
		m.put("mouseCursor", p.mouseCursor);
		m.put("focusColor", p.focusColor);
		m.put("hoverColor", p.hoverColor);
		m.put("overlayColor", p.overlayColor);
		m.put("splashRadius", p.splashRadius);
		m.put("focusNode", p.focusNode);
		m.put("onFocusChange", p.onFocusChange);
		m.put("autofocus", p.autofocus);
		shptr<class Switch> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Switch> /*non-null*/ Switch::adaptive(_adaptive p) {
		auto m = ManagedCall("Switch", "adaptive");
		m.put("key", p.key);
		m.put("value", p.value);
		m.put("onChanged", p.onChanged);
		m.put("activeColor", p.activeColor);
		m.put("activeTrackColor", p.activeTrackColor);
		m.put("inactiveThumbColor", p.inactiveThumbColor);
		m.put("inactiveTrackColor", p.inactiveTrackColor);
		m.put("activeThumbImage", p.activeThumbImage);
//		m.put("onActiveThumbImageError", p.onActiveThumbImageError);
		m.put("inactiveThumbImage", p.inactiveThumbImage);
//		m.put("onInactiveThumbImageError", p.onInactiveThumbImageError);
		m.put("materialTapTargetSize", p.materialTapTargetSize);
		m.put("thumbColor", p.thumbColor);
		m.put("trackColor", p.trackColor);
		m.put("trackOutlineColor", p.trackOutlineColor);
		m.put("trackOutlineWidth", p.trackOutlineWidth);
		m.put("thumbIcon", p.thumbIcon);
		m.put("dragStartBehavior", p.dragStartBehavior);
		m.put("mouseCursor", p.mouseCursor);
		m.put("focusColor", p.focusColor);
		m.put("hoverColor", p.hoverColor);
		m.put("overlayColor", p.overlayColor);
		m.put("splashRadius", p.splashRadius);
		m.put("focusNode", p.focusNode);
		m.put("onFocusChange", p.onFocusChange);
		m.put("autofocus", p.autofocus);
		m.put("applyCupertinoTheme", p.applyCupertinoTheme);
		shptr<class Switch> result;
		m.check(m.call(result, true));
		return result;
	}

	bool /*get-non-null*/ ExpansionTileController::isExpanded() {
		auto m = ManagedCall("ExpansionTileController", "isExpanded");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	void ExpansionTileController::expand() {
		auto m = ManagedCall("ExpansionTileController", "expand");
		m.put("this", this);
		m.call();
	}

	void ExpansionTileController::collapse() {
		auto m = ManagedCall("ExpansionTileController", "collapse");
		m.put("this", this);
		m.call();
	}

	shptr<class ExpansionTileController> /*non-null*/ ExpansionTileController::of(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("ExpansionTileController", "of");
		m.put("context", context, true);
		shptr<class ExpansionTileController> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ExpansionTileController> /*nullable*/ ExpansionTileController::maybeOf(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("ExpansionTileController", "maybeOf");
		m.put("context", context, true);
		shptr<class ExpansionTileController> result;
		m.call(result);
		return result;
	}

	shptr<class ExpansionTileController> /*non-null*/ ExpansionTileController::ctorMain() {
		auto m = ManagedCall("ExpansionTileController", "ExpansionTileController");
		shptr<class ExpansionTileController> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Widget> /*var-nullable*/ ExpansionTile::leading() {
		auto m = ManagedCall("ExpansionTile", "leading");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	shptr<class Widget> /*var-non-null*/ ExpansionTile::title() {
		auto m = ManagedCall("ExpansionTile", "title");
		m.put("this", this);
		shptr<class Widget> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Widget> /*var-nullable*/ ExpansionTile::subtitle() {
		auto m = ManagedCall("ExpansionTile", "subtitle");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ ExpansionTile::backgroundColor() {
		auto m = ManagedCall("ExpansionTile", "backgroundColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ ExpansionTile::collapsedBackgroundColor() {
		auto m = ManagedCall("ExpansionTile", "collapsedBackgroundColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Widget> /*var-nullable*/ ExpansionTile::trailing() {
		auto m = ManagedCall("ExpansionTile", "trailing");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	bool /*var-non-null*/ ExpansionTile::initiallyExpanded() {
		auto m = ManagedCall("ExpansionTile", "initiallyExpanded");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	bool /*var-non-null*/ ExpansionTile::maintainState() {
		auto m = ManagedCall("ExpansionTile", "maintainState");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class EdgeInsetsGeometry> /*var-nullable*/ ExpansionTile::tilePadding() {
		auto m = ManagedCall("ExpansionTile", "tilePadding");
		m.put("this", this);
		shptr<class EdgeInsetsGeometry> result;
		m.call(result);
		return result;
	}

	shptr<class Alignment> /*var-nullable*/ ExpansionTile::expandedAlignment() {
		auto m = ManagedCall("ExpansionTile", "expandedAlignment");
		m.put("this", this);
		shptr<class Alignment> result;
		m.call(result);
		return result;
	}

	stdop<CrossAxisAlignment> /*var-nullable*/ ExpansionTile::expandedCrossAxisAlignment() {
		auto m = ManagedCall("ExpansionTile", "expandedCrossAxisAlignment");
		m.put("this", this);
		stdop<CrossAxisAlignment> result;
		m.call(result);
		return result;
	}

	shptr<class EdgeInsetsGeometry> /*var-nullable*/ ExpansionTile::childrenPadding() {
		auto m = ManagedCall("ExpansionTile", "childrenPadding");
		m.put("this", this);
		shptr<class EdgeInsetsGeometry> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ ExpansionTile::iconColor() {
		auto m = ManagedCall("ExpansionTile", "iconColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ ExpansionTile::collapsedIconColor() {
		auto m = ManagedCall("ExpansionTile", "collapsedIconColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ ExpansionTile::textColor() {
		auto m = ManagedCall("ExpansionTile", "textColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ ExpansionTile::collapsedTextColor() {
		auto m = ManagedCall("ExpansionTile", "collapsedTextColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class ShapeBorder> /*var-nullable*/ ExpansionTile::shape() {
		auto m = ManagedCall("ExpansionTile", "shape");
		m.put("this", this);
		shptr<class ShapeBorder> result;
		m.call(result);
		return result;
	}

	shptr<class ShapeBorder> /*var-nullable*/ ExpansionTile::collapsedShape() {
		auto m = ManagedCall("ExpansionTile", "collapsedShape");
		m.put("this", this);
		shptr<class ShapeBorder> result;
		m.call(result);
		return result;
	}

	stdop<Clip> /*var-nullable*/ ExpansionTile::clipBehavior() {
		auto m = ManagedCall("ExpansionTile", "clipBehavior");
		m.put("this", this);
		stdop<Clip> result;
		m.call(result);
		return result;
	}

	stdop<ListTileControlAffinity> /*var-nullable*/ ExpansionTile::controlAffinity() {
		auto m = ManagedCall("ExpansionTile", "controlAffinity");
		m.put("this", this);
		stdop<ListTileControlAffinity> result;
		m.call(result);
		return result;
	}

	shptr<class ExpansionTileController> /*var-nullable*/ ExpansionTile::controller() {
		auto m = ManagedCall("ExpansionTile", "controller");
		m.put("this", this);
		shptr<class ExpansionTileController> result;
		m.call(result);
		return result;
	}

	shptr<class ExpansionTile> /*non-null*/ ExpansionTile::ctorMain(_ctorMain p) {
		auto m = ManagedCall("ExpansionTile", "ExpansionTile");
		m.put("key", p.key);
		m.put("leading", p.leading);
		m.put("title", p.title, true);
		m.put("subtitle", p.subtitle);
		m.put("onExpansionChanged", p.onExpansionChanged);
		m.put("children", p.children);
		m.put("trailing", p.trailing);
		m.put("initiallyExpanded", p.initiallyExpanded);
		m.put("maintainState", p.maintainState);
		m.put("tilePadding", p.tilePadding);
		m.put("expandedCrossAxisAlignment", p.expandedCrossAxisAlignment);
		m.put("expandedAlignment", p.expandedAlignment);
		m.put("childrenPadding", p.childrenPadding);
		m.put("backgroundColor", p.backgroundColor);
		m.put("collapsedBackgroundColor", p.collapsedBackgroundColor);
		m.put("textColor", p.textColor);
		m.put("collapsedTextColor", p.collapsedTextColor);
		m.put("iconColor", p.iconColor);
		m.put("collapsedIconColor", p.collapsedIconColor);
		m.put("shape", p.shape);
		m.put("collapsedShape", p.collapsedShape);
		m.put("clipBehavior", p.clipBehavior);
		m.put("controlAffinity", p.controlAffinity);
		m.put("controller", p.controller);
		shptr<class ExpansionTile> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Widget> /*var-non-null*/ ExpansionPanel::body() {
		auto m = ManagedCall("ExpansionPanel", "body");
		m.put("this", this);
		shptr<class Widget> result;
		m.check(m.call(result));
		return result;
	}

	bool /*var-non-null*/ ExpansionPanel::isExpanded() {
		auto m = ManagedCall("ExpansionPanel", "isExpanded");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	bool /*var-non-null*/ ExpansionPanel::canTapOnHeader() {
		auto m = ManagedCall("ExpansionPanel", "canTapOnHeader");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*var-nullable*/ ExpansionPanel::backgroundColor() {
		auto m = ManagedCall("ExpansionPanel", "backgroundColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class ExpansionPanel> /*non-null*/ ExpansionPanel::ctorMain(_ctorMain p) {
		auto m = ManagedCall("ExpansionPanel", "ExpansionPanel");
		m.put("headerBuilder", p.headerBuilder, true);
		m.put("body", p.body, true);
		m.put("isExpanded", p.isExpanded);
		m.put("canTapOnHeader", p.canTapOnHeader);
		m.put("backgroundColor", p.backgroundColor);
		shptr<class ExpansionPanel> result;
		m.check(m.call(result, true));
		return result;
	}

	int64 /*var-non-null*/ ExpansionPanelRadio::value() {
		auto m = ManagedCall("ExpansionPanelRadio", "value");
		m.put("this", this);
		int64 result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ExpansionPanelRadio> /*non-null*/ ExpansionPanelRadio::ctorMain(_ctorMain p) {
		auto m = ManagedCall("ExpansionPanelRadio", "ExpansionPanelRadio");
		m.put("value", p.value);
		m.put("headerBuilder", p.headerBuilder, true);
		m.put("body", p.body, true);
		m.put("canTapOnHeader", p.canTapOnHeader);
		m.put("backgroundColor", p.backgroundColor);
		shptr<class ExpansionPanelRadio> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Duration> /*var-non-null*/ ExpansionPanelList::animationDuration() {
		auto m = ManagedCall("ExpansionPanelList", "animationDuration");
		m.put("this", this);
		shptr<class Duration> result;
		m.check(m.call(result));
		return result;
	}

	stdop<int64> /*var-nullable*/ ExpansionPanelList::initialOpenPanelValue() {
		auto m = ManagedCall("ExpansionPanelList", "initialOpenPanelValue");
		m.put("this", this);
		stdop<int64> result;
		m.call(result);
		return result;
	}

	shptr<class EdgeInsets> /*var-non-null*/ ExpansionPanelList::expandedHeaderPadding() {
		auto m = ManagedCall("ExpansionPanelList", "expandedHeaderPadding");
		m.put("this", this);
		shptr<class EdgeInsets> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*var-nullable*/ ExpansionPanelList::dividerColor() {
		auto m = ManagedCall("ExpansionPanelList", "dividerColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	double /*var-non-null*/ ExpansionPanelList::elevation() {
		auto m = ManagedCall("ExpansionPanelList", "elevation");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*var-nullable*/ ExpansionPanelList::expandIconColor() {
		auto m = ManagedCall("ExpansionPanelList", "expandIconColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	double /*var-non-null*/ ExpansionPanelList::materialGapSize() {
		auto m = ManagedCall("ExpansionPanelList", "materialGapSize");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ExpansionPanelList> /*non-null*/ ExpansionPanelList::ctorMain(_ctorMain p) {
		auto m = ManagedCall("ExpansionPanelList", "ExpansionPanelList");
		m.put("key", p.key);
		m.put("children", p.children);
		m.put("expansionCallback", p.expansionCallback);
		m.put("animationDuration", p.animationDuration, true);
		m.put("expandedHeaderPadding", p.expandedHeaderPadding, true);
		m.put("dividerColor", p.dividerColor);
		m.put("elevation", p.elevation);
		m.put("expandIconColor", p.expandIconColor);
		m.put("materialGapSize", p.materialGapSize);
		shptr<class ExpansionPanelList> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class ExpansionPanelList> /*non-null*/ ExpansionPanelList::radio(_radio p) {
		auto m = ManagedCall("ExpansionPanelList", "radio");
		m.put("key", p.key);
		m.put("children", p.children);
		m.put("expansionCallback", p.expansionCallback);
		m.put("animationDuration", p.animationDuration, true);
		m.put("initialOpenPanelValue", p.initialOpenPanelValue);
		m.put("expandedHeaderPadding", p.expandedHeaderPadding, true);
		m.put("dividerColor", p.dividerColor);
		m.put("elevation", p.elevation);
		m.put("expandIconColor", p.expandIconColor);
		m.put("materialGapSize", p.materialGapSize);
		shptr<class ExpansionPanelList> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Widget> /*var-nullable*/ ActionChip::avatar() {
		auto m = ManagedCall("ActionChip", "avatar");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	shptr<class Widget> /*var-non-null*/ ActionChip::label() {
		auto m = ManagedCall("ActionChip", "label");
		m.put("this", this);
		shptr<class Widget> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class TextStyle> /*var-nullable*/ ActionChip::labelStyle() {
		auto m = ManagedCall("ActionChip", "labelStyle");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.call(result);
		return result;
	}

	shptr<class EdgeInsetsGeometry> /*var-nullable*/ ActionChip::labelPadding() {
		auto m = ManagedCall("ActionChip", "labelPadding");
		m.put("this", this);
		shptr<class EdgeInsetsGeometry> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ ActionChip::pressElevation() {
		auto m = ManagedCall("ActionChip", "pressElevation");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	stdop<stdstr> /*var-nullable*/ ActionChip::tooltip() {
		auto m = ManagedCall("ActionChip", "tooltip");
		m.put("this", this);
		stdop<stdstr> result;
		m.call(result);
		return result;
	}

	shptr<class BorderSide> /*var-nullable*/ ActionChip::side() {
		auto m = ManagedCall("ActionChip", "side");
		m.put("this", this);
		shptr<class BorderSide> result;
		m.call(result);
		return result;
	}

	shptr<class OutlinedBorder> /*var-nullable*/ ActionChip::shape() {
		auto m = ManagedCall("ActionChip", "shape");
		m.put("this", this);
		shptr<class OutlinedBorder> result;
		m.call(result);
		return result;
	}

	Clip /*var-non-null*/ ActionChip::clipBehavior() {
		auto m = ManagedCall("ActionChip", "clipBehavior");
		m.put("this", this);
		Clip result;
		m.check(m.call(result));
		return result;
	}

	shptr<class FocusNode> /*var-nullable*/ ActionChip::focusNode() {
		auto m = ManagedCall("ActionChip", "focusNode");
		m.put("this", this);
		shptr<class FocusNode> result;
		m.call(result);
		return result;
	}

	bool /*var-non-null*/ ActionChip::autofocus() {
		auto m = ManagedCall("ActionChip", "autofocus");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*var-nullable*/ ActionChip::backgroundColor() {
		auto m = ManagedCall("ActionChip", "backgroundColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ ActionChip::disabledColor() {
		auto m = ManagedCall("ActionChip", "disabledColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class EdgeInsetsGeometry> /*var-nullable*/ ActionChip::padding() {
		auto m = ManagedCall("ActionChip", "padding");
		m.put("this", this);
		shptr<class EdgeInsetsGeometry> result;
		m.call(result);
		return result;
	}

	shptr<class VisualDensity> /*var-nullable*/ ActionChip::visualDensity() {
		auto m = ManagedCall("ActionChip", "visualDensity");
		m.put("this", this);
		shptr<class VisualDensity> result;
		m.call(result);
		return result;
	}

	stdop<MaterialTapTargetSize> /*var-nullable*/ ActionChip::materialTapTargetSize() {
		auto m = ManagedCall("ActionChip", "materialTapTargetSize");
		m.put("this", this);
		stdop<MaterialTapTargetSize> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ ActionChip::elevation() {
		auto m = ManagedCall("ActionChip", "elevation");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ ActionChip::shadowColor() {
		auto m = ManagedCall("ActionChip", "shadowColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ ActionChip::surfaceTintColor() {
		auto m = ManagedCall("ActionChip", "surfaceTintColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class IconThemeData> /*var-nullable*/ ActionChip::iconTheme() {
		auto m = ManagedCall("ActionChip", "iconTheme");
		m.put("this", this);
		shptr<class IconThemeData> result;
		m.call(result);
		return result;
	}

	bool /*get-non-null*/ ActionChip::isEnabled() {
		auto m = ManagedCall("ActionChip", "isEnabled");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ActionChip> /*non-null*/ ActionChip::ctorMain(_ctorMain p) {
		auto m = ManagedCall("ActionChip", "ActionChip");
		m.put("key", p.key);
		m.put("avatar", p.avatar);
		m.put("label", p.label, true);
		m.put("labelStyle", p.labelStyle);
		m.put("labelPadding", p.labelPadding);
		m.put("onPressed", p.onPressed);
		m.put("pressElevation", p.pressElevation);
		m.put("tooltip", p.tooltip);
		m.put("side", p.side);
		m.put("shape", p.shape);
		m.put("clipBehavior", p.clipBehavior);
		m.put("focusNode", p.focusNode);
		m.put("autofocus", p.autofocus);
		m.put("color", p.color);
		m.put("backgroundColor", p.backgroundColor);
		m.put("disabledColor", p.disabledColor);
		m.put("padding", p.padding);
		m.put("visualDensity", p.visualDensity);
		m.put("materialTapTargetSize", p.materialTapTargetSize);
		m.put("elevation", p.elevation);
		m.put("shadowColor", p.shadowColor);
		m.put("surfaceTintColor", p.surfaceTintColor);
		m.put("iconTheme", p.iconTheme);
		shptr<class ActionChip> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class ActionChip> /*non-null*/ ActionChip::elevated(_elevated p) {
		auto m = ManagedCall("ActionChip", "elevated");
		m.put("key", p.key);
		m.put("avatar", p.avatar);
		m.put("label", p.label, true);
		m.put("labelStyle", p.labelStyle);
		m.put("labelPadding", p.labelPadding);
		m.put("onPressed", p.onPressed);
		m.put("pressElevation", p.pressElevation);
		m.put("tooltip", p.tooltip);
		m.put("side", p.side);
		m.put("shape", p.shape);
		m.put("clipBehavior", p.clipBehavior);
		m.put("focusNode", p.focusNode);
		m.put("autofocus", p.autofocus);
		m.put("color", p.color);
		m.put("backgroundColor", p.backgroundColor);
		m.put("disabledColor", p.disabledColor);
		m.put("padding", p.padding);
		m.put("visualDensity", p.visualDensity);
		m.put("materialTapTargetSize", p.materialTapTargetSize);
		m.put("elevation", p.elevation);
		m.put("shadowColor", p.shadowColor);
		m.put("surfaceTintColor", p.surfaceTintColor);
		m.put("iconTheme", p.iconTheme);
		shptr<class ActionChip> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Widget> /*var-nullable*/ FilterChip::avatar() {
		auto m = ManagedCall("FilterChip", "avatar");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	shptr<class Widget> /*var-non-null*/ FilterChip::label() {
		auto m = ManagedCall("FilterChip", "label");
		m.put("this", this);
		shptr<class Widget> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class TextStyle> /*var-nullable*/ FilterChip::labelStyle() {
		auto m = ManagedCall("FilterChip", "labelStyle");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.call(result);
		return result;
	}

	shptr<class EdgeInsetsGeometry> /*var-nullable*/ FilterChip::labelPadding() {
		auto m = ManagedCall("FilterChip", "labelPadding");
		m.put("this", this);
		shptr<class EdgeInsetsGeometry> result;
		m.call(result);
		return result;
	}

	bool /*var-non-null*/ FilterChip::selected() {
		auto m = ManagedCall("FilterChip", "selected");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	stdop<double> /*var-nullable*/ FilterChip::pressElevation() {
		auto m = ManagedCall("FilterChip", "pressElevation");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ FilterChip::disabledColor() {
		auto m = ManagedCall("FilterChip", "disabledColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ FilterChip::selectedColor() {
		auto m = ManagedCall("FilterChip", "selectedColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	stdop<stdstr> /*var-nullable*/ FilterChip::tooltip() {
		auto m = ManagedCall("FilterChip", "tooltip");
		m.put("this", this);
		stdop<stdstr> result;
		m.call(result);
		return result;
	}

	shptr<class BorderSide> /*var-nullable*/ FilterChip::side() {
		auto m = ManagedCall("FilterChip", "side");
		m.put("this", this);
		shptr<class BorderSide> result;
		m.call(result);
		return result;
	}

	shptr<class OutlinedBorder> /*var-nullable*/ FilterChip::shape() {
		auto m = ManagedCall("FilterChip", "shape");
		m.put("this", this);
		shptr<class OutlinedBorder> result;
		m.call(result);
		return result;
	}

	Clip /*var-non-null*/ FilterChip::clipBehavior() {
		auto m = ManagedCall("FilterChip", "clipBehavior");
		m.put("this", this);
		Clip result;
		m.check(m.call(result));
		return result;
	}

	shptr<class FocusNode> /*var-nullable*/ FilterChip::focusNode() {
		auto m = ManagedCall("FilterChip", "focusNode");
		m.put("this", this);
		shptr<class FocusNode> result;
		m.call(result);
		return result;
	}

	bool /*var-non-null*/ FilterChip::autofocus() {
		auto m = ManagedCall("FilterChip", "autofocus");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*var-nullable*/ FilterChip::backgroundColor() {
		auto m = ManagedCall("FilterChip", "backgroundColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class EdgeInsetsGeometry> /*var-nullable*/ FilterChip::padding() {
		auto m = ManagedCall("FilterChip", "padding");
		m.put("this", this);
		shptr<class EdgeInsetsGeometry> result;
		m.call(result);
		return result;
	}

	shptr<class VisualDensity> /*var-nullable*/ FilterChip::visualDensity() {
		auto m = ManagedCall("FilterChip", "visualDensity");
		m.put("this", this);
		shptr<class VisualDensity> result;
		m.call(result);
		return result;
	}

	stdop<MaterialTapTargetSize> /*var-nullable*/ FilterChip::materialTapTargetSize() {
		auto m = ManagedCall("FilterChip", "materialTapTargetSize");
		m.put("this", this);
		stdop<MaterialTapTargetSize> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ FilterChip::elevation() {
		auto m = ManagedCall("FilterChip", "elevation");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ FilterChip::shadowColor() {
		auto m = ManagedCall("FilterChip", "shadowColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ FilterChip::surfaceTintColor() {
		auto m = ManagedCall("FilterChip", "surfaceTintColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ FilterChip::selectedShadowColor() {
		auto m = ManagedCall("FilterChip", "selectedShadowColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	stdop<bool> /*var-nullable*/ FilterChip::showCheckmark() {
		auto m = ManagedCall("FilterChip", "showCheckmark");
		m.put("this", this);
		stdop<bool> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ FilterChip::checkmarkColor() {
		auto m = ManagedCall("FilterChip", "checkmarkColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class ShapeBorder> /*var-non-null*/ FilterChip::avatarBorder() {
		auto m = ManagedCall("FilterChip", "avatarBorder");
		m.put("this", this);
		shptr<class ShapeBorder> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class IconThemeData> /*var-nullable*/ FilterChip::iconTheme() {
		auto m = ManagedCall("FilterChip", "iconTheme");
		m.put("this", this);
		shptr<class IconThemeData> result;
		m.call(result);
		return result;
	}

	bool /*get-non-null*/ FilterChip::isEnabled() {
		auto m = ManagedCall("FilterChip", "isEnabled");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class FilterChip> /*non-null*/ FilterChip::ctorMain(_ctorMain p) {
		auto m = ManagedCall("FilterChip", "FilterChip");
		m.put("key", p.key);
		m.put("avatar", p.avatar);
		m.put("label", p.label, true);
		m.put("labelStyle", p.labelStyle);
		m.put("labelPadding", p.labelPadding);
		m.put("selected", p.selected);
		m.put("onSelected", p.onSelected);
		m.put("pressElevation", p.pressElevation);
		m.put("disabledColor", p.disabledColor);
		m.put("selectedColor", p.selectedColor);
		m.put("tooltip", p.tooltip);
		m.put("side", p.side);
		m.put("shape", p.shape);
		m.put("clipBehavior", p.clipBehavior);
		m.put("focusNode", p.focusNode);
		m.put("autofocus", p.autofocus);
		m.put("color", p.color);
		m.put("backgroundColor", p.backgroundColor);
		m.put("padding", p.padding);
		m.put("visualDensity", p.visualDensity);
		m.put("materialTapTargetSize", p.materialTapTargetSize);
		m.put("elevation", p.elevation);
		m.put("shadowColor", p.shadowColor);
		m.put("surfaceTintColor", p.surfaceTintColor);
		m.put("iconTheme", p.iconTheme);
		m.put("selectedShadowColor", p.selectedShadowColor);
		m.put("showCheckmark", p.showCheckmark);
		m.put("checkmarkColor", p.checkmarkColor);
		m.put("avatarBorder", p.avatarBorder, true);
		shptr<class FilterChip> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class FilterChip> /*non-null*/ FilterChip::elevated(_elevated p) {
		auto m = ManagedCall("FilterChip", "elevated");
		m.put("key", p.key);
		m.put("avatar", p.avatar);
		m.put("label", p.label, true);
		m.put("labelStyle", p.labelStyle);
		m.put("labelPadding", p.labelPadding);
		m.put("selected", p.selected);
		m.put("onSelected", p.onSelected);
		m.put("pressElevation", p.pressElevation);
		m.put("disabledColor", p.disabledColor);
		m.put("selectedColor", p.selectedColor);
		m.put("tooltip", p.tooltip);
		m.put("side", p.side);
		m.put("shape", p.shape);
		m.put("clipBehavior", p.clipBehavior);
		m.put("focusNode", p.focusNode);
		m.put("autofocus", p.autofocus);
		m.put("color", p.color);
		m.put("backgroundColor", p.backgroundColor);
		m.put("padding", p.padding);
		m.put("visualDensity", p.visualDensity);
		m.put("materialTapTargetSize", p.materialTapTargetSize);
		m.put("elevation", p.elevation);
		m.put("shadowColor", p.shadowColor);
		m.put("surfaceTintColor", p.surfaceTintColor);
		m.put("iconTheme", p.iconTheme);
		m.put("selectedShadowColor", p.selectedShadowColor);
		m.put("showCheckmark", p.showCheckmark);
		m.put("checkmarkColor", p.checkmarkColor);
		m.put("avatarBorder", p.avatarBorder, true);
		shptr<class FilterChip> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class ButtonStyle> /*non-null*/ OutlinedButton::styleFrom(_styleFrom p) {
		auto m = ManagedCall("OutlinedButton", "styleFrom");
		m.put("foregroundColor", p.foregroundColor);
		m.put("backgroundColor", p.backgroundColor);
		m.put("disabledForegroundColor", p.disabledForegroundColor);
		m.put("disabledBackgroundColor", p.disabledBackgroundColor);
		m.put("shadowColor", p.shadowColor);
		m.put("surfaceTintColor", p.surfaceTintColor);
		m.put("elevation", p.elevation);
		m.put("textStyle", p.textStyle);
		m.put("padding", p.padding);
		m.put("minimumSize", p.minimumSize);
		m.put("fixedSize", p.fixedSize);
		m.put("maximumSize", p.maximumSize);
		m.put("side", p.side);
		m.put("shape", p.shape);
		m.put("enabledMouseCursor", p.enabledMouseCursor);
		m.put("disabledMouseCursor", p.disabledMouseCursor);
		m.put("visualDensity", p.visualDensity);
		m.put("tapTargetSize", p.tapTargetSize);
		m.put("animationDuration", p.animationDuration);
		m.put("enableFeedback", p.enableFeedback);
		m.put("alignment", p.alignment);
		m.put("splashFactory", p.splashFactory);
		m.put("primary", p.primary);
		m.put("onSurface", p.onSurface);
		shptr<class ButtonStyle> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ButtonStyle> /*non-null*/ OutlinedButton::defaultStyleOf(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("OutlinedButton", "defaultStyleOf");
		m.put("this", this);
		m.put("context", context, true);
		shptr<class ButtonStyle> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ButtonStyle> /*nullable*/ OutlinedButton::themeStyleOf(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("OutlinedButton", "themeStyleOf");
		m.put("this", this);
		m.put("context", context, true);
		shptr<class ButtonStyle> result;
		m.call(result);
		return result;
	}

	shptr<class OutlinedButton> /*non-null*/ OutlinedButton::ctorMain(_ctorMain p) {
		auto m = ManagedCall("OutlinedButton", "OutlinedButton");
		m.put("key", p.key);
		m.put("onPressed", p.onPressed);
		m.put("onLongPress", p.onLongPress);
		m.put("onHover", p.onHover);
		m.put("onFocusChange", p.onFocusChange);
		m.put("style", p.style);
		m.put("focusNode", p.focusNode);
		m.put("autofocus", p.autofocus);
		m.put("clipBehavior", p.clipBehavior);
		m.put("statesController", p.statesController);
		m.put("child", p.child);
		shptr<class OutlinedButton> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class OutlinedButton> /*non-null*/ OutlinedButton::icon(_icon p) {
		auto m = ManagedCall("OutlinedButton", "icon");
		m.put("key", p.key);
		m.put("onPressed", p.onPressed);
		m.put("onLongPress", p.onLongPress);
		m.put("style", p.style);
		m.put("focusNode", p.focusNode);
		m.put("autofocus", p.autofocus);
		m.put("clipBehavior", p.clipBehavior);
		m.put("statesController", p.statesController);
		m.put("icon", p.icon, true);
		m.put("label", p.label, true);
		shptr<class OutlinedButton> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class ButtonStyle> /*non-null*/ ElevatedButton::styleFrom(_styleFrom p) {
		auto m = ManagedCall("ElevatedButton", "styleFrom");
		m.put("foregroundColor", p.foregroundColor);
		m.put("backgroundColor", p.backgroundColor);
		m.put("disabledForegroundColor", p.disabledForegroundColor);
		m.put("disabledBackgroundColor", p.disabledBackgroundColor);
		m.put("shadowColor", p.shadowColor);
		m.put("surfaceTintColor", p.surfaceTintColor);
		m.put("elevation", p.elevation);
		m.put("textStyle", p.textStyle);
		m.put("padding", p.padding);
		m.put("minimumSize", p.minimumSize);
		m.put("fixedSize", p.fixedSize);
		m.put("maximumSize", p.maximumSize);
		m.put("side", p.side);
		m.put("shape", p.shape);
		m.put("enabledMouseCursor", p.enabledMouseCursor);
		m.put("disabledMouseCursor", p.disabledMouseCursor);
		m.put("visualDensity", p.visualDensity);
		m.put("tapTargetSize", p.tapTargetSize);
		m.put("animationDuration", p.animationDuration);
		m.put("enableFeedback", p.enableFeedback);
		m.put("alignment", p.alignment);
		m.put("splashFactory", p.splashFactory);
		m.put("primary", p.primary);
		m.put("onPrimary", p.onPrimary);
		m.put("onSurface", p.onSurface);
		shptr<class ButtonStyle> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ButtonStyle> /*non-null*/ ElevatedButton::defaultStyleOf(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("ElevatedButton", "defaultStyleOf");
		m.put("this", this);
		m.put("context", context, true);
		shptr<class ButtonStyle> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ButtonStyle> /*nullable*/ ElevatedButton::themeStyleOf(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("ElevatedButton", "themeStyleOf");
		m.put("this", this);
		m.put("context", context, true);
		shptr<class ButtonStyle> result;
		m.call(result);
		return result;
	}

	shptr<class ElevatedButton> /*non-null*/ ElevatedButton::ctorMain(_ctorMain p) {
		auto m = ManagedCall("ElevatedButton", "ElevatedButton");
		m.put("key", p.key);
		m.put("onPressed", p.onPressed);
		m.put("onLongPress", p.onLongPress);
		m.put("onHover", p.onHover);
		m.put("onFocusChange", p.onFocusChange);
		m.put("style", p.style);
		m.put("focusNode", p.focusNode);
		m.put("autofocus", p.autofocus);
		m.put("clipBehavior", p.clipBehavior);
		m.put("statesController", p.statesController);
		m.put("child", p.child);
		shptr<class ElevatedButton> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class ElevatedButton> /*non-null*/ ElevatedButton::icon(_icon p) {
		auto m = ManagedCall("ElevatedButton", "icon");
		m.put("key", p.key);
		m.put("onPressed", p.onPressed);
		m.put("onLongPress", p.onLongPress);
		m.put("onHover", p.onHover);
		m.put("onFocusChange", p.onFocusChange);
		m.put("style", p.style);
		m.put("focusNode", p.focusNode);
		m.put("autofocus", p.autofocus);
		m.put("clipBehavior", p.clipBehavior);
		m.put("statesController", p.statesController);
		m.put("icon", p.icon, true);
		m.put("label", p.label, true);
		shptr<class ElevatedButton> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class ButtonStyle> /*non-null*/ FilledButton::styleFrom(_styleFrom p) {
		auto m = ManagedCall("FilledButton", "styleFrom");
		m.put("foregroundColor", p.foregroundColor);
		m.put("backgroundColor", p.backgroundColor);
		m.put("disabledForegroundColor", p.disabledForegroundColor);
		m.put("disabledBackgroundColor", p.disabledBackgroundColor);
		m.put("shadowColor", p.shadowColor);
		m.put("surfaceTintColor", p.surfaceTintColor);
		m.put("elevation", p.elevation);
		m.put("textStyle", p.textStyle);
		m.put("padding", p.padding);
		m.put("minimumSize", p.minimumSize);
		m.put("fixedSize", p.fixedSize);
		m.put("maximumSize", p.maximumSize);
		m.put("side", p.side);
		m.put("shape", p.shape);
		m.put("enabledMouseCursor", p.enabledMouseCursor);
		m.put("disabledMouseCursor", p.disabledMouseCursor);
		m.put("visualDensity", p.visualDensity);
		m.put("tapTargetSize", p.tapTargetSize);
		m.put("animationDuration", p.animationDuration);
		m.put("enableFeedback", p.enableFeedback);
		m.put("alignment", p.alignment);
		m.put("splashFactory", p.splashFactory);
		shptr<class ButtonStyle> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ButtonStyle> /*non-null*/ FilledButton::defaultStyleOf(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("FilledButton", "defaultStyleOf");
		m.put("this", this);
		m.put("context", context, true);
		shptr<class ButtonStyle> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ButtonStyle> /*nullable*/ FilledButton::themeStyleOf(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("FilledButton", "themeStyleOf");
		m.put("this", this);
		m.put("context", context, true);
		shptr<class ButtonStyle> result;
		m.call(result);
		return result;
	}

	shptr<class FilledButton> /*non-null*/ FilledButton::ctorMain(_ctorMain p) {
		auto m = ManagedCall("FilledButton", "FilledButton");
		m.put("key", p.key);
		m.put("onPressed", p.onPressed);
		m.put("onLongPress", p.onLongPress);
		m.put("onHover", p.onHover);
		m.put("onFocusChange", p.onFocusChange);
		m.put("style", p.style);
		m.put("focusNode", p.focusNode);
		m.put("autofocus", p.autofocus);
		m.put("clipBehavior", p.clipBehavior);
		m.put("statesController", p.statesController);
		m.put("child", p.child);
		shptr<class FilledButton> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class FilledButton> /*non-null*/ FilledButton::tonal(_tonal p) {
		auto m = ManagedCall("FilledButton", "tonal");
		m.put("key", p.key);
		m.put("onPressed", p.onPressed);
		m.put("onLongPress", p.onLongPress);
		m.put("onHover", p.onHover);
		m.put("onFocusChange", p.onFocusChange);
		m.put("style", p.style);
		m.put("focusNode", p.focusNode);
		m.put("autofocus", p.autofocus);
		m.put("clipBehavior", p.clipBehavior);
		m.put("statesController", p.statesController);
		m.put("child", p.child);
		shptr<class FilledButton> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class FilledButton> /*non-null*/ FilledButton::icon(_icon p) {
		auto m = ManagedCall("FilledButton", "icon");
		m.put("key", p.key);
		m.put("onPressed", p.onPressed);
		m.put("onLongPress", p.onLongPress);
		m.put("onHover", p.onHover);
		m.put("onFocusChange", p.onFocusChange);
		m.put("style", p.style);
		m.put("focusNode", p.focusNode);
		m.put("autofocus", p.autofocus);
		m.put("clipBehavior", p.clipBehavior);
		m.put("statesController", p.statesController);
		m.put("icon", p.icon, true);
		m.put("label", p.label, true);
		shptr<class FilledButton> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class FilledButton> /*non-null*/ FilledButton::tonalIcon(_tonalIcon p) {
		auto m = ManagedCall("FilledButton", "tonalIcon");
		m.put("key", p.key);
		m.put("onPressed", p.onPressed);
		m.put("onLongPress", p.onLongPress);
		m.put("onHover", p.onHover);
		m.put("onFocusChange", p.onFocusChange);
		m.put("style", p.style);
		m.put("focusNode", p.focusNode);
		m.put("autofocus", p.autofocus);
		m.put("clipBehavior", p.clipBehavior);
		m.put("statesController", p.statesController);
		m.put("icon", p.icon, true);
		m.put("label", p.label, true);
		shptr<class FilledButton> result;
		m.check(m.call(result, true));
		return result;
	}

	double /*var-non-null*/ CircularProgressIndicator::strokeWidth() {
		auto m = ManagedCall("CircularProgressIndicator", "strokeWidth");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	double /*var-non-null*/ CircularProgressIndicator::strokeAlign() {
		auto m = ManagedCall("CircularProgressIndicator", "strokeAlign");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	stdop<StrokeCap> /*var-nullable*/ CircularProgressIndicator::strokeCap() {
		auto m = ManagedCall("CircularProgressIndicator", "strokeCap");
		m.put("this", this);
		stdop<StrokeCap> result;
		m.call(result);
		return result;
	}

	double /*var-non-null*/ CircularProgressIndicator::strokeAlignInside() {
		auto m = ManagedCall("CircularProgressIndicator", "strokeAlignInside");
		double result;
		m.check(m.call(result));
		return result;
	}

	double /*var-non-null*/ CircularProgressIndicator::strokeAlignCenter() {
		auto m = ManagedCall("CircularProgressIndicator", "strokeAlignCenter");
		double result;
		m.check(m.call(result));
		return result;
	}

	double /*var-non-null*/ CircularProgressIndicator::strokeAlignOutside() {
		auto m = ManagedCall("CircularProgressIndicator", "strokeAlignOutside");
		double result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*get-nullable*/ CircularProgressIndicator::backgroundColor() {
		auto m = ManagedCall("CircularProgressIndicator", "backgroundColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class CircularProgressIndicator> /*non-null*/ CircularProgressIndicator::ctorMain(_ctorMain p) {
		auto m = ManagedCall("CircularProgressIndicator", "CircularProgressIndicator");
		m.put("key", p.key);
		m.put("value", p.value);
		m.put("backgroundColor", p.backgroundColor);
		m.put("color", p.color);
		m.put("valueColor", p.valueColor);
		m.put("strokeWidth", p.strokeWidth);
		m.put("strokeAlign", p.strokeAlign);
		m.put("semanticsLabel", p.semanticsLabel);
		m.put("semanticsValue", p.semanticsValue);
		m.put("strokeCap", p.strokeCap);
		shptr<class CircularProgressIndicator> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class CircularProgressIndicator> /*non-null*/ CircularProgressIndicator::adaptive(_adaptive p) {
		auto m = ManagedCall("CircularProgressIndicator", "adaptive");
		m.put("key", p.key);
		m.put("value", p.value);
		m.put("backgroundColor", p.backgroundColor);
		m.put("valueColor", p.valueColor);
		m.put("strokeWidth", p.strokeWidth);
		m.put("semanticsLabel", p.semanticsLabel);
		m.put("semanticsValue", p.semanticsValue);
		m.put("strokeCap", p.strokeCap);
		m.put("strokeAlign", p.strokeAlign);
		shptr<class CircularProgressIndicator> result;
		m.check(m.call(result, true));
		return result;
	}

	double /*var-non-null*/ RefreshProgressIndicator::defaultStrokeWidth() {
		auto m = ManagedCall("RefreshProgressIndicator", "defaultStrokeWidth");
		double result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*get-nullable*/ RefreshProgressIndicator::backgroundColor() {
		auto m = ManagedCall("RefreshProgressIndicator", "backgroundColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class RefreshProgressIndicator> /*non-null*/ RefreshProgressIndicator::ctorMain(_ctorMain p) {
		auto m = ManagedCall("RefreshProgressIndicator", "RefreshProgressIndicator");
		m.put("key", p.key);
		m.put("value", p.value);
		m.put("backgroundColor", p.backgroundColor);
		m.put("color", p.color);
		m.put("valueColor", p.valueColor);
		m.put("strokeWidth", p.strokeWidth);
		m.put("strokeAlign", p.strokeAlign);
		m.put("semanticsLabel", p.semanticsLabel);
		m.put("semanticsValue", p.semanticsValue);
		m.put("strokeCap", p.strokeCap);
		shptr<class RefreshProgressIndicator> result;
		m.check(m.call(result, true));
		return result;
	}

	stdop<double> /*var-nullable*/ LinearProgressIndicator::minHeight() {
		auto m = ManagedCall("LinearProgressIndicator", "minHeight");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	shptr<class BorderRadiusGeometry> /*var-non-null*/ LinearProgressIndicator::borderRadius() {
		auto m = ManagedCall("LinearProgressIndicator", "borderRadius");
		m.put("this", this);
		shptr<class BorderRadiusGeometry> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*get-nullable*/ LinearProgressIndicator::backgroundColor() {
		auto m = ManagedCall("LinearProgressIndicator", "backgroundColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class LinearProgressIndicator> /*non-null*/ LinearProgressIndicator::ctorMain(_ctorMain p) {
		auto m = ManagedCall("LinearProgressIndicator", "LinearProgressIndicator");
		m.put("key", p.key);
		m.put("value", p.value);
		m.put("backgroundColor", p.backgroundColor);
		m.put("color", p.color);
		m.put("valueColor", p.valueColor);
		m.put("minHeight", p.minHeight);
		m.put("semanticsLabel", p.semanticsLabel);
		m.put("semanticsValue", p.semanticsValue);
		m.put("borderRadius", p.borderRadius, true);
		shptr<class LinearProgressIndicator> result;
		m.check(m.call(result, true));
		return result;
	}

	stdstr /*get-non-null*/ TextEditingController::text() {
		auto m = ManagedCall("TextEditingController", "text");
		m.put("this", this);
		stdstr result;
		m.check(m.call(result));
		return result;
	}

	shptr<class TextSelection> /*get-non-null*/ TextEditingController::selection() {
		auto m = ManagedCall("TextEditingController", "selection");
		m.put("this", this);
		shptr<class TextSelection> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class TextSpan> /*non-null*/ TextEditingController::buildTextSpan(_buildTextSpan p) {
		auto m = ManagedCall("TextEditingController", "buildTextSpan");
		m.put("this", this);
		m.put("context", p.context, true);
		m.put("style", p.style);
		m.put("withComposing", p.withComposing);
		shptr<class TextSpan> result;
		m.check(m.call(result));
		return result;
	}

	void TextEditingController::clear() {
		auto m = ManagedCall("TextEditingController", "clear");
		m.put("this", this);
		m.call();
	}

	void TextEditingController::clearComposing() {
		auto m = ManagedCall("TextEditingController", "clearComposing");
		m.put("this", this);
		m.call();
	}

	bool /*non-null*/ TextEditingController::isSelectionWithinTextBounds(/*non-null*/ shptr<class TextSelection> selection) {
		auto m = ManagedCall("TextEditingController", "isSelectionWithinTextBounds");
		m.put("this", this);
		m.put("selection", selection, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class TextEditingController> /*non-null*/ TextEditingController::ctorMain(_ctorMain p) {
		auto m = ManagedCall("TextEditingController", "TextEditingController");
		m.put("text", p.text);
		shptr<class TextEditingController> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class TextEditingController> /*non-null*/ TextEditingController::fromValue(/*nullable*/ shptr<class TextEditingValue> value) {
		auto m = ManagedCall("TextEditingController", "fromValue");
		m.put("value", value);
		shptr<class TextEditingController> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Color> /*var-nullable*/ Drawer::backgroundColor() {
		auto m = ManagedCall("Drawer", "backgroundColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ Drawer::elevation() {
		auto m = ManagedCall("Drawer", "elevation");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ Drawer::shadowColor() {
		auto m = ManagedCall("Drawer", "shadowColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ Drawer::surfaceTintColor() {
		auto m = ManagedCall("Drawer", "surfaceTintColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class ShapeBorder> /*var-nullable*/ Drawer::shape() {
		auto m = ManagedCall("Drawer", "shape");
		m.put("this", this);
		shptr<class ShapeBorder> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ Drawer::width() {
		auto m = ManagedCall("Drawer", "width");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	shptr<class Widget> /*var-nullable*/ Drawer::child() {
		auto m = ManagedCall("Drawer", "child");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	stdop<stdstr> /*var-nullable*/ Drawer::semanticLabel() {
		auto m = ManagedCall("Drawer", "semanticLabel");
		m.put("this", this);
		stdop<stdstr> result;
		m.call(result);
		return result;
	}

	stdop<Clip> /*var-nullable*/ Drawer::clipBehavior() {
		auto m = ManagedCall("Drawer", "clipBehavior");
		m.put("this", this);
		stdop<Clip> result;
		m.call(result);
		return result;
	}

	shptr<class Drawer> /*non-null*/ Drawer::ctorMain(_ctorMain p) {
		auto m = ManagedCall("Drawer", "Drawer");
		m.put("key", p.key);
		m.put("backgroundColor", p.backgroundColor);
		m.put("elevation", p.elevation);
		m.put("shadowColor", p.shadowColor);
		m.put("surfaceTintColor", p.surfaceTintColor);
		m.put("shape", p.shape);
		m.put("width", p.width);
		m.put("child", p.child);
		m.put("semanticLabel", p.semanticLabel);
		m.put("clipBehavior", p.clipBehavior);
		shptr<class Drawer> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Decoration> /*var-nullable*/ DrawerHeader::decoration() {
		auto m = ManagedCall("DrawerHeader", "decoration");
		m.put("this", this);
		shptr<class Decoration> result;
		m.call(result);
		return result;
	}

	shptr<class EdgeInsetsGeometry> /*var-non-null*/ DrawerHeader::padding() {
		auto m = ManagedCall("DrawerHeader", "padding");
		m.put("this", this);
		shptr<class EdgeInsetsGeometry> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class EdgeInsetsGeometry> /*var-nullable*/ DrawerHeader::margin() {
		auto m = ManagedCall("DrawerHeader", "margin");
		m.put("this", this);
		shptr<class EdgeInsetsGeometry> result;
		m.call(result);
		return result;
	}

	shptr<class Duration> /*var-non-null*/ DrawerHeader::duration() {
		auto m = ManagedCall("DrawerHeader", "duration");
		m.put("this", this);
		shptr<class Duration> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Curve> /*var-non-null*/ DrawerHeader::curve() {
		auto m = ManagedCall("DrawerHeader", "curve");
		m.put("this", this);
		shptr<class Curve> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Widget> /*var-nullable*/ DrawerHeader::child() {
		auto m = ManagedCall("DrawerHeader", "child");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	shptr<class DrawerHeader> /*non-null*/ DrawerHeader::ctorMain(_ctorMain p) {
		auto m = ManagedCall("DrawerHeader", "DrawerHeader");
		m.put("key", p.key);
		m.put("decoration", p.decoration);
		m.put("margin", p.margin);
		m.put("padding", p.padding, true);
		m.put("duration", p.duration, true);
		m.put("curve", p.curve, true);
		m.put("child", p.child);
		shptr<class DrawerHeader> result;
		m.check(m.call(result, true));
		return result;
	}

	stdop<int64> /*var-nullable*/ DropdownButton::value() {
		auto m = ManagedCall("DropdownButton", "value");
		m.put("this", this);
		stdop<int64> result;
		m.call(result);
		return result;
	}

	shptr<class Widget> /*var-nullable*/ DropdownButton::hint() {
		auto m = ManagedCall("DropdownButton", "hint");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	shptr<class Widget> /*var-nullable*/ DropdownButton::disabledHint() {
		auto m = ManagedCall("DropdownButton", "disabledHint");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	int64 /*var-non-null*/ DropdownButton::elevation() {
		auto m = ManagedCall("DropdownButton", "elevation");
		m.put("this", this);
		int64 result;
		m.check(m.call(result));
		return result;
	}

	shptr<class TextStyle> /*var-nullable*/ DropdownButton::style() {
		auto m = ManagedCall("DropdownButton", "style");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.call(result);
		return result;
	}

	shptr<class Widget> /*var-nullable*/ DropdownButton::underline() {
		auto m = ManagedCall("DropdownButton", "underline");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	shptr<class Widget> /*var-nullable*/ DropdownButton::icon() {
		auto m = ManagedCall("DropdownButton", "icon");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ DropdownButton::iconDisabledColor() {
		auto m = ManagedCall("DropdownButton", "iconDisabledColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ DropdownButton::iconEnabledColor() {
		auto m = ManagedCall("DropdownButton", "iconEnabledColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	double /*var-non-null*/ DropdownButton::iconSize() {
		auto m = ManagedCall("DropdownButton", "iconSize");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	bool /*var-non-null*/ DropdownButton::isDense() {
		auto m = ManagedCall("DropdownButton", "isDense");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	bool /*var-non-null*/ DropdownButton::isExpanded() {
		auto m = ManagedCall("DropdownButton", "isExpanded");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	stdop<double> /*var-nullable*/ DropdownButton::itemHeight() {
		auto m = ManagedCall("DropdownButton", "itemHeight");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ DropdownButton::focusColor() {
		auto m = ManagedCall("DropdownButton", "focusColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class FocusNode> /*var-nullable*/ DropdownButton::focusNode() {
		auto m = ManagedCall("DropdownButton", "focusNode");
		m.put("this", this);
		shptr<class FocusNode> result;
		m.call(result);
		return result;
	}

	bool /*var-non-null*/ DropdownButton::autofocus() {
		auto m = ManagedCall("DropdownButton", "autofocus");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*var-nullable*/ DropdownButton::dropdownColor() {
		auto m = ManagedCall("DropdownButton", "dropdownColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class EdgeInsetsGeometry> /*var-nullable*/ DropdownButton::padding() {
		auto m = ManagedCall("DropdownButton", "padding");
		m.put("this", this);
		shptr<class EdgeInsetsGeometry> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ DropdownButton::menuMaxHeight() {
		auto m = ManagedCall("DropdownButton", "menuMaxHeight");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	stdop<bool> /*var-nullable*/ DropdownButton::enableFeedback() {
		auto m = ManagedCall("DropdownButton", "enableFeedback");
		m.put("this", this);
		stdop<bool> result;
		m.call(result);
		return result;
	}

	shptr<class AlignmentGeometry> /*var-non-null*/ DropdownButton::alignment() {
		auto m = ManagedCall("DropdownButton", "alignment");
		m.put("this", this);
		shptr<class AlignmentGeometry> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class BorderRadius> /*var-nullable*/ DropdownButton::borderRadius() {
		auto m = ManagedCall("DropdownButton", "borderRadius");
		m.put("this", this);
		shptr<class BorderRadius> result;
		m.call(result);
		return result;
	}

	shptr<class DropdownButton> /*non-null*/ DropdownButton::ctorMain(_ctorMain p) {
		auto m = ManagedCall("DropdownButton", "DropdownButton");
		m.put("key", p.key);
		m.put("items", p.items);
//		m.put("selectedItemBuilder", p.selectedItemBuilder);
		m.put("value", p.value);
		m.put("hint", p.hint);
		m.put("disabledHint", p.disabledHint);
		m.put("onChanged", p.onChanged);
		m.put("onTap", p.onTap);
		m.put("elevation", p.elevation);
		m.put("style", p.style);
		m.put("underline", p.underline);
		m.put("icon", p.icon);
		m.put("iconDisabledColor", p.iconDisabledColor);
		m.put("iconEnabledColor", p.iconEnabledColor);
		m.put("iconSize", p.iconSize);
		m.put("isDense", p.isDense);
		m.put("isExpanded", p.isExpanded);
		m.put("itemHeight", p.itemHeight);
		m.put("focusColor", p.focusColor);
		m.put("focusNode", p.focusNode);
		m.put("autofocus", p.autofocus);
		m.put("dropdownColor", p.dropdownColor);
		m.put("menuMaxHeight", p.menuMaxHeight);
		m.put("enableFeedback", p.enableFeedback);
		m.put("alignment", p.alignment, true);
		m.put("borderRadius", p.borderRadius);
		m.put("padding", p.padding);
		shptr<class DropdownButton> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class InputDecoration> /*var-non-null*/ DropdownButtonFormField::decoration() {
		auto m = ManagedCall("DropdownButtonFormField", "decoration");
		m.put("this", this);
		shptr<class InputDecoration> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class DropdownButtonFormField> /*non-null*/ DropdownButtonFormField::ctorMain(_ctorMain p) {
		auto m = ManagedCall("DropdownButtonFormField", "DropdownButtonFormField");
		m.put("key", p.key);
		m.put("items", p.items);
//		m.put("selectedItemBuilder", p.selectedItemBuilder);
		m.put("value", p.value);
		m.put("hint", p.hint);
		m.put("disabledHint", p.disabledHint);
		m.put("onChanged", p.onChanged);
		m.put("onTap", p.onTap);
		m.put("elevation", p.elevation);
		m.put("style", p.style);
		m.put("icon", p.icon);
		m.put("iconDisabledColor", p.iconDisabledColor);
		m.put("iconEnabledColor", p.iconEnabledColor);
		m.put("iconSize", p.iconSize);
		m.put("isDense", p.isDense);
		m.put("isExpanded", p.isExpanded);
		m.put("itemHeight", p.itemHeight);
		m.put("focusColor", p.focusColor);
		m.put("focusNode", p.focusNode);
		m.put("autofocus", p.autofocus);
		m.put("dropdownColor", p.dropdownColor);
		m.put("decoration", p.decoration);
		m.put("onSaved", p.onSaved);
//		m.put("validator", p.validator);
		m.put("autovalidateMode", p.autovalidateMode);
		m.put("menuMaxHeight", p.menuMaxHeight);
		m.put("enableFeedback", p.enableFeedback);
		m.put("alignment", p.alignment, true);
		m.put("borderRadius", p.borderRadius);
		m.put("padding", p.padding);
		shptr<class DropdownButtonFormField> result;
		m.check(m.call(result, true));
		return result;
	}

	stdop<int64> /*var-nullable*/ DropdownMenuItem::value() {
		auto m = ManagedCall("DropdownMenuItem", "value");
		m.put("this", this);
		stdop<int64> result;
		m.call(result);
		return result;
	}

	bool /*var-non-null*/ DropdownMenuItem::enabled() {
		auto m = ManagedCall("DropdownMenuItem", "enabled");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class DropdownMenuItem> /*non-null*/ DropdownMenuItem::ctorMain(_ctorMain p) {
		auto m = ManagedCall("DropdownMenuItem", "DropdownMenuItem");
		m.put("key", p.key);
		m.put("onTap", p.onTap);
		m.put("value", p.value);
		m.put("enabled", p.enabled);
		m.put("alignment", p.alignment, true);
		m.put("child", p.child, true);
		shptr<class DropdownMenuItem> result;
		m.check(m.call(result, true));
		return result;
	}

	bool /*var-non-null*/ ExpandIcon::isExpanded() {
		auto m = ManagedCall("ExpandIcon", "isExpanded");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	double /*var-non-null*/ ExpandIcon::size() {
		auto m = ManagedCall("ExpandIcon", "size");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	shptr<class EdgeInsetsGeometry> /*var-non-null*/ ExpandIcon::padding() {
		auto m = ManagedCall("ExpandIcon", "padding");
		m.put("this", this);
		shptr<class EdgeInsetsGeometry> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*var-nullable*/ ExpandIcon::color() {
		auto m = ManagedCall("ExpandIcon", "color");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ ExpandIcon::disabledColor() {
		auto m = ManagedCall("ExpandIcon", "disabledColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ ExpandIcon::expandedColor() {
		auto m = ManagedCall("ExpandIcon", "expandedColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class ExpandIcon> /*non-null*/ ExpandIcon::ctorMain(_ctorMain p) {
		auto m = ManagedCall("ExpandIcon", "ExpandIcon");
		m.put("key", p.key);
		m.put("isExpanded", p.isExpanded);
		m.put("size", p.size);
		m.put("onPressed", p.onPressed);
		m.put("padding", p.padding, true);
		m.put("color", p.color);
		m.put("disabledColor", p.disabledColor);
		m.put("expandedColor", p.expandedColor);
		shptr<class ExpandIcon> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Widget> /*var-nullable*/ InputChip::avatar() {
		auto m = ManagedCall("InputChip", "avatar");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	shptr<class Widget> /*var-non-null*/ InputChip::label() {
		auto m = ManagedCall("InputChip", "label");
		m.put("this", this);
		shptr<class Widget> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class TextStyle> /*var-nullable*/ InputChip::labelStyle() {
		auto m = ManagedCall("InputChip", "labelStyle");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.call(result);
		return result;
	}

	shptr<class EdgeInsetsGeometry> /*var-nullable*/ InputChip::labelPadding() {
		auto m = ManagedCall("InputChip", "labelPadding");
		m.put("this", this);
		shptr<class EdgeInsetsGeometry> result;
		m.call(result);
		return result;
	}

	bool /*var-non-null*/ InputChip::selected() {
		auto m = ManagedCall("InputChip", "selected");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	bool /*var-non-null*/ InputChip::isEnabled() {
		auto m = ManagedCall("InputChip", "isEnabled");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Widget> /*var-nullable*/ InputChip::deleteIcon() {
		auto m = ManagedCall("InputChip", "deleteIcon");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ InputChip::deleteIconColor() {
		auto m = ManagedCall("InputChip", "deleteIconColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	stdop<stdstr> /*var-nullable*/ InputChip::deleteButtonTooltipMessage() {
		auto m = ManagedCall("InputChip", "deleteButtonTooltipMessage");
		m.put("this", this);
		stdop<stdstr> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ InputChip::pressElevation() {
		auto m = ManagedCall("InputChip", "pressElevation");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ InputChip::disabledColor() {
		auto m = ManagedCall("InputChip", "disabledColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ InputChip::selectedColor() {
		auto m = ManagedCall("InputChip", "selectedColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	stdop<stdstr> /*var-nullable*/ InputChip::tooltip() {
		auto m = ManagedCall("InputChip", "tooltip");
		m.put("this", this);
		stdop<stdstr> result;
		m.call(result);
		return result;
	}

	shptr<class BorderSide> /*var-nullable*/ InputChip::side() {
		auto m = ManagedCall("InputChip", "side");
		m.put("this", this);
		shptr<class BorderSide> result;
		m.call(result);
		return result;
	}

	shptr<class OutlinedBorder> /*var-nullable*/ InputChip::shape() {
		auto m = ManagedCall("InputChip", "shape");
		m.put("this", this);
		shptr<class OutlinedBorder> result;
		m.call(result);
		return result;
	}

	Clip /*var-non-null*/ InputChip::clipBehavior() {
		auto m = ManagedCall("InputChip", "clipBehavior");
		m.put("this", this);
		Clip result;
		m.check(m.call(result));
		return result;
	}

	shptr<class FocusNode> /*var-nullable*/ InputChip::focusNode() {
		auto m = ManagedCall("InputChip", "focusNode");
		m.put("this", this);
		shptr<class FocusNode> result;
		m.call(result);
		return result;
	}

	bool /*var-non-null*/ InputChip::autofocus() {
		auto m = ManagedCall("InputChip", "autofocus");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*var-nullable*/ InputChip::backgroundColor() {
		auto m = ManagedCall("InputChip", "backgroundColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class EdgeInsetsGeometry> /*var-nullable*/ InputChip::padding() {
		auto m = ManagedCall("InputChip", "padding");
		m.put("this", this);
		shptr<class EdgeInsetsGeometry> result;
		m.call(result);
		return result;
	}

	shptr<class VisualDensity> /*var-nullable*/ InputChip::visualDensity() {
		auto m = ManagedCall("InputChip", "visualDensity");
		m.put("this", this);
		shptr<class VisualDensity> result;
		m.call(result);
		return result;
	}

	stdop<MaterialTapTargetSize> /*var-nullable*/ InputChip::materialTapTargetSize() {
		auto m = ManagedCall("InputChip", "materialTapTargetSize");
		m.put("this", this);
		stdop<MaterialTapTargetSize> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ InputChip::elevation() {
		auto m = ManagedCall("InputChip", "elevation");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ InputChip::shadowColor() {
		auto m = ManagedCall("InputChip", "shadowColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ InputChip::surfaceTintColor() {
		auto m = ManagedCall("InputChip", "surfaceTintColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ InputChip::selectedShadowColor() {
		auto m = ManagedCall("InputChip", "selectedShadowColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	stdop<bool> /*var-nullable*/ InputChip::showCheckmark() {
		auto m = ManagedCall("InputChip", "showCheckmark");
		m.put("this", this);
		stdop<bool> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ InputChip::checkmarkColor() {
		auto m = ManagedCall("InputChip", "checkmarkColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class ShapeBorder> /*var-non-null*/ InputChip::avatarBorder() {
		auto m = ManagedCall("InputChip", "avatarBorder");
		m.put("this", this);
		shptr<class ShapeBorder> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class IconThemeData> /*var-nullable*/ InputChip::iconTheme() {
		auto m = ManagedCall("InputChip", "iconTheme");
		m.put("this", this);
		shptr<class IconThemeData> result;
		m.call(result);
		return result;
	}

	bool /*var-non-null*/ InputChip::useDeleteButtonTooltip() {
		auto m = ManagedCall("InputChip", "useDeleteButtonTooltip");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class InputChip> /*non-null*/ InputChip::ctorMain(_ctorMain p) {
		auto m = ManagedCall("InputChip", "InputChip");
		m.put("key", p.key);
		m.put("avatar", p.avatar);
		m.put("label", p.label, true);
		m.put("labelStyle", p.labelStyle);
		m.put("labelPadding", p.labelPadding);
		m.put("selected", p.selected);
		m.put("isEnabled", p.isEnabled);
		m.put("onSelected", p.onSelected);
		m.put("deleteIcon", p.deleteIcon);
		m.put("onDeleted", p.onDeleted);
		m.put("deleteIconColor", p.deleteIconColor);
		m.put("deleteButtonTooltipMessage", p.deleteButtonTooltipMessage);
		m.put("onPressed", p.onPressed);
		m.put("pressElevation", p.pressElevation);
		m.put("disabledColor", p.disabledColor);
		m.put("selectedColor", p.selectedColor);
		m.put("tooltip", p.tooltip);
		m.put("side", p.side);
		m.put("shape", p.shape);
		m.put("clipBehavior", p.clipBehavior);
		m.put("focusNode", p.focusNode);
		m.put("autofocus", p.autofocus);
		m.put("color", p.color);
		m.put("backgroundColor", p.backgroundColor);
		m.put("padding", p.padding);
		m.put("visualDensity", p.visualDensity);
		m.put("materialTapTargetSize", p.materialTapTargetSize);
		m.put("elevation", p.elevation);
		m.put("shadowColor", p.shadowColor);
		m.put("surfaceTintColor", p.surfaceTintColor);
		m.put("iconTheme", p.iconTheme);
		m.put("selectedShadowColor", p.selectedShadowColor);
		m.put("showCheckmark", p.showCheckmark);
		m.put("checkmarkColor", p.checkmarkColor);
		m.put("avatarBorder", p.avatarBorder, true);
		m.put("useDeleteButtonTooltip", p.useDeleteButtonTooltip);
		shptr<class InputChip> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Widget> /*var-non-null*/ MaterialBanner::content() {
		auto m = ManagedCall("MaterialBanner", "content");
		m.put("this", this);
		shptr<class Widget> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class TextStyle> /*var-nullable*/ MaterialBanner::contentTextStyle() {
		auto m = ManagedCall("MaterialBanner", "contentTextStyle");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ MaterialBanner::elevation() {
		auto m = ManagedCall("MaterialBanner", "elevation");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	shptr<class Widget> /*var-nullable*/ MaterialBanner::leading() {
		auto m = ManagedCall("MaterialBanner", "leading");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ MaterialBanner::backgroundColor() {
		auto m = ManagedCall("MaterialBanner", "backgroundColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ MaterialBanner::surfaceTintColor() {
		auto m = ManagedCall("MaterialBanner", "surfaceTintColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ MaterialBanner::shadowColor() {
		auto m = ManagedCall("MaterialBanner", "shadowColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ MaterialBanner::dividerColor() {
		auto m = ManagedCall("MaterialBanner", "dividerColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class EdgeInsetsGeometry> /*var-nullable*/ MaterialBanner::padding() {
		auto m = ManagedCall("MaterialBanner", "padding");
		m.put("this", this);
		shptr<class EdgeInsetsGeometry> result;
		m.call(result);
		return result;
	}

	shptr<class EdgeInsetsGeometry> /*var-nullable*/ MaterialBanner::margin() {
		auto m = ManagedCall("MaterialBanner", "margin");
		m.put("this", this);
		shptr<class EdgeInsetsGeometry> result;
		m.call(result);
		return result;
	}

	shptr<class EdgeInsetsGeometry> /*var-nullable*/ MaterialBanner::leadingPadding() {
		auto m = ManagedCall("MaterialBanner", "leadingPadding");
		m.put("this", this);
		shptr<class EdgeInsetsGeometry> result;
		m.call(result);
		return result;
	}

	bool /*var-non-null*/ MaterialBanner::forceActionsBelow() {
		auto m = ManagedCall("MaterialBanner", "forceActionsBelow");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	OverflowBarAlignment /*var-non-null*/ MaterialBanner::overflowAlignment() {
		auto m = ManagedCall("MaterialBanner", "overflowAlignment");
		m.put("this", this);
		OverflowBarAlignment result;
		m.check(m.call(result));
		return result;
	}

	shptr<class MaterialBanner> /*non-null*/ MaterialBanner::ctorMain(_ctorMain p) {
		auto m = ManagedCall("MaterialBanner", "MaterialBanner");
		m.put("key", p.key);
		m.put("content", p.content, true);
		m.put("contentTextStyle", p.contentTextStyle);
		m.put("actions", p.actions);
		m.put("elevation", p.elevation);
		m.put("leading", p.leading);
		m.put("backgroundColor", p.backgroundColor);
		m.put("surfaceTintColor", p.surfaceTintColor);
		m.put("shadowColor", p.shadowColor);
		m.put("dividerColor", p.dividerColor);
		m.put("padding", p.padding);
		m.put("margin", p.margin);
		m.put("leadingPadding", p.leadingPadding);
		m.put("forceActionsBelow", p.forceActionsBelow);
		m.put("overflowAlignment", p.overflowAlignment);
		m.put("animation", p.animation);
		m.put("onVisible", p.onVisible);
		shptr<class MaterialBanner> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Duration> /*var-nullable*/ NavigationBar::animationDuration() {
		auto m = ManagedCall("NavigationBar", "animationDuration");
		m.put("this", this);
		shptr<class Duration> result;
		m.call(result);
		return result;
	}

	int64 /*var-non-null*/ NavigationBar::selectedIndex() {
		auto m = ManagedCall("NavigationBar", "selectedIndex");
		m.put("this", this);
		int64 result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*var-nullable*/ NavigationBar::backgroundColor() {
		auto m = ManagedCall("NavigationBar", "backgroundColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ NavigationBar::elevation() {
		auto m = ManagedCall("NavigationBar", "elevation");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ NavigationBar::shadowColor() {
		auto m = ManagedCall("NavigationBar", "shadowColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ NavigationBar::surfaceTintColor() {
		auto m = ManagedCall("NavigationBar", "surfaceTintColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ NavigationBar::indicatorColor() {
		auto m = ManagedCall("NavigationBar", "indicatorColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class ShapeBorder> /*var-nullable*/ NavigationBar::indicatorShape() {
		auto m = ManagedCall("NavigationBar", "indicatorShape");
		m.put("this", this);
		shptr<class ShapeBorder> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ NavigationBar::height() {
		auto m = ManagedCall("NavigationBar", "height");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	stdop<NavigationDestinationLabelBehavior> /*var-nullable*/ NavigationBar::labelBehavior() {
		auto m = ManagedCall("NavigationBar", "labelBehavior");
		m.put("this", this);
		stdop<NavigationDestinationLabelBehavior> result;
		m.call(result);
		return result;
	}

	shptr<class NavigationBar> /*non-null*/ NavigationBar::ctorMain(_ctorMain p) {
		auto m = ManagedCall("NavigationBar", "NavigationBar");
		m.put("key", p.key);
		m.put("animationDuration", p.animationDuration);
		m.put("selectedIndex", p.selectedIndex);
		m.put("destinations", p.destinations);
		m.put("onDestinationSelected", p.onDestinationSelected);
		m.put("backgroundColor", p.backgroundColor);
		m.put("elevation", p.elevation);
		m.put("shadowColor", p.shadowColor);
		m.put("surfaceTintColor", p.surfaceTintColor);
		m.put("indicatorColor", p.indicatorColor);
		m.put("indicatorShape", p.indicatorShape);
		m.put("height", p.height);
		m.put("labelBehavior", p.labelBehavior);
		shptr<class NavigationBar> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Widget> /*var-non-null*/ NavigationDestination::icon() {
		auto m = ManagedCall("NavigationDestination", "icon");
		m.put("this", this);
		shptr<class Widget> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Widget> /*var-nullable*/ NavigationDestination::selectedIcon() {
		auto m = ManagedCall("NavigationDestination", "selectedIcon");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	stdstr /*var-non-null*/ NavigationDestination::label() {
		auto m = ManagedCall("NavigationDestination", "label");
		m.put("this", this);
		stdstr result;
		m.check(m.call(result));
		return result;
	}

	stdop<stdstr> /*var-nullable*/ NavigationDestination::tooltip() {
		auto m = ManagedCall("NavigationDestination", "tooltip");
		m.put("this", this);
		stdop<stdstr> result;
		m.call(result);
		return result;
	}

	shptr<class NavigationDestination> /*non-null*/ NavigationDestination::ctorMain(_ctorMain p) {
		auto m = ManagedCall("NavigationDestination", "NavigationDestination");
		m.put("key", p.key);
		m.put("icon", p.icon, true);
		m.put("selectedIcon", p.selectedIcon);
		m.put("label", p.label);
		m.put("tooltip", p.tooltip);
		shptr<class NavigationDestination> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Color> /*var-nullable*/ NavigationDrawer::backgroundColor() {
		auto m = ManagedCall("NavigationDrawer", "backgroundColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ NavigationDrawer::shadowColor() {
		auto m = ManagedCall("NavigationDrawer", "shadowColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ NavigationDrawer::surfaceTintColor() {
		auto m = ManagedCall("NavigationDrawer", "surfaceTintColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ NavigationDrawer::elevation() {
		auto m = ManagedCall("NavigationDrawer", "elevation");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ NavigationDrawer::indicatorColor() {
		auto m = ManagedCall("NavigationDrawer", "indicatorColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class ShapeBorder> /*var-nullable*/ NavigationDrawer::indicatorShape() {
		auto m = ManagedCall("NavigationDrawer", "indicatorShape");
		m.put("this", this);
		shptr<class ShapeBorder> result;
		m.call(result);
		return result;
	}

	stdop<int64> /*var-nullable*/ NavigationDrawer::selectedIndex() {
		auto m = ManagedCall("NavigationDrawer", "selectedIndex");
		m.put("this", this);
		stdop<int64> result;
		m.call(result);
		return result;
	}

	shptr<class EdgeInsetsGeometry> /*var-non-null*/ NavigationDrawer::tilePadding() {
		auto m = ManagedCall("NavigationDrawer", "tilePadding");
		m.put("this", this);
		shptr<class EdgeInsetsGeometry> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class NavigationDrawer> /*non-null*/ NavigationDrawer::ctorMain(_ctorMain p) {
		auto m = ManagedCall("NavigationDrawer", "NavigationDrawer");
		m.put("key", p.key);
		m.put("children", p.children);
		m.put("backgroundColor", p.backgroundColor);
		m.put("shadowColor", p.shadowColor);
		m.put("surfaceTintColor", p.surfaceTintColor);
		m.put("elevation", p.elevation);
		m.put("indicatorColor", p.indicatorColor);
		m.put("indicatorShape", p.indicatorShape);
		m.put("onDestinationSelected", p.onDestinationSelected);
		m.put("selectedIndex", p.selectedIndex);
		m.put("tilePadding", p.tilePadding, true);
		shptr<class NavigationDrawer> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Color> /*var-nullable*/ NavigationDrawerDestination::backgroundColor() {
		auto m = ManagedCall("NavigationDrawerDestination", "backgroundColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Widget> /*var-non-null*/ NavigationDrawerDestination::icon() {
		auto m = ManagedCall("NavigationDrawerDestination", "icon");
		m.put("this", this);
		shptr<class Widget> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Widget> /*var-nullable*/ NavigationDrawerDestination::selectedIcon() {
		auto m = ManagedCall("NavigationDrawerDestination", "selectedIcon");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	shptr<class Widget> /*var-non-null*/ NavigationDrawerDestination::label() {
		auto m = ManagedCall("NavigationDrawerDestination", "label");
		m.put("this", this);
		shptr<class Widget> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class NavigationDrawerDestination> /*non-null*/ NavigationDrawerDestination::ctorMain(_ctorMain p) {
		auto m = ManagedCall("NavigationDrawerDestination", "NavigationDrawerDestination");
		m.put("key", p.key);
		m.put("backgroundColor", p.backgroundColor);
		m.put("icon", p.icon, true);
		m.put("selectedIcon", p.selectedIcon);
		m.put("label", p.label, true);
		shptr<class NavigationDrawerDestination> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Widget> /*var-non-null*/ ScaffoldMessenger::child() {
		auto m = ManagedCall("ScaffoldMessenger", "child");
		m.put("this", this);
		shptr<class Widget> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ScaffoldMessengerState> /*non-null*/ ScaffoldMessenger::of(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("ScaffoldMessenger", "of");
		m.put("context", context, true);
		shptr<class ScaffoldMessengerState> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ScaffoldMessengerState> /*nullable*/ ScaffoldMessenger::maybeOf(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("ScaffoldMessenger", "maybeOf");
		m.put("context", context, true);
		shptr<class ScaffoldMessengerState> result;
		m.call(result);
		return result;
	}

	void ScaffoldMessengerState::showSnackBar(/*non-null*/ shptr<class SnackBar> snackBar) {
		auto m = ManagedCall("ScaffoldMessengerState", "showSnackBar");
		m.put("this", this);
		m.put("snackBar", snackBar, true);
		m.call();
	}

	void ScaffoldMessengerState::removeCurrentSnackBar(_removeCurrentSnackBar p) {
		auto m = ManagedCall("ScaffoldMessengerState", "removeCurrentSnackBar");
		m.put("this", this);
		m.put("reason", p.reason);
		m.call();
	}

	void ScaffoldMessengerState::hideCurrentSnackBar(_hideCurrentSnackBar p) {
		auto m = ManagedCall("ScaffoldMessengerState", "hideCurrentSnackBar");
		m.put("this", this);
		m.put("reason", p.reason);
		m.call();
	}

	void ScaffoldMessengerState::clearSnackBars() {
		auto m = ManagedCall("ScaffoldMessengerState", "clearSnackBars");
		m.put("this", this);
		m.call();
	}

	void ScaffoldMessengerState::showMaterialBanner(/*non-null*/ shptr<class MaterialBanner> materialBanner) {
		auto m = ManagedCall("ScaffoldMessengerState", "showMaterialBanner");
		m.put("this", this);
		m.put("materialBanner", materialBanner, true);
		m.call();
	}

	void ScaffoldMessengerState::removeCurrentMaterialBanner(_removeCurrentMaterialBanner p) {
		auto m = ManagedCall("ScaffoldMessengerState", "removeCurrentMaterialBanner");
		m.put("this", this);
		m.put("reason", p.reason);
		m.call();
	}

	void ScaffoldMessengerState::hideCurrentMaterialBanner(_hideCurrentMaterialBanner p) {
		auto m = ManagedCall("ScaffoldMessengerState", "hideCurrentMaterialBanner");
		m.put("this", this);
		m.put("reason", p.reason);
		m.call();
	}

	void ScaffoldMessengerState::clearMaterialBanners() {
		auto m = ManagedCall("ScaffoldMessengerState", "clearMaterialBanners");
		m.put("this", this);
		m.call();
	}

	stdop<int64> /*var-nullable*/ PopupMenuButton::initialValue() {
		auto m = ManagedCall("PopupMenuButton", "initialValue");
		m.put("this", this);
		stdop<int64> result;
		m.call(result);
		return result;
	}

	stdop<stdstr> /*var-nullable*/ PopupMenuButton::tooltip() {
		auto m = ManagedCall("PopupMenuButton", "tooltip");
		m.put("this", this);
		stdop<stdstr> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ PopupMenuButton::elevation() {
		auto m = ManagedCall("PopupMenuButton", "elevation");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ PopupMenuButton::shadowColor() {
		auto m = ManagedCall("PopupMenuButton", "shadowColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ PopupMenuButton::surfaceTintColor() {
		auto m = ManagedCall("PopupMenuButton", "surfaceTintColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class EdgeInsetsGeometry> /*var-non-null*/ PopupMenuButton::padding() {
		auto m = ManagedCall("PopupMenuButton", "padding");
		m.put("this", this);
		shptr<class EdgeInsetsGeometry> result;
		m.check(m.call(result));
		return result;
	}

	stdop<double> /*var-nullable*/ PopupMenuButton::splashRadius() {
		auto m = ManagedCall("PopupMenuButton", "splashRadius");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	shptr<class Widget> /*var-nullable*/ PopupMenuButton::child() {
		auto m = ManagedCall("PopupMenuButton", "child");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	shptr<class Widget> /*var-nullable*/ PopupMenuButton::icon() {
		auto m = ManagedCall("PopupMenuButton", "icon");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	shptr<class Offset> /*var-non-null*/ PopupMenuButton::offset() {
		auto m = ManagedCall("PopupMenuButton", "offset");
		m.put("this", this);
		shptr<class Offset> result;
		m.check(m.call(result));
		return result;
	}

	bool /*var-non-null*/ PopupMenuButton::enabled() {
		auto m = ManagedCall("PopupMenuButton", "enabled");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ShapeBorder> /*var-nullable*/ PopupMenuButton::shape() {
		auto m = ManagedCall("PopupMenuButton", "shape");
		m.put("this", this);
		shptr<class ShapeBorder> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ PopupMenuButton::color() {
		auto m = ManagedCall("PopupMenuButton", "color");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	stdop<bool> /*var-nullable*/ PopupMenuButton::enableFeedback() {
		auto m = ManagedCall("PopupMenuButton", "enableFeedback");
		m.put("this", this);
		stdop<bool> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ PopupMenuButton::iconSize() {
		auto m = ManagedCall("PopupMenuButton", "iconSize");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	shptr<class BoxConstraints> /*var-nullable*/ PopupMenuButton::constraints() {
		auto m = ManagedCall("PopupMenuButton", "constraints");
		m.put("this", this);
		shptr<class BoxConstraints> result;
		m.call(result);
		return result;
	}

	stdop<PopupMenuPosition> /*var-nullable*/ PopupMenuButton::position() {
		auto m = ManagedCall("PopupMenuButton", "position");
		m.put("this", this);
		stdop<PopupMenuPosition> result;
		m.call(result);
		return result;
	}

	Clip /*var-non-null*/ PopupMenuButton::clipBehavior() {
		auto m = ManagedCall("PopupMenuButton", "clipBehavior");
		m.put("this", this);
		Clip result;
		m.check(m.call(result));
		return result;
	}

	shptr<class PopupMenuButton> /*non-null*/ PopupMenuButton::ctorMain(_ctorMain p) {
		auto m = ManagedCall("PopupMenuButton", "PopupMenuButton");
		m.put("key", p.key);
		m.put("_items", p._items);
		m.put("initialValue", p.initialValue);
		m.put("onOpened", p.onOpened);
		m.put("onSelected", p.onSelected);
		m.put("onCanceled", p.onCanceled);
		m.put("tooltip", p.tooltip);
		m.put("elevation", p.elevation);
		m.put("shadowColor", p.shadowColor);
		m.put("surfaceTintColor", p.surfaceTintColor);
		m.put("padding", p.padding, true);
		m.put("child", p.child);
		m.put("splashRadius", p.splashRadius);
		m.put("icon", p.icon);
		m.put("iconSize", p.iconSize);
		m.put("offset", p.offset, true);
		m.put("enabled", p.enabled);
		m.put("shape", p.shape);
		m.put("color", p.color);
		m.put("enableFeedback", p.enableFeedback);
		m.put("constraints", p.constraints);
		m.put("position", p.position);
		m.put("clipBehavior", p.clipBehavior);
		shptr<class PopupMenuButton> result;
		m.check(m.call(result, true));
		return result;
	}

	stdop<int64> /*var-nullable*/ PopupMenuItem::value() {
		auto m = ManagedCall("PopupMenuItem", "value");
		m.put("this", this);
		stdop<int64> result;
		m.call(result);
		return result;
	}

	bool /*var-non-null*/ PopupMenuItem::enabled() {
		auto m = ManagedCall("PopupMenuItem", "enabled");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	double /*var-non-null*/ PopupMenuItem::height() {
		auto m = ManagedCall("PopupMenuItem", "height");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	shptr<class EdgeInsets> /*var-nullable*/ PopupMenuItem::padding() {
		auto m = ManagedCall("PopupMenuItem", "padding");
		m.put("this", this);
		shptr<class EdgeInsets> result;
		m.call(result);
		return result;
	}

	shptr<class TextStyle> /*var-nullable*/ PopupMenuItem::textStyle() {
		auto m = ManagedCall("PopupMenuItem", "textStyle");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.call(result);
		return result;
	}

	shptr<class MouseCursor> /*var-nullable*/ PopupMenuItem::mouseCursor() {
		auto m = ManagedCall("PopupMenuItem", "mouseCursor");
		m.put("this", this);
		shptr<class MouseCursor> result;
		m.call(result);
		return result;
	}

	shptr<class Widget> /*var-nullable*/ PopupMenuItem::child() {
		auto m = ManagedCall("PopupMenuItem", "child");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	shptr<class PopupMenuItem> /*non-null*/ PopupMenuItem::ctorMain(_ctorMain p) {
		auto m = ManagedCall("PopupMenuItem", "PopupMenuItem");
		m.put("key", p.key);
		m.put("value", p.value);
		m.put("onTap", p.onTap);
		m.put("enabled", p.enabled);
		m.put("height", p.height);
		m.put("padding", p.padding);
		m.put("textStyle", p.textStyle);
		m.put("labelTextStyle", p.labelTextStyle);
		m.put("mouseCursor", p.mouseCursor);
		m.put("child", p.child);
		shptr<class PopupMenuItem> result;
		m.check(m.call(result, true));
		return result;
	}

	bool /*var-non-null*/ CheckedPopupMenuItem::checked() {
		auto m = ManagedCall("CheckedPopupMenuItem", "checked");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Widget> /*get-nullable*/ CheckedPopupMenuItem::child() {
		auto m = ManagedCall("CheckedPopupMenuItem", "child");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	shptr<class CheckedPopupMenuItem> /*non-null*/ CheckedPopupMenuItem::ctorMain(_ctorMain p) {
		auto m = ManagedCall("CheckedPopupMenuItem", "CheckedPopupMenuItem");
		m.put("key", p.key);
		m.put("value", p.value);
		m.put("checked", p.checked);
		m.put("enabled", p.enabled);
		m.put("padding", p.padding);
		m.put("height", p.height);
		m.put("mouseCursor", p.mouseCursor);
		m.put("child", p.child);
		shptr<class CheckedPopupMenuItem> result;
		m.check(m.call(result, true));
		return result;
	}

	double /*var-non-null*/ PopupMenuDivider::height() {
		auto m = ManagedCall("PopupMenuDivider", "height");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	shptr<class PopupMenuDivider> /*non-null*/ PopupMenuDivider::ctorMain(_ctorMain p) {
		auto m = ManagedCall("PopupMenuDivider", "PopupMenuDivider");
		m.put("key", p.key);
		m.put("height", p.height);
		shptr<class PopupMenuDivider> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Color> /*var-nullable*/ SnackBarAction::textColor() {
		auto m = ManagedCall("SnackBarAction", "textColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ SnackBarAction::backgroundColor() {
		auto m = ManagedCall("SnackBarAction", "backgroundColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ SnackBarAction::disabledTextColor() {
		auto m = ManagedCall("SnackBarAction", "disabledTextColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ SnackBarAction::disabledBackgroundColor() {
		auto m = ManagedCall("SnackBarAction", "disabledBackgroundColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	stdstr /*var-non-null*/ SnackBarAction::label() {
		auto m = ManagedCall("SnackBarAction", "label");
		m.put("this", this);
		stdstr result;
		m.check(m.call(result));
		return result;
	}

	shptr<class SnackBarAction> /*non-null*/ SnackBarAction::ctorMain(_ctorMain p) {
		auto m = ManagedCall("SnackBarAction", "SnackBarAction");
		m.put("key", p.key);
		m.put("textColor", p.textColor);
		m.put("disabledTextColor", p.disabledTextColor);
		m.put("backgroundColor", p.backgroundColor);
		m.put("disabledBackgroundColor", p.disabledBackgroundColor);
		m.put("label", p.label);
		m.put("onPressed", p.onPressed, true);
		shptr<class SnackBarAction> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Widget> /*var-non-null*/ SnackBar::content() {
		auto m = ManagedCall("SnackBar", "content");
		m.put("this", this);
		shptr<class Widget> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*var-nullable*/ SnackBar::backgroundColor() {
		auto m = ManagedCall("SnackBar", "backgroundColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ SnackBar::elevation() {
		auto m = ManagedCall("SnackBar", "elevation");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	shptr<class EdgeInsetsGeometry> /*var-nullable*/ SnackBar::margin() {
		auto m = ManagedCall("SnackBar", "margin");
		m.put("this", this);
		shptr<class EdgeInsetsGeometry> result;
		m.call(result);
		return result;
	}

	shptr<class EdgeInsetsGeometry> /*var-nullable*/ SnackBar::padding() {
		auto m = ManagedCall("SnackBar", "padding");
		m.put("this", this);
		shptr<class EdgeInsetsGeometry> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ SnackBar::width() {
		auto m = ManagedCall("SnackBar", "width");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	shptr<class ShapeBorder> /*var-nullable*/ SnackBar::shape() {
		auto m = ManagedCall("SnackBar", "shape");
		m.put("this", this);
		shptr<class ShapeBorder> result;
		m.call(result);
		return result;
	}

	stdop<SnackBarBehavior> /*var-nullable*/ SnackBar::behavior() {
		auto m = ManagedCall("SnackBar", "behavior");
		m.put("this", this);
		stdop<SnackBarBehavior> result;
		m.call(result);
		return result;
	}

	shptr<class SnackBarAction> /*var-nullable*/ SnackBar::action() {
		auto m = ManagedCall("SnackBar", "action");
		m.put("this", this);
		shptr<class SnackBarAction> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ SnackBar::actionOverflowThreshold() {
		auto m = ManagedCall("SnackBar", "actionOverflowThreshold");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	stdop<bool> /*var-nullable*/ SnackBar::showCloseIcon() {
		auto m = ManagedCall("SnackBar", "showCloseIcon");
		m.put("this", this);
		stdop<bool> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ SnackBar::closeIconColor() {
		auto m = ManagedCall("SnackBar", "closeIconColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Duration> /*var-non-null*/ SnackBar::duration() {
		auto m = ManagedCall("SnackBar", "duration");
		m.put("this", this);
		shptr<class Duration> result;
		m.check(m.call(result));
		return result;
	}

	DismissDirection /*var-non-null*/ SnackBar::dismissDirection() {
		auto m = ManagedCall("SnackBar", "dismissDirection");
		m.put("this", this);
		DismissDirection result;
		m.check(m.call(result));
		return result;
	}

	Clip /*var-non-null*/ SnackBar::clipBehavior() {
		auto m = ManagedCall("SnackBar", "clipBehavior");
		m.put("this", this);
		Clip result;
		m.check(m.call(result));
		return result;
	}

	shptr<class SnackBar> /*non-null*/ SnackBar::ctorMain(_ctorMain p) {
		auto m = ManagedCall("SnackBar", "SnackBar");
		m.put("key", p.key);
		m.put("content", p.content, true);
		m.put("backgroundColor", p.backgroundColor);
		m.put("elevation", p.elevation);
		m.put("margin", p.margin);
		m.put("padding", p.padding);
		m.put("width", p.width);
		m.put("shape", p.shape);
		m.put("behavior", p.behavior);
		m.put("action", p.action);
		m.put("actionOverflowThreshold", p.actionOverflowThreshold);
		m.put("showCloseIcon", p.showCloseIcon);
		m.put("closeIconColor", p.closeIconColor);
		m.put("duration", p.duration, true);
		m.put("animation", p.animation);
		m.put("onVisible", p.onVisible);
		m.put("dismissDirection", p.dismissDirection);
		m.put("clipBehavior", p.clipBehavior);
		shptr<class SnackBar> result;
		m.check(m.call(result, true));
		return result;
	}

	int64 /*var-non-null*/ ControlsDetails::currentStep() {
		auto m = ManagedCall("ControlsDetails", "currentStep");
		m.put("this", this);
		int64 result;
		m.check(m.call(result));
		return result;
	}

	int64 /*var-non-null*/ ControlsDetails::stepIndex() {
		auto m = ManagedCall("ControlsDetails", "stepIndex");
		m.put("this", this);
		int64 result;
		m.check(m.call(result));
		return result;
	}

	bool /*get-non-null*/ ControlsDetails::isActive() {
		auto m = ManagedCall("ControlsDetails", "isActive");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ControlsDetails> /*non-null*/ ControlsDetails::ctorMain(_ctorMain p) {
		auto m = ManagedCall("ControlsDetails", "ControlsDetails");
		m.put("currentStep", p.currentStep);
		m.put("stepIndex", p.stepIndex);
		m.put("onStepCancel", p.onStepCancel);
		m.put("onStepContinue", p.onStepContinue);
		shptr<class ControlsDetails> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Widget> /*var-non-null*/ Step::title() {
		auto m = ManagedCall("Step", "title");
		m.put("this", this);
		shptr<class Widget> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Widget> /*var-nullable*/ Step::subtitle() {
		auto m = ManagedCall("Step", "subtitle");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	shptr<class Widget> /*var-non-null*/ Step::content() {
		auto m = ManagedCall("Step", "content");
		m.put("this", this);
		shptr<class Widget> result;
		m.check(m.call(result));
		return result;
	}

	StepState /*var-non-null*/ Step::state() {
		auto m = ManagedCall("Step", "state");
		m.put("this", this);
		StepState result;
		m.check(m.call(result));
		return result;
	}

	bool /*var-non-null*/ Step::isActive() {
		auto m = ManagedCall("Step", "isActive");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Widget> /*var-nullable*/ Step::label() {
		auto m = ManagedCall("Step", "label");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	shptr<class Step> /*non-null*/ Step::ctorMain(_ctorMain p) {
		auto m = ManagedCall("Step", "Step");
		m.put("title", p.title, true);
		m.put("subtitle", p.subtitle);
		m.put("content", p.content, true);
		m.put("state", p.state);
		m.put("isActive", p.isActive);
		m.put("label", p.label);
		shptr<class Step> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class ScrollPhysics> /*var-nullable*/ Stepper::physics() {
		auto m = ManagedCall("Stepper", "physics");
		m.put("this", this);
		shptr<class ScrollPhysics> result;
		m.call(result);
		return result;
	}

	shptr<class ScrollController> /*var-nullable*/ Stepper::controller() {
		auto m = ManagedCall("Stepper", "controller");
		m.put("this", this);
		shptr<class ScrollController> result;
		m.call(result);
		return result;
	}

	StepperType /*var-non-null*/ Stepper::type() {
		auto m = ManagedCall("Stepper", "type");
		m.put("this", this);
		StepperType result;
		m.check(m.call(result));
		return result;
	}

	int64 /*var-non-null*/ Stepper::currentStep() {
		auto m = ManagedCall("Stepper", "currentStep");
		m.put("this", this);
		int64 result;
		m.check(m.call(result));
		return result;
	}

	stdop<double> /*var-nullable*/ Stepper::elevation() {
		auto m = ManagedCall("Stepper", "elevation");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	shptr<class EdgeInsetsGeometry> /*var-nullable*/ Stepper::margin() {
		auto m = ManagedCall("Stepper", "margin");
		m.put("this", this);
		shptr<class EdgeInsetsGeometry> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ Stepper::connectorThickness() {
		auto m = ManagedCall("Stepper", "connectorThickness");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	shptr<class Stepper> /*non-null*/ Stepper::ctorMain(_ctorMain p) {
		auto m = ManagedCall("Stepper", "Stepper");
		m.put("key", p.key);
		m.put("steps", p.steps);
		m.put("controller", p.controller);
		m.put("physics", p.physics);
		m.put("type", p.type);
		m.put("currentStep", p.currentStep);
		m.put("onStepTapped", p.onStepTapped);
		m.put("onStepContinue", p.onStepContinue);
		m.put("onStepCancel", p.onStepCancel);
		m.put("controlsBuilder", p.controlsBuilder);
		m.put("elevation", p.elevation);
		m.put("margin", p.margin);
		m.put("connectorColor", p.connectorColor);
		m.put("connectorThickness", p.connectorThickness);
		m.put("stepIconBuilder", p.stepIconBuilder);
		shptr<class Stepper> result;
		m.check(m.call(result, true));
		return result;
	}

	stdop<bool> /*var-nullable*/ CheckboxListTile::value() {
		auto m = ManagedCall("CheckboxListTile", "value");
		m.put("this", this);
		stdop<bool> result;
		m.call(result);
		return result;
	}

	shptr<class MouseCursor> /*var-nullable*/ CheckboxListTile::mouseCursor() {
		auto m = ManagedCall("CheckboxListTile", "mouseCursor");
		m.put("this", this);
		shptr<class MouseCursor> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ CheckboxListTile::activeColor() {
		auto m = ManagedCall("CheckboxListTile", "activeColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ CheckboxListTile::checkColor() {
		auto m = ManagedCall("CheckboxListTile", "checkColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ CheckboxListTile::hoverColor() {
		auto m = ManagedCall("CheckboxListTile", "hoverColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ CheckboxListTile::splashRadius() {
		auto m = ManagedCall("CheckboxListTile", "splashRadius");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	stdop<MaterialTapTargetSize> /*var-nullable*/ CheckboxListTile::materialTapTargetSize() {
		auto m = ManagedCall("CheckboxListTile", "materialTapTargetSize");
		m.put("this", this);
		stdop<MaterialTapTargetSize> result;
		m.call(result);
		return result;
	}

	shptr<class VisualDensity> /*var-nullable*/ CheckboxListTile::visualDensity() {
		auto m = ManagedCall("CheckboxListTile", "visualDensity");
		m.put("this", this);
		shptr<class VisualDensity> result;
		m.call(result);
		return result;
	}

	shptr<class FocusNode> /*var-nullable*/ CheckboxListTile::focusNode() {
		auto m = ManagedCall("CheckboxListTile", "focusNode");
		m.put("this", this);
		shptr<class FocusNode> result;
		m.call(result);
		return result;
	}

	bool /*var-non-null*/ CheckboxListTile::autofocus() {
		auto m = ManagedCall("CheckboxListTile", "autofocus");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ShapeBorder> /*var-nullable*/ CheckboxListTile::shape() {
		auto m = ManagedCall("CheckboxListTile", "shape");
		m.put("this", this);
		shptr<class ShapeBorder> result;
		m.call(result);
		return result;
	}

	shptr<class BorderSide> /*var-nullable*/ CheckboxListTile::side() {
		auto m = ManagedCall("CheckboxListTile", "side");
		m.put("this", this);
		shptr<class BorderSide> result;
		m.call(result);
		return result;
	}

	bool /*var-non-null*/ CheckboxListTile::isError() {
		auto m = ManagedCall("CheckboxListTile", "isError");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*var-nullable*/ CheckboxListTile::tileColor() {
		auto m = ManagedCall("CheckboxListTile", "tileColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Widget> /*var-nullable*/ CheckboxListTile::title() {
		auto m = ManagedCall("CheckboxListTile", "title");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	shptr<class Widget> /*var-nullable*/ CheckboxListTile::subtitle() {
		auto m = ManagedCall("CheckboxListTile", "subtitle");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	shptr<class Widget> /*var-nullable*/ CheckboxListTile::secondary() {
		auto m = ManagedCall("CheckboxListTile", "secondary");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	bool /*var-non-null*/ CheckboxListTile::isThreeLine() {
		auto m = ManagedCall("CheckboxListTile", "isThreeLine");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	stdop<bool> /*var-nullable*/ CheckboxListTile::dense() {
		auto m = ManagedCall("CheckboxListTile", "dense");
		m.put("this", this);
		stdop<bool> result;
		m.call(result);
		return result;
	}

	bool /*var-non-null*/ CheckboxListTile::selected() {
		auto m = ManagedCall("CheckboxListTile", "selected");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	ListTileControlAffinity /*var-non-null*/ CheckboxListTile::controlAffinity() {
		auto m = ManagedCall("CheckboxListTile", "controlAffinity");
		m.put("this", this);
		ListTileControlAffinity result;
		m.check(m.call(result));
		return result;
	}

	shptr<class EdgeInsetsGeometry> /*var-nullable*/ CheckboxListTile::contentPadding() {
		auto m = ManagedCall("CheckboxListTile", "contentPadding");
		m.put("this", this);
		shptr<class EdgeInsetsGeometry> result;
		m.call(result);
		return result;
	}

	bool /*var-non-null*/ CheckboxListTile::tristate() {
		auto m = ManagedCall("CheckboxListTile", "tristate");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class OutlinedBorder> /*var-nullable*/ CheckboxListTile::checkboxShape() {
		auto m = ManagedCall("CheckboxListTile", "checkboxShape");
		m.put("this", this);
		shptr<class OutlinedBorder> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ CheckboxListTile::selectedTileColor() {
		auto m = ManagedCall("CheckboxListTile", "selectedTileColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	stdop<bool> /*var-nullable*/ CheckboxListTile::enableFeedback() {
		auto m = ManagedCall("CheckboxListTile", "enableFeedback");
		m.put("this", this);
		stdop<bool> result;
		m.call(result);
		return result;
	}

	stdop<bool> /*var-nullable*/ CheckboxListTile::enabled() {
		auto m = ManagedCall("CheckboxListTile", "enabled");
		m.put("this", this);
		stdop<bool> result;
		m.call(result);
		return result;
	}

	stdop<stdstr> /*var-nullable*/ CheckboxListTile::checkboxSemanticLabel() {
		auto m = ManagedCall("CheckboxListTile", "checkboxSemanticLabel");
		m.put("this", this);
		stdop<stdstr> result;
		m.call(result);
		return result;
	}

	shptr<class CheckboxListTile> /*non-null*/ CheckboxListTile::ctorMain(_ctorMain p) {
		auto m = ManagedCall("CheckboxListTile", "CheckboxListTile");
		m.put("key", p.key);
		m.put("value", p.value);
		m.put("onChanged", p.onChanged);
		m.put("mouseCursor", p.mouseCursor);
		m.put("activeColor", p.activeColor);
		m.put("fillColor", p.fillColor);
		m.put("checkColor", p.checkColor);
		m.put("hoverColor", p.hoverColor);
		m.put("overlayColor", p.overlayColor);
		m.put("splashRadius", p.splashRadius);
		m.put("materialTapTargetSize", p.materialTapTargetSize);
		m.put("visualDensity", p.visualDensity);
		m.put("focusNode", p.focusNode);
		m.put("autofocus", p.autofocus);
		m.put("shape", p.shape);
		m.put("side", p.side);
		m.put("isError", p.isError);
		m.put("enabled", p.enabled);
		m.put("tileColor", p.tileColor);
		m.put("title", p.title);
		m.put("subtitle", p.subtitle);
		m.put("isThreeLine", p.isThreeLine);
		m.put("dense", p.dense);
		m.put("secondary", p.secondary);
		m.put("selected", p.selected);
		m.put("controlAffinity", p.controlAffinity);
		m.put("contentPadding", p.contentPadding);
		m.put("tristate", p.tristate);
		m.put("checkboxShape", p.checkboxShape);
		m.put("selectedTileColor", p.selectedTileColor);
		m.put("onFocusChange", p.onFocusChange);
		m.put("enableFeedback", p.enableFeedback);
		m.put("checkboxSemanticLabel", p.checkboxSemanticLabel);
		shptr<class CheckboxListTile> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class CheckboxListTile> /*non-null*/ CheckboxListTile::adaptive(_adaptive p) {
		auto m = ManagedCall("CheckboxListTile", "adaptive");
		m.put("key", p.key);
		m.put("value", p.value);
		m.put("onChanged", p.onChanged);
		m.put("mouseCursor", p.mouseCursor);
		m.put("activeColor", p.activeColor);
		m.put("fillColor", p.fillColor);
		m.put("checkColor", p.checkColor);
		m.put("hoverColor", p.hoverColor);
		m.put("overlayColor", p.overlayColor);
		m.put("splashRadius", p.splashRadius);
		m.put("materialTapTargetSize", p.materialTapTargetSize);
		m.put("visualDensity", p.visualDensity);
		m.put("focusNode", p.focusNode);
		m.put("autofocus", p.autofocus);
		m.put("shape", p.shape);
		m.put("side", p.side);
		m.put("isError", p.isError);
		m.put("enabled", p.enabled);
		m.put("tileColor", p.tileColor);
		m.put("title", p.title);
		m.put("subtitle", p.subtitle);
		m.put("isThreeLine", p.isThreeLine);
		m.put("dense", p.dense);
		m.put("secondary", p.secondary);
		m.put("selected", p.selected);
		m.put("controlAffinity", p.controlAffinity);
		m.put("contentPadding", p.contentPadding);
		m.put("tristate", p.tristate);
		m.put("checkboxShape", p.checkboxShape);
		m.put("selectedTileColor", p.selectedTileColor);
		m.put("onFocusChange", p.onFocusChange);
		m.put("enableFeedback", p.enableFeedback);
		m.put("checkboxSemanticLabel", p.checkboxSemanticLabel);
		shptr<class CheckboxListTile> result;
		m.check(m.call(result, true));
		return result;
	}

	bool /*var-non-null*/ SwitchListTile::value() {
		auto m = ManagedCall("SwitchListTile", "value");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*var-nullable*/ SwitchListTile::activeColor() {
		auto m = ManagedCall("SwitchListTile", "activeColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ SwitchListTile::activeTrackColor() {
		auto m = ManagedCall("SwitchListTile", "activeTrackColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ SwitchListTile::inactiveThumbColor() {
		auto m = ManagedCall("SwitchListTile", "inactiveThumbColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ SwitchListTile::inactiveTrackColor() {
		auto m = ManagedCall("SwitchListTile", "inactiveTrackColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	stdop<MaterialTapTargetSize> /*var-nullable*/ SwitchListTile::materialTapTargetSize() {
		auto m = ManagedCall("SwitchListTile", "materialTapTargetSize");
		m.put("this", this);
		stdop<MaterialTapTargetSize> result;
		m.call(result);
		return result;
	}

	DragStartBehavior /*var-non-null*/ SwitchListTile::dragStartBehavior() {
		auto m = ManagedCall("SwitchListTile", "dragStartBehavior");
		m.put("this", this);
		DragStartBehavior result;
		m.check(m.call(result));
		return result;
	}

	shptr<class MouseCursor> /*var-nullable*/ SwitchListTile::mouseCursor() {
		auto m = ManagedCall("SwitchListTile", "mouseCursor");
		m.put("this", this);
		shptr<class MouseCursor> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ SwitchListTile::splashRadius() {
		auto m = ManagedCall("SwitchListTile", "splashRadius");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	shptr<class FocusNode> /*var-nullable*/ SwitchListTile::focusNode() {
		auto m = ManagedCall("SwitchListTile", "focusNode");
		m.put("this", this);
		shptr<class FocusNode> result;
		m.call(result);
		return result;
	}

	bool /*var-non-null*/ SwitchListTile::autofocus() {
		auto m = ManagedCall("SwitchListTile", "autofocus");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*var-nullable*/ SwitchListTile::tileColor() {
		auto m = ManagedCall("SwitchListTile", "tileColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Widget> /*var-nullable*/ SwitchListTile::title() {
		auto m = ManagedCall("SwitchListTile", "title");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	shptr<class Widget> /*var-nullable*/ SwitchListTile::subtitle() {
		auto m = ManagedCall("SwitchListTile", "subtitle");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	shptr<class Widget> /*var-nullable*/ SwitchListTile::secondary() {
		auto m = ManagedCall("SwitchListTile", "secondary");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	bool /*var-non-null*/ SwitchListTile::isThreeLine() {
		auto m = ManagedCall("SwitchListTile", "isThreeLine");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	stdop<bool> /*var-nullable*/ SwitchListTile::dense() {
		auto m = ManagedCall("SwitchListTile", "dense");
		m.put("this", this);
		stdop<bool> result;
		m.call(result);
		return result;
	}

	shptr<class EdgeInsetsGeometry> /*var-nullable*/ SwitchListTile::contentPadding() {
		auto m = ManagedCall("SwitchListTile", "contentPadding");
		m.put("this", this);
		shptr<class EdgeInsetsGeometry> result;
		m.call(result);
		return result;
	}

	bool /*var-non-null*/ SwitchListTile::selected() {
		auto m = ManagedCall("SwitchListTile", "selected");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	ListTileControlAffinity /*var-non-null*/ SwitchListTile::controlAffinity() {
		auto m = ManagedCall("SwitchListTile", "controlAffinity");
		m.put("this", this);
		ListTileControlAffinity result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ShapeBorder> /*var-nullable*/ SwitchListTile::shape() {
		auto m = ManagedCall("SwitchListTile", "shape");
		m.put("this", this);
		shptr<class ShapeBorder> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ SwitchListTile::selectedTileColor() {
		auto m = ManagedCall("SwitchListTile", "selectedTileColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class VisualDensity> /*var-nullable*/ SwitchListTile::visualDensity() {
		auto m = ManagedCall("SwitchListTile", "visualDensity");
		m.put("this", this);
		shptr<class VisualDensity> result;
		m.call(result);
		return result;
	}

	stdop<bool> /*var-nullable*/ SwitchListTile::enableFeedback() {
		auto m = ManagedCall("SwitchListTile", "enableFeedback");
		m.put("this", this);
		stdop<bool> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ SwitchListTile::hoverColor() {
		auto m = ManagedCall("SwitchListTile", "hoverColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	stdop<bool> /*var-nullable*/ SwitchListTile::applyCupertinoTheme() {
		auto m = ManagedCall("SwitchListTile", "applyCupertinoTheme");
		m.put("this", this);
		stdop<bool> result;
		m.call(result);
		return result;
	}

	shptr<class SwitchListTile> /*non-null*/ SwitchListTile::ctorMain(_ctorMain p) {
		auto m = ManagedCall("SwitchListTile", "SwitchListTile");
		m.put("key", p.key);
		m.put("value", p.value);
		m.put("onChanged", p.onChanged);
		m.put("activeColor", p.activeColor);
		m.put("activeTrackColor", p.activeTrackColor);
		m.put("inactiveThumbColor", p.inactiveThumbColor);
		m.put("inactiveTrackColor", p.inactiveTrackColor);
		m.put("activeThumbImage", p.activeThumbImage);
		m.put("onActiveThumbImageError", p.onActiveThumbImageError);
		m.put("inactiveThumbImage", p.inactiveThumbImage);
		m.put("onInactiveThumbImageError", p.onInactiveThumbImageError);
		m.put("thumbColor", p.thumbColor);
		m.put("trackColor", p.trackColor);
		m.put("trackOutlineColor", p.trackOutlineColor);
		m.put("thumbIcon", p.thumbIcon);
		m.put("materialTapTargetSize", p.materialTapTargetSize);
		m.put("dragStartBehavior", p.dragStartBehavior);
		m.put("mouseCursor", p.mouseCursor);
		m.put("overlayColor", p.overlayColor);
		m.put("splashRadius", p.splashRadius);
		m.put("focusNode", p.focusNode);
		m.put("onFocusChange", p.onFocusChange);
		m.put("autofocus", p.autofocus);
		m.put("tileColor", p.tileColor);
		m.put("title", p.title);
		m.put("subtitle", p.subtitle);
		m.put("isThreeLine", p.isThreeLine);
		m.put("dense", p.dense);
		m.put("contentPadding", p.contentPadding);
		m.put("secondary", p.secondary);
		m.put("selected", p.selected);
		m.put("controlAffinity", p.controlAffinity);
		m.put("shape", p.shape);
		m.put("selectedTileColor", p.selectedTileColor);
		m.put("visualDensity", p.visualDensity);
		m.put("enableFeedback", p.enableFeedback);
		m.put("hoverColor", p.hoverColor);
		shptr<class SwitchListTile> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class SwitchListTile> /*non-null*/ SwitchListTile::adaptive(_adaptive p) {
		auto m = ManagedCall("SwitchListTile", "adaptive");
		m.put("key", p.key);
		m.put("value", p.value);
		m.put("onChanged", p.onChanged);
		m.put("activeColor", p.activeColor);
		m.put("activeTrackColor", p.activeTrackColor);
		m.put("inactiveThumbColor", p.inactiveThumbColor);
		m.put("inactiveTrackColor", p.inactiveTrackColor);
		m.put("activeThumbImage", p.activeThumbImage);
		m.put("onActiveThumbImageError", p.onActiveThumbImageError);
		m.put("inactiveThumbImage", p.inactiveThumbImage);
		m.put("onInactiveThumbImageError", p.onInactiveThumbImageError);
		m.put("thumbColor", p.thumbColor);
		m.put("trackColor", p.trackColor);
		m.put("trackOutlineColor", p.trackOutlineColor);
		m.put("thumbIcon", p.thumbIcon);
		m.put("materialTapTargetSize", p.materialTapTargetSize);
		m.put("dragStartBehavior", p.dragStartBehavior);
		m.put("mouseCursor", p.mouseCursor);
		m.put("overlayColor", p.overlayColor);
		m.put("splashRadius", p.splashRadius);
		m.put("focusNode", p.focusNode);
		m.put("onFocusChange", p.onFocusChange);
		m.put("autofocus", p.autofocus);
		m.put("applyCupertinoTheme", p.applyCupertinoTheme);
		m.put("tileColor", p.tileColor);
		m.put("title", p.title);
		m.put("subtitle", p.subtitle);
		m.put("isThreeLine", p.isThreeLine);
		m.put("dense", p.dense);
		m.put("contentPadding", p.contentPadding);
		m.put("secondary", p.secondary);
		m.put("selected", p.selected);
		m.put("controlAffinity", p.controlAffinity);
		m.put("shape", p.shape);
		m.put("selectedTileColor", p.selectedTileColor);
		m.put("visualDensity", p.visualDensity);
		m.put("enableFeedback", p.enableFeedback);
		m.put("hoverColor", p.hoverColor);
		shptr<class SwitchListTile> result;
		m.check(m.call(result, true));
		return result;
	}

	int64 /*var-non-null*/ RadioListTile::value() {
		auto m = ManagedCall("RadioListTile", "value");
		m.put("this", this);
		int64 result;
		m.check(m.call(result));
		return result;
	}

	stdop<int64> /*var-nullable*/ RadioListTile::groupValue() {
		auto m = ManagedCall("RadioListTile", "groupValue");
		m.put("this", this);
		stdop<int64> result;
		m.call(result);
		return result;
	}

	shptr<class MouseCursor> /*var-nullable*/ RadioListTile::mouseCursor() {
		auto m = ManagedCall("RadioListTile", "mouseCursor");
		m.put("this", this);
		shptr<class MouseCursor> result;
		m.call(result);
		return result;
	}

	bool /*var-non-null*/ RadioListTile::toggleable() {
		auto m = ManagedCall("RadioListTile", "toggleable");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*var-nullable*/ RadioListTile::activeColor() {
		auto m = ManagedCall("RadioListTile", "activeColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	stdop<MaterialTapTargetSize> /*var-nullable*/ RadioListTile::materialTapTargetSize() {
		auto m = ManagedCall("RadioListTile", "materialTapTargetSize");
		m.put("this", this);
		stdop<MaterialTapTargetSize> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ RadioListTile::hoverColor() {
		auto m = ManagedCall("RadioListTile", "hoverColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ RadioListTile::splashRadius() {
		auto m = ManagedCall("RadioListTile", "splashRadius");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	shptr<class Widget> /*var-nullable*/ RadioListTile::title() {
		auto m = ManagedCall("RadioListTile", "title");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	shptr<class Widget> /*var-nullable*/ RadioListTile::subtitle() {
		auto m = ManagedCall("RadioListTile", "subtitle");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	shptr<class Widget> /*var-nullable*/ RadioListTile::secondary() {
		auto m = ManagedCall("RadioListTile", "secondary");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	bool /*var-non-null*/ RadioListTile::isThreeLine() {
		auto m = ManagedCall("RadioListTile", "isThreeLine");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	stdop<bool> /*var-nullable*/ RadioListTile::dense() {
		auto m = ManagedCall("RadioListTile", "dense");
		m.put("this", this);
		stdop<bool> result;
		m.call(result);
		return result;
	}

	bool /*var-non-null*/ RadioListTile::selected() {
		auto m = ManagedCall("RadioListTile", "selected");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	ListTileControlAffinity /*var-non-null*/ RadioListTile::controlAffinity() {
		auto m = ManagedCall("RadioListTile", "controlAffinity");
		m.put("this", this);
		ListTileControlAffinity result;
		m.check(m.call(result));
		return result;
	}

	bool /*var-non-null*/ RadioListTile::autofocus() {
		auto m = ManagedCall("RadioListTile", "autofocus");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class EdgeInsetsGeometry> /*var-nullable*/ RadioListTile::contentPadding() {
		auto m = ManagedCall("RadioListTile", "contentPadding");
		m.put("this", this);
		shptr<class EdgeInsetsGeometry> result;
		m.call(result);
		return result;
	}

	shptr<class ShapeBorder> /*var-nullable*/ RadioListTile::shape() {
		auto m = ManagedCall("RadioListTile", "shape");
		m.put("this", this);
		shptr<class ShapeBorder> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ RadioListTile::tileColor() {
		auto m = ManagedCall("RadioListTile", "tileColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ RadioListTile::selectedTileColor() {
		auto m = ManagedCall("RadioListTile", "selectedTileColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class VisualDensity> /*var-nullable*/ RadioListTile::visualDensity() {
		auto m = ManagedCall("RadioListTile", "visualDensity");
		m.put("this", this);
		shptr<class VisualDensity> result;
		m.call(result);
		return result;
	}

	shptr<class FocusNode> /*var-nullable*/ RadioListTile::focusNode() {
		auto m = ManagedCall("RadioListTile", "focusNode");
		m.put("this", this);
		shptr<class FocusNode> result;
		m.call(result);
		return result;
	}

	stdop<bool> /*var-nullable*/ RadioListTile::enableFeedback() {
		auto m = ManagedCall("RadioListTile", "enableFeedback");
		m.put("this", this);
		stdop<bool> result;
		m.call(result);
		return result;
	}

	bool /*var-non-null*/ RadioListTile::useCupertinoCheckmarkStyle() {
		auto m = ManagedCall("RadioListTile", "useCupertinoCheckmarkStyle");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	bool /*get-non-null*/ RadioListTile::checked() {
		auto m = ManagedCall("RadioListTile", "checked");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class RadioListTile> /*non-null*/ RadioListTile::ctorMain(_ctorMain p) {
		auto m = ManagedCall("RadioListTile", "RadioListTile");
		m.put("key", p.key);
		m.put("value", p.value);
		m.put("groupValue", p.groupValue);
		m.put("onChanged", p.onChanged);
		m.put("mouseCursor", p.mouseCursor);
		m.put("toggleable", p.toggleable);
		m.put("activeColor", p.activeColor);
		m.put("fillColor", p.fillColor);
		m.put("hoverColor", p.hoverColor);
		m.put("overlayColor", p.overlayColor);
		m.put("splashRadius", p.splashRadius);
		m.put("materialTapTargetSize", p.materialTapTargetSize);
		m.put("title", p.title);
		m.put("subtitle", p.subtitle);
		m.put("isThreeLine", p.isThreeLine);
		m.put("dense", p.dense);
		m.put("secondary", p.secondary);
		m.put("selected", p.selected);
		m.put("controlAffinity", p.controlAffinity);
		m.put("autofocus", p.autofocus);
		m.put("contentPadding", p.contentPadding);
		m.put("shape", p.shape);
		m.put("tileColor", p.tileColor);
		m.put("selectedTileColor", p.selectedTileColor);
		m.put("visualDensity", p.visualDensity);
		m.put("focusNode", p.focusNode);
		m.put("onFocusChange", p.onFocusChange);
		m.put("enableFeedback", p.enableFeedback);
		shptr<class RadioListTile> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class RadioListTile> /*non-null*/ RadioListTile::adaptive(_adaptive p) {
		auto m = ManagedCall("RadioListTile", "adaptive");
		m.put("key", p.key);
		m.put("value", p.value);
		m.put("groupValue", p.groupValue);
		m.put("onChanged", p.onChanged);
		m.put("mouseCursor", p.mouseCursor);
		m.put("toggleable", p.toggleable);
		m.put("activeColor", p.activeColor);
		m.put("fillColor", p.fillColor);
		m.put("hoverColor", p.hoverColor);
		m.put("overlayColor", p.overlayColor);
		m.put("splashRadius", p.splashRadius);
		m.put("materialTapTargetSize", p.materialTapTargetSize);
		m.put("title", p.title);
		m.put("subtitle", p.subtitle);
		m.put("isThreeLine", p.isThreeLine);
		m.put("dense", p.dense);
		m.put("secondary", p.secondary);
		m.put("selected", p.selected);
		m.put("controlAffinity", p.controlAffinity);
		m.put("autofocus", p.autofocus);
		m.put("contentPadding", p.contentPadding);
		m.put("shape", p.shape);
		m.put("tileColor", p.tileColor);
		m.put("selectedTileColor", p.selectedTileColor);
		m.put("visualDensity", p.visualDensity);
		m.put("focusNode", p.focusNode);
		m.put("onFocusChange", p.onFocusChange);
		m.put("enableFeedback", p.enableFeedback);
		m.put("useCupertinoCheckmarkStyle", p.useCupertinoCheckmarkStyle);
		shptr<class RadioListTile> result;
		m.check(m.call(result, true));
		return result;
	}

	int64 /*var-non-null*/ DefaultTabController::length() {
		auto m = ManagedCall("DefaultTabController", "length");
		m.put("this", this);
		int64 result;
		m.check(m.call(result));
		return result;
	}

	int64 /*var-non-null*/ DefaultTabController::initialIndex() {
		auto m = ManagedCall("DefaultTabController", "initialIndex");
		m.put("this", this);
		int64 result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Duration> /*var-nullable*/ DefaultTabController::animationDuration() {
		auto m = ManagedCall("DefaultTabController", "animationDuration");
		m.put("this", this);
		shptr<class Duration> result;
		m.call(result);
		return result;
	}

	shptr<class Widget> /*var-non-null*/ DefaultTabController::child() {
		auto m = ManagedCall("DefaultTabController", "child");
		m.put("this", this);
		shptr<class Widget> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class TabController> /*nullable*/ DefaultTabController::maybeOf(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("DefaultTabController", "maybeOf");
		m.put("context", context, true);
		shptr<class TabController> result;
		m.call(result);
		return result;
	}

	shptr<class TabController> /*non-null*/ DefaultTabController::of(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("DefaultTabController", "of");
		m.put("context", context, true);
		shptr<class TabController> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class DefaultTabController> /*non-null*/ DefaultTabController::ctorMain(_ctorMain p) {
		auto m = ManagedCall("DefaultTabController", "DefaultTabController");
		m.put("key", p.key);
		m.put("length", p.length);
		m.put("initialIndex", p.initialIndex);
		m.put("child", p.child, true);
		m.put("animationDuration", p.animationDuration);
		shptr<class DefaultTabController> result;
		m.check(m.call(result, true));
		return result;
	}

	int64 /*var-non-null*/ TabController::length() {
		auto m = ManagedCall("TabController", "length");
		m.put("this", this);
		int64 result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Animation<double>> /*get-nullable*/ TabController::animation() {
		auto m = ManagedCall("TabController", "animation");
		m.put("this", this);
		shptr<class Animation<double>> result;
		m.call(result);
		return result;
	}

	shptr<class Duration> /*get-non-null*/ TabController::animationDuration() {
		auto m = ManagedCall("TabController", "animationDuration");
		m.put("this", this);
		shptr<class Duration> result;
		m.check(m.call(result));
		return result;
	}

	int64 /*get-non-null*/ TabController::index() {
		auto m = ManagedCall("TabController", "index");
		m.put("this", this);
		int64 result;
		m.check(m.call(result));
		return result;
	}

	int64 /*get-non-null*/ TabController::previousIndex() {
		auto m = ManagedCall("TabController", "previousIndex");
		m.put("this", this);
		int64 result;
		m.check(m.call(result));
		return result;
	}

	bool /*get-non-null*/ TabController::indexIsChanging() {
		auto m = ManagedCall("TabController", "indexIsChanging");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	double /*get-non-null*/ TabController::offset() {
		auto m = ManagedCall("TabController", "offset");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	void TabController::animateTo(/*non-null*/ int64 value, _animateTo p) {
		auto m = ManagedCall("TabController", "animateTo");
		m.put("this", this);
		m.put("value", value);
		m.put("duration", p.duration);
		m.put("curve", p.curve, true);
		m.call();
	}

	void TabController::dispose() {
		auto m = ManagedCall("TabController", "dispose");
		m.put("this", this);
		m.call();
	}

	shptr<class TabController> /*non-null*/ TabController::ctorMain(_ctorMain p) {
		auto m = ManagedCall("TabController", "TabController");
		m.put("initialIndex", p.initialIndex);
		m.put("animationDuration", p.animationDuration);
		m.put("length", p.length);
		m.put("vsync", p.vsync, true);
		shptr<class TabController> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class BorderRadius> /*var-nullable*/ UnderlineTabIndicator::borderRadius() {
		auto m = ManagedCall("UnderlineTabIndicator", "borderRadius");
		m.put("this", this);
		shptr<class BorderRadius> result;
		m.call(result);
		return result;
	}

	shptr<class BorderSide> /*var-non-null*/ UnderlineTabIndicator::borderSide() {
		auto m = ManagedCall("UnderlineTabIndicator", "borderSide");
		m.put("this", this);
		shptr<class BorderSide> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class EdgeInsetsGeometry> /*var-non-null*/ UnderlineTabIndicator::insets() {
		auto m = ManagedCall("UnderlineTabIndicator", "insets");
		m.put("this", this);
		shptr<class EdgeInsetsGeometry> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Decoration> /*nullable*/ UnderlineTabIndicator::lerpFrom(/*nullable*/ shptr<class Decoration> a, /*non-null*/ double t) {
		auto m = ManagedCall("UnderlineTabIndicator", "lerpFrom");
		m.put("this", this);
		m.put("a", a);
		m.put("t", t);
		shptr<class Decoration> result;
		m.call(result);
		return result;
	}

	shptr<class Decoration> /*nullable*/ UnderlineTabIndicator::lerpTo(/*nullable*/ shptr<class Decoration> b, /*non-null*/ double t) {
		auto m = ManagedCall("UnderlineTabIndicator", "lerpTo");
		m.put("this", this);
		m.put("b", b);
		m.put("t", t);
		shptr<class Decoration> result;
		m.call(result);
		return result;
	}

	shptr<class BoxPainter> /*non-null*/ UnderlineTabIndicator::createBoxPainter(/*nullable*/ stdfunc<void()> /*() -> void*/ onChanged) {
		auto m = ManagedCall("UnderlineTabIndicator", "createBoxPainter");
		m.put("this", this);
		m.put("onChanged", onChanged);
		shptr<class BoxPainter> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Path> /*non-null*/ UnderlineTabIndicator::getClipPath(/*non-null*/ shptr<class Rect> rect, /*non-null*/ TextDirection textDirection) {
		auto m = ManagedCall("UnderlineTabIndicator", "getClipPath");
		m.put("this", this);
		m.put("rect", rect, true);
		m.put("textDirection", textDirection);
		shptr<class Path> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class UnderlineTabIndicator> /*non-null*/ UnderlineTabIndicator::ctorMain(_ctorMain p) {
		auto m = ManagedCall("UnderlineTabIndicator", "UnderlineTabIndicator");
		m.put("borderRadius", p.borderRadius);
		m.put("borderSide", p.borderSide, true);
		m.put("insets", p.insets, true);
		shptr<class UnderlineTabIndicator> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class TabController> /*var-nullable*/ TabBarView::controller() {
		auto m = ManagedCall("TabBarView", "controller");
		m.put("this", this);
		shptr<class TabController> result;
		m.call(result);
		return result;
	}

	shptr<class ScrollPhysics> /*var-nullable*/ TabBarView::physics() {
		auto m = ManagedCall("TabBarView", "physics");
		m.put("this", this);
		shptr<class ScrollPhysics> result;
		m.call(result);
		return result;
	}

	DragStartBehavior /*var-non-null*/ TabBarView::dragStartBehavior() {
		auto m = ManagedCall("TabBarView", "dragStartBehavior");
		m.put("this", this);
		DragStartBehavior result;
		m.check(m.call(result));
		return result;
	}

	double /*var-non-null*/ TabBarView::viewportFraction() {
		auto m = ManagedCall("TabBarView", "viewportFraction");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	Clip /*var-non-null*/ TabBarView::clipBehavior() {
		auto m = ManagedCall("TabBarView", "clipBehavior");
		m.put("this", this);
		Clip result;
		m.check(m.call(result));
		return result;
	}

	shptr<class TabBarView> /*non-null*/ TabBarView::ctorMain(_ctorMain p) {
		auto m = ManagedCall("TabBarView", "TabBarView");
		m.put("key", p.key);
		m.put("children", p.children);
		m.put("controller", p.controller);
		m.put("physics", p.physics);
		m.put("dragStartBehavior", p.dragStartBehavior);
		m.put("viewportFraction", p.viewportFraction);
		m.put("clipBehavior", p.clipBehavior);
		shptr<class TabBarView> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class TabController> /*var-nullable*/ TabPageSelector::controller() {
		auto m = ManagedCall("TabPageSelector", "controller");
		m.put("this", this);
		shptr<class TabController> result;
		m.call(result);
		return result;
	}

	double /*var-non-null*/ TabPageSelector::indicatorSize() {
		auto m = ManagedCall("TabPageSelector", "indicatorSize");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*var-nullable*/ TabPageSelector::color() {
		auto m = ManagedCall("TabPageSelector", "color");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ TabPageSelector::selectedColor() {
		auto m = ManagedCall("TabPageSelector", "selectedColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	stdop<BorderStyle> /*var-nullable*/ TabPageSelector::borderStyle() {
		auto m = ManagedCall("TabPageSelector", "borderStyle");
		m.put("this", this);
		stdop<BorderStyle> result;
		m.call(result);
		return result;
	}

	shptr<class TabPageSelector> /*non-null*/ TabPageSelector::ctorMain(_ctorMain p) {
		auto m = ManagedCall("TabPageSelector", "TabPageSelector");
		m.put("key", p.key);
		m.put("controller", p.controller);
		m.put("indicatorSize", p.indicatorSize);
		m.put("color", p.color);
		m.put("selectedColor", p.selectedColor);
		m.put("borderStyle", p.borderStyle);
		shptr<class TabPageSelector> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class TabController> /*var-nullable*/ TabBar::controller() {
		auto m = ManagedCall("TabBar", "controller");
		m.put("this", this);
		shptr<class TabController> result;
		m.call(result);
		return result;
	}

	bool /*var-non-null*/ TabBar::isScrollable() {
		auto m = ManagedCall("TabBar", "isScrollable");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class EdgeInsetsGeometry> /*var-nullable*/ TabBar::padding() {
		auto m = ManagedCall("TabBar", "padding");
		m.put("this", this);
		shptr<class EdgeInsetsGeometry> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ TabBar::indicatorColor() {
		auto m = ManagedCall("TabBar", "indicatorColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	double /*var-non-null*/ TabBar::indicatorWeight() {
		auto m = ManagedCall("TabBar", "indicatorWeight");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	shptr<class EdgeInsetsGeometry> /*var-non-null*/ TabBar::indicatorPadding() {
		auto m = ManagedCall("TabBar", "indicatorPadding");
		m.put("this", this);
		shptr<class EdgeInsetsGeometry> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Decoration> /*var-nullable*/ TabBar::indicator() {
		auto m = ManagedCall("TabBar", "indicator");
		m.put("this", this);
		shptr<class Decoration> result;
		m.call(result);
		return result;
	}

	bool /*var-non-null*/ TabBar::automaticIndicatorColorAdjustment() {
		auto m = ManagedCall("TabBar", "automaticIndicatorColorAdjustment");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	stdop<TabBarIndicatorSize> /*var-nullable*/ TabBar::indicatorSize() {
		auto m = ManagedCall("TabBar", "indicatorSize");
		m.put("this", this);
		stdop<TabBarIndicatorSize> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ TabBar::dividerColor() {
		auto m = ManagedCall("TabBar", "dividerColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ TabBar::labelColor() {
		auto m = ManagedCall("TabBar", "labelColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ TabBar::unselectedLabelColor() {
		auto m = ManagedCall("TabBar", "unselectedLabelColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class TextStyle> /*var-nullable*/ TabBar::labelStyle() {
		auto m = ManagedCall("TabBar", "labelStyle");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.call(result);
		return result;
	}

	shptr<class TextStyle> /*var-nullable*/ TabBar::unselectedLabelStyle() {
		auto m = ManagedCall("TabBar", "unselectedLabelStyle");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.call(result);
		return result;
	}

	shptr<class EdgeInsetsGeometry> /*var-nullable*/ TabBar::labelPadding() {
		auto m = ManagedCall("TabBar", "labelPadding");
		m.put("this", this);
		shptr<class EdgeInsetsGeometry> result;
		m.call(result);
		return result;
	}

	DragStartBehavior /*var-non-null*/ TabBar::dragStartBehavior() {
		auto m = ManagedCall("TabBar", "dragStartBehavior");
		m.put("this", this);
		DragStartBehavior result;
		m.check(m.call(result));
		return result;
	}

	shptr<class MouseCursor> /*var-nullable*/ TabBar::mouseCursor() {
		auto m = ManagedCall("TabBar", "mouseCursor");
		m.put("this", this);
		shptr<class MouseCursor> result;
		m.call(result);
		return result;
	}

	stdop<bool> /*var-nullable*/ TabBar::enableFeedback() {
		auto m = ManagedCall("TabBar", "enableFeedback");
		m.put("this", this);
		stdop<bool> result;
		m.call(result);
		return result;
	}

	shptr<class ScrollPhysics> /*var-nullable*/ TabBar::physics() {
		auto m = ManagedCall("TabBar", "physics");
		m.put("this", this);
		shptr<class ScrollPhysics> result;
		m.call(result);
		return result;
	}

	shptr<class InteractiveInkFeatureFactory> /*var-nullable*/ TabBar::splashFactory() {
		auto m = ManagedCall("TabBar", "splashFactory");
		m.put("this", this);
		shptr<class InteractiveInkFeatureFactory> result;
		m.call(result);
		return result;
	}

	shptr<class BorderRadius> /*var-nullable*/ TabBar::splashBorderRadius() {
		auto m = ManagedCall("TabBar", "splashBorderRadius");
		m.put("this", this);
		shptr<class BorderRadius> result;
		m.call(result);
		return result;
	}

	stdop<TabAlignment> /*var-nullable*/ TabBar::tabAlignment() {
		auto m = ManagedCall("TabBar", "tabAlignment");
		m.put("this", this);
		stdop<TabAlignment> result;
		m.call(result);
		return result;
	}

	shptr<class Size> /*get-non-null*/ TabBar::preferredSize() {
		auto m = ManagedCall("TabBar", "preferredSize");
		m.put("this", this);
		shptr<class Size> result;
		m.check(m.call(result));
		return result;
	}

	bool /*get-non-null*/ TabBar::tabHasTextAndIcon() {
		auto m = ManagedCall("TabBar", "tabHasTextAndIcon");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class TabBar> /*non-null*/ TabBar::ctorMain(_ctorMain p) {
		auto m = ManagedCall("TabBar", "TabBar");
		m.put("key", p.key);
		m.put("tabs", p.tabs);
		m.put("controller", p.controller);
		m.put("isScrollable", p.isScrollable);
		m.put("padding", p.padding);
		m.put("indicatorColor", p.indicatorColor);
		m.put("automaticIndicatorColorAdjustment", p.automaticIndicatorColorAdjustment);
		m.put("indicatorWeight", p.indicatorWeight);
		m.put("indicatorPadding", p.indicatorPadding, true);
		m.put("indicator", p.indicator);
		m.put("indicatorSize", p.indicatorSize);
		m.put("dividerColor", p.dividerColor);
		m.put("labelColor", p.labelColor);
		m.put("labelStyle", p.labelStyle);
		m.put("labelPadding", p.labelPadding);
		m.put("unselectedLabelColor", p.unselectedLabelColor);
		m.put("unselectedLabelStyle", p.unselectedLabelStyle);
		m.put("dragStartBehavior", p.dragStartBehavior);
		m.put("overlayColor", p.overlayColor);
		m.put("mouseCursor", p.mouseCursor);
		m.put("enableFeedback", p.enableFeedback);
		m.put("onTap", p.onTap);
		m.put("physics", p.physics);
		m.put("splashFactory", p.splashFactory);
		m.put("splashBorderRadius", p.splashBorderRadius);
		m.put("tabAlignment", p.tabAlignment);
		shptr<class TabBar> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class TabBar> /*non-null*/ TabBar::secondary(_secondary p) {
		auto m = ManagedCall("TabBar", "secondary");
		m.put("key", p.key);
		m.put("tabs", p.tabs);
		m.put("controller", p.controller);
		m.put("isScrollable", p.isScrollable);
		m.put("padding", p.padding);
		m.put("indicatorColor", p.indicatorColor);
		m.put("automaticIndicatorColorAdjustment", p.automaticIndicatorColorAdjustment);
		m.put("indicatorWeight", p.indicatorWeight);
		m.put("indicatorPadding", p.indicatorPadding, true);
		m.put("indicator", p.indicator);
		m.put("indicatorSize", p.indicatorSize);
		m.put("dividerColor", p.dividerColor);
		m.put("labelColor", p.labelColor);
		m.put("labelStyle", p.labelStyle);
		m.put("labelPadding", p.labelPadding);
		m.put("unselectedLabelColor", p.unselectedLabelColor);
		m.put("unselectedLabelStyle", p.unselectedLabelStyle);
		m.put("dragStartBehavior", p.dragStartBehavior);
		m.put("overlayColor", p.overlayColor);
		m.put("mouseCursor", p.mouseCursor);
		m.put("enableFeedback", p.enableFeedback);
		m.put("onTap", p.onTap);
		m.put("physics", p.physics);
		m.put("splashFactory", p.splashFactory);
		m.put("splashBorderRadius", p.splashBorderRadius);
		m.put("tabAlignment", p.tabAlignment);
		shptr<class TabBar> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Color> /*var-non-null*/ TabPageSelectorIndicator::backgroundColor() {
		auto m = ManagedCall("TabPageSelectorIndicator", "backgroundColor");
		m.put("this", this);
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*var-non-null*/ TabPageSelectorIndicator::borderColor() {
		auto m = ManagedCall("TabPageSelectorIndicator", "borderColor");
		m.put("this", this);
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	double /*var-non-null*/ TabPageSelectorIndicator::size() {
		auto m = ManagedCall("TabPageSelectorIndicator", "size");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	BorderStyle /*var-non-null*/ TabPageSelectorIndicator::borderStyle() {
		auto m = ManagedCall("TabPageSelectorIndicator", "borderStyle");
		m.put("this", this);
		BorderStyle result;
		m.check(m.call(result));
		return result;
	}

	shptr<class TabPageSelectorIndicator> /*non-null*/ TabPageSelectorIndicator::ctorMain(_ctorMain p) {
		auto m = ManagedCall("TabPageSelectorIndicator", "TabPageSelectorIndicator");
		m.put("key", p.key);
		m.put("backgroundColor", p.backgroundColor, true);
		m.put("borderColor", p.borderColor, true);
		m.put("size", p.size);
		m.put("borderStyle", p.borderStyle);
		shptr<class TabPageSelectorIndicator> result;
		m.check(m.call(result, true));
		return result;
	}

	stdop<stdstr> /*var-nullable*/ Tab::text() {
		auto m = ManagedCall("Tab", "text");
		m.put("this", this);
		stdop<stdstr> result;
		m.call(result);
		return result;
	}

	shptr<class Widget> /*var-nullable*/ Tab::child() {
		auto m = ManagedCall("Tab", "child");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	shptr<class Widget> /*var-nullable*/ Tab::icon() {
		auto m = ManagedCall("Tab", "icon");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	shptr<class EdgeInsetsGeometry> /*var-non-null*/ Tab::iconMargin() {
		auto m = ManagedCall("Tab", "iconMargin");
		m.put("this", this);
		shptr<class EdgeInsetsGeometry> result;
		m.check(m.call(result));
		return result;
	}

	stdop<double> /*var-nullable*/ Tab::height() {
		auto m = ManagedCall("Tab", "height");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	shptr<class Size> /*get-non-null*/ Tab::preferredSize() {
		auto m = ManagedCall("Tab", "preferredSize");
		m.put("this", this);
		shptr<class Size> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Tab> /*non-null*/ Tab::ctorMain(_ctorMain p) {
		auto m = ManagedCall("Tab", "Tab");
		m.put("key", p.key);
		m.put("text", p.text);
		m.put("icon", p.icon);
		m.put("iconMargin", p.iconMargin, true);
		m.put("height", p.height);
		m.put("child", p.child);
		shptr<class Tab> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class MouseCursor> /*var-nullable*/ ToggleButtons::mouseCursor() {
		auto m = ManagedCall("ToggleButtons", "mouseCursor");
		m.put("this", this);
		shptr<class MouseCursor> result;
		m.call(result);
		return result;
	}

	stdop<MaterialTapTargetSize> /*var-nullable*/ ToggleButtons::tapTargetSize() {
		auto m = ManagedCall("ToggleButtons", "tapTargetSize");
		m.put("this", this);
		stdop<MaterialTapTargetSize> result;
		m.call(result);
		return result;
	}

	shptr<class TextStyle> /*var-nullable*/ ToggleButtons::textStyle() {
		auto m = ManagedCall("ToggleButtons", "textStyle");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.call(result);
		return result;
	}

	shptr<class BoxConstraints> /*var-nullable*/ ToggleButtons::constraints() {
		auto m = ManagedCall("ToggleButtons", "constraints");
		m.put("this", this);
		shptr<class BoxConstraints> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ ToggleButtons::color() {
		auto m = ManagedCall("ToggleButtons", "color");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ ToggleButtons::selectedColor() {
		auto m = ManagedCall("ToggleButtons", "selectedColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ ToggleButtons::disabledColor() {
		auto m = ManagedCall("ToggleButtons", "disabledColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ ToggleButtons::fillColor() {
		auto m = ManagedCall("ToggleButtons", "fillColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ ToggleButtons::focusColor() {
		auto m = ManagedCall("ToggleButtons", "focusColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ ToggleButtons::highlightColor() {
		auto m = ManagedCall("ToggleButtons", "highlightColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ ToggleButtons::splashColor() {
		auto m = ManagedCall("ToggleButtons", "splashColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ ToggleButtons::hoverColor() {
		auto m = ManagedCall("ToggleButtons", "hoverColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	bool /*var-non-null*/ ToggleButtons::renderBorder() {
		auto m = ManagedCall("ToggleButtons", "renderBorder");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*var-nullable*/ ToggleButtons::borderColor() {
		auto m = ManagedCall("ToggleButtons", "borderColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ ToggleButtons::selectedBorderColor() {
		auto m = ManagedCall("ToggleButtons", "selectedBorderColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ ToggleButtons::disabledBorderColor() {
		auto m = ManagedCall("ToggleButtons", "disabledBorderColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ ToggleButtons::borderWidth() {
		auto m = ManagedCall("ToggleButtons", "borderWidth");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	shptr<class BorderRadius> /*var-nullable*/ ToggleButtons::borderRadius() {
		auto m = ManagedCall("ToggleButtons", "borderRadius");
		m.put("this", this);
		shptr<class BorderRadius> result;
		m.call(result);
		return result;
	}

	Axis /*var-non-null*/ ToggleButtons::direction() {
		auto m = ManagedCall("ToggleButtons", "direction");
		m.put("this", this);
		Axis result;
		m.check(m.call(result));
		return result;
	}

	VerticalDirection /*var-non-null*/ ToggleButtons::verticalDirection() {
		auto m = ManagedCall("ToggleButtons", "verticalDirection");
		m.put("this", this);
		VerticalDirection result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ToggleButtons> /*non-null*/ ToggleButtons::ctorMain(_ctorMain p) {
		auto m = ManagedCall("ToggleButtons", "ToggleButtons");
		m.put("key", p.key);
		m.put("children", p.children);
		m.put("isSelected", p.isSelected);
		m.put("onPressed", p.onPressed);
		m.put("mouseCursor", p.mouseCursor);
		m.put("tapTargetSize", p.tapTargetSize);
		m.put("textStyle", p.textStyle);
		m.put("constraints", p.constraints);
		m.put("color", p.color);
		m.put("selectedColor", p.selectedColor);
		m.put("disabledColor", p.disabledColor);
		m.put("fillColor", p.fillColor);
		m.put("focusColor", p.focusColor);
		m.put("highlightColor", p.highlightColor);
		m.put("hoverColor", p.hoverColor);
		m.put("splashColor", p.splashColor);
		m.put("focusNodes", p.focusNodes);
		m.put("renderBorder", p.renderBorder);
		m.put("borderColor", p.borderColor);
		m.put("selectedBorderColor", p.selectedBorderColor);
		m.put("disabledBorderColor", p.disabledBorderColor);
		m.put("borderRadius", p.borderRadius);
		m.put("borderWidth", p.borderWidth);
		m.put("direction", p.direction);
		m.put("verticalDirection", p.verticalDirection);
		shptr<class ToggleButtons> result;
		m.check(m.call(result, true));
		return result;
	}

	stdop<stdstr> /*var-nullable*/ Tooltip::message() {
		auto m = ManagedCall("Tooltip", "message");
		m.put("this", this);
		stdop<stdstr> result;
		m.call(result);
		return result;
	}

	shptr<class InlineSpan> /*var-nullable*/ Tooltip::richMessage() {
		auto m = ManagedCall("Tooltip", "richMessage");
		m.put("this", this);
		shptr<class InlineSpan> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ Tooltip::height() {
		auto m = ManagedCall("Tooltip", "height");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	shptr<class EdgeInsetsGeometry> /*var-nullable*/ Tooltip::padding() {
		auto m = ManagedCall("Tooltip", "padding");
		m.put("this", this);
		shptr<class EdgeInsetsGeometry> result;
		m.call(result);
		return result;
	}

	shptr<class EdgeInsetsGeometry> /*var-nullable*/ Tooltip::margin() {
		auto m = ManagedCall("Tooltip", "margin");
		m.put("this", this);
		shptr<class EdgeInsetsGeometry> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ Tooltip::verticalOffset() {
		auto m = ManagedCall("Tooltip", "verticalOffset");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	stdop<bool> /*var-nullable*/ Tooltip::preferBelow() {
		auto m = ManagedCall("Tooltip", "preferBelow");
		m.put("this", this);
		stdop<bool> result;
		m.call(result);
		return result;
	}

	stdop<bool> /*var-nullable*/ Tooltip::excludeFromSemantics() {
		auto m = ManagedCall("Tooltip", "excludeFromSemantics");
		m.put("this", this);
		stdop<bool> result;
		m.call(result);
		return result;
	}

	shptr<class Widget> /*var-nullable*/ Tooltip::child() {
		auto m = ManagedCall("Tooltip", "child");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	shptr<class Decoration> /*var-nullable*/ Tooltip::decoration() {
		auto m = ManagedCall("Tooltip", "decoration");
		m.put("this", this);
		shptr<class Decoration> result;
		m.call(result);
		return result;
	}

	shptr<class TextStyle> /*var-nullable*/ Tooltip::textStyle() {
		auto m = ManagedCall("Tooltip", "textStyle");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.call(result);
		return result;
	}

	stdop<TextAlign> /*var-nullable*/ Tooltip::textAlign() {
		auto m = ManagedCall("Tooltip", "textAlign");
		m.put("this", this);
		stdop<TextAlign> result;
		m.call(result);
		return result;
	}

	shptr<class Duration> /*var-nullable*/ Tooltip::waitDuration() {
		auto m = ManagedCall("Tooltip", "waitDuration");
		m.put("this", this);
		shptr<class Duration> result;
		m.call(result);
		return result;
	}

	shptr<class Duration> /*var-nullable*/ Tooltip::showDuration() {
		auto m = ManagedCall("Tooltip", "showDuration");
		m.put("this", this);
		shptr<class Duration> result;
		m.call(result);
		return result;
	}

	stdop<TooltipTriggerMode> /*var-nullable*/ Tooltip::triggerMode() {
		auto m = ManagedCall("Tooltip", "triggerMode");
		m.put("this", this);
		stdop<TooltipTriggerMode> result;
		m.call(result);
		return result;
	}

	stdop<bool> /*var-nullable*/ Tooltip::enableFeedback() {
		auto m = ManagedCall("Tooltip", "enableFeedback");
		m.put("this", this);
		stdop<bool> result;
		m.call(result);
		return result;
	}

	bool /*non-null*/ Tooltip::dismissAllToolTips() {
		auto m = ManagedCall("Tooltip", "dismissAllToolTips");
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Tooltip> /*non-null*/ Tooltip::ctorMain(_ctorMain p) {
		auto m = ManagedCall("Tooltip", "Tooltip");
		m.put("key", p.key);
		m.put("message", p.message);
		m.put("richMessage", p.richMessage);
		m.put("height", p.height);
		m.put("padding", p.padding);
		m.put("margin", p.margin);
		m.put("verticalOffset", p.verticalOffset);
		m.put("preferBelow", p.preferBelow);
		m.put("excludeFromSemantics", p.excludeFromSemantics);
		m.put("decoration", p.decoration);
		m.put("textStyle", p.textStyle);
		m.put("textAlign", p.textAlign);
		m.put("waitDuration", p.waitDuration);
		m.put("showDuration", p.showDuration);
		m.put("triggerMode", p.triggerMode);
		m.put("enableFeedback", p.enableFeedback);
		m.put("onTriggered", p.onTriggered);
		m.put("child", p.child);
		shptr<class Tooltip> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Color> /*var-nullable*/ Badge::backgroundColor() {
		auto m = ManagedCall("Badge", "backgroundColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ Badge::textColor() {
		auto m = ManagedCall("Badge", "textColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ Badge::smallSize() {
		auto m = ManagedCall("Badge", "smallSize");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ Badge::largeSize() {
		auto m = ManagedCall("Badge", "largeSize");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	shptr<class TextStyle> /*var-nullable*/ Badge::textStyle() {
		auto m = ManagedCall("Badge", "textStyle");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.call(result);
		return result;
	}

	shptr<class EdgeInsetsGeometry> /*var-nullable*/ Badge::padding() {
		auto m = ManagedCall("Badge", "padding");
		m.put("this", this);
		shptr<class EdgeInsetsGeometry> result;
		m.call(result);
		return result;
	}

	shptr<class AlignmentGeometry> /*var-nullable*/ Badge::alignment() {
		auto m = ManagedCall("Badge", "alignment");
		m.put("this", this);
		shptr<class AlignmentGeometry> result;
		m.call(result);
		return result;
	}

	shptr<class Offset> /*var-nullable*/ Badge::offset() {
		auto m = ManagedCall("Badge", "offset");
		m.put("this", this);
		shptr<class Offset> result;
		m.call(result);
		return result;
	}

	shptr<class Widget> /*var-nullable*/ Badge::label() {
		auto m = ManagedCall("Badge", "label");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	bool /*var-non-null*/ Badge::isLabelVisible() {
		auto m = ManagedCall("Badge", "isLabelVisible");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Widget> /*var-nullable*/ Badge::child() {
		auto m = ManagedCall("Badge", "child");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	shptr<class Badge> /*non-null*/ Badge::ctorMain(_ctorMain p) {
		auto m = ManagedCall("Badge", "Badge");
		m.put("key", p.key);
		m.put("backgroundColor", p.backgroundColor);
		m.put("textColor", p.textColor);
		m.put("smallSize", p.smallSize);
		m.put("largeSize", p.largeSize);
		m.put("textStyle", p.textStyle);
		m.put("padding", p.padding);
		m.put("alignment", p.alignment);
		m.put("offset", p.offset);
		m.put("label", p.label);
		m.put("isLabelVisible", p.isLabelVisible);
		m.put("child", p.child);
		shptr<class Badge> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Badge> /*non-null*/ Badge::count(_count p) {
		auto m = ManagedCall("Badge", "count");
		m.put("key", p.key);
		m.put("backgroundColor", p.backgroundColor);
		m.put("textColor", p.textColor);
		m.put("smallSize", p.smallSize);
		m.put("largeSize", p.largeSize);
		m.put("textStyle", p.textStyle);
		m.put("padding", p.padding);
		m.put("alignment", p.alignment);
		m.put("offset", p.offset);
		m.put("count", p.count);
		m.put("isLabelVisible", p.isLabelVisible);
		m.put("child", p.child);
		shptr<class Badge> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Widget> /*var-nullable*/ BottomAppBar::child() {
		auto m = ManagedCall("BottomAppBar", "child");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	shptr<class EdgeInsetsGeometry> /*var-nullable*/ BottomAppBar::padding() {
		auto m = ManagedCall("BottomAppBar", "padding");
		m.put("this", this);
		shptr<class EdgeInsetsGeometry> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ BottomAppBar::color() {
		auto m = ManagedCall("BottomAppBar", "color");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ BottomAppBar::elevation() {
		auto m = ManagedCall("BottomAppBar", "elevation");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	shptr<class NotchedShape> /*var-nullable*/ BottomAppBar::shape() {
		auto m = ManagedCall("BottomAppBar", "shape");
		m.put("this", this);
		shptr<class NotchedShape> result;
		m.call(result);
		return result;
	}

	Clip /*var-non-null*/ BottomAppBar::clipBehavior() {
		auto m = ManagedCall("BottomAppBar", "clipBehavior");
		m.put("this", this);
		Clip result;
		m.check(m.call(result));
		return result;
	}

	double /*var-non-null*/ BottomAppBar::notchMargin() {
		auto m = ManagedCall("BottomAppBar", "notchMargin");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*var-nullable*/ BottomAppBar::surfaceTintColor() {
		auto m = ManagedCall("BottomAppBar", "surfaceTintColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ BottomAppBar::shadowColor() {
		auto m = ManagedCall("BottomAppBar", "shadowColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ BottomAppBar::height() {
		auto m = ManagedCall("BottomAppBar", "height");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	shptr<class BottomAppBar> /*non-null*/ BottomAppBar::ctorMain(_ctorMain p) {
		auto m = ManagedCall("BottomAppBar", "BottomAppBar");
		m.put("key", p.key);
		m.put("color", p.color);
		m.put("elevation", p.elevation);
		m.put("shape", p.shape);
		m.put("clipBehavior", p.clipBehavior);
		m.put("notchMargin", p.notchMargin);
		m.put("child", p.child);
		m.put("padding", p.padding);
		m.put("surfaceTintColor", p.surfaceTintColor);
		m.put("shadowColor", p.shadowColor);
		m.put("height", p.height);
		shptr<class BottomAppBar> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Widget> /*var-nullable*/ SimpleDialog::title() {
		auto m = ManagedCall("SimpleDialog", "title");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	shptr<class EdgeInsetsGeometry> /*var-non-null*/ SimpleDialog::titlePadding() {
		auto m = ManagedCall("SimpleDialog", "titlePadding");
		m.put("this", this);
		shptr<class EdgeInsetsGeometry> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class TextStyle> /*var-nullable*/ SimpleDialog::titleTextStyle() {
		auto m = ManagedCall("SimpleDialog", "titleTextStyle");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.call(result);
		return result;
	}

	shptr<class EdgeInsetsGeometry> /*var-non-null*/ SimpleDialog::contentPadding() {
		auto m = ManagedCall("SimpleDialog", "contentPadding");
		m.put("this", this);
		shptr<class EdgeInsetsGeometry> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*var-nullable*/ SimpleDialog::backgroundColor() {
		auto m = ManagedCall("SimpleDialog", "backgroundColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ SimpleDialog::elevation() {
		auto m = ManagedCall("SimpleDialog", "elevation");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ SimpleDialog::shadowColor() {
		auto m = ManagedCall("SimpleDialog", "shadowColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ SimpleDialog::surfaceTintColor() {
		auto m = ManagedCall("SimpleDialog", "surfaceTintColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	stdop<stdstr> /*var-nullable*/ SimpleDialog::semanticLabel() {
		auto m = ManagedCall("SimpleDialog", "semanticLabel");
		m.put("this", this);
		stdop<stdstr> result;
		m.call(result);
		return result;
	}

	shptr<class EdgeInsets> /*var-non-null*/ SimpleDialog::insetPadding() {
		auto m = ManagedCall("SimpleDialog", "insetPadding");
		m.put("this", this);
		shptr<class EdgeInsets> result;
		m.check(m.call(result));
		return result;
	}

	Clip /*var-non-null*/ SimpleDialog::clipBehavior() {
		auto m = ManagedCall("SimpleDialog", "clipBehavior");
		m.put("this", this);
		Clip result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ShapeBorder> /*var-nullable*/ SimpleDialog::shape() {
		auto m = ManagedCall("SimpleDialog", "shape");
		m.put("this", this);
		shptr<class ShapeBorder> result;
		m.call(result);
		return result;
	}

	shptr<class AlignmentGeometry> /*var-nullable*/ SimpleDialog::alignment() {
		auto m = ManagedCall("SimpleDialog", "alignment");
		m.put("this", this);
		shptr<class AlignmentGeometry> result;
		m.call(result);
		return result;
	}

	shptr<class SimpleDialog> /*non-null*/ SimpleDialog::ctorMain(_ctorMain p) {
		auto m = ManagedCall("SimpleDialog", "SimpleDialog");
		m.put("key", p.key);
		m.put("title", p.title);
		m.put("titlePadding", p.titlePadding, true);
		m.put("titleTextStyle", p.titleTextStyle);
		m.put("children", p.children);
		m.put("contentPadding", p.contentPadding, true);
		m.put("backgroundColor", p.backgroundColor);
		m.put("elevation", p.elevation);
		m.put("shadowColor", p.shadowColor);
		m.put("surfaceTintColor", p.surfaceTintColor);
		m.put("semanticLabel", p.semanticLabel);
		m.put("insetPadding", p.insetPadding, true);
		m.put("clipBehavior", p.clipBehavior);
		m.put("shape", p.shape);
		m.put("alignment", p.alignment);
		shptr<class SimpleDialog> result;
		m.check(m.call(result, true));
		return result;
	}

	bool /*var-non-null*/ SegmentedButton::multiSelectionEnabled() {
		auto m = ManagedCall("SegmentedButton", "multiSelectionEnabled");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	bool /*var-non-null*/ SegmentedButton::emptySelectionAllowed() {
		auto m = ManagedCall("SegmentedButton", "emptySelectionAllowed");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ButtonStyle> /*var-nullable*/ SegmentedButton::style() {
		auto m = ManagedCall("SegmentedButton", "style");
		m.put("this", this);
		shptr<class ButtonStyle> result;
		m.call(result);
		return result;
	}

	bool /*var-non-null*/ SegmentedButton::showSelectedIcon() {
		auto m = ManagedCall("SegmentedButton", "showSelectedIcon");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Widget> /*var-nullable*/ SegmentedButton::selectedIcon() {
		auto m = ManagedCall("SegmentedButton", "selectedIcon");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	shptr<class SegmentedButton> /*non-null*/ SegmentedButton::ctorMain(_ctorMain p) {
		auto m = ManagedCall("SegmentedButton", "SegmentedButton");
		m.put("key", p.key);
		m.put("segments", p.segments);
		m.put("selected", p.selected);
		m.put("onSelectionChanged", p.onSelectionChanged);
		m.put("multiSelectionEnabled", p.multiSelectionEnabled);
		m.put("emptySelectionAllowed", p.emptySelectionAllowed);
		m.put("style", p.style);
		m.put("showSelectedIcon", p.showSelectedIcon);
		m.put("selectedIcon", p.selectedIcon);
		shptr<class SegmentedButton> result;
		m.check(m.call(result, true));
		return result;
	}

	int64 /*var-non-null*/ ButtonSegment::value() {
		auto m = ManagedCall("ButtonSegment", "value");
		m.put("this", this);
		int64 result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Widget> /*var-nullable*/ ButtonSegment::icon() {
		auto m = ManagedCall("ButtonSegment", "icon");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	shptr<class Widget> /*var-nullable*/ ButtonSegment::label() {
		auto m = ManagedCall("ButtonSegment", "label");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	stdop<stdstr> /*var-nullable*/ ButtonSegment::tooltip() {
		auto m = ManagedCall("ButtonSegment", "tooltip");
		m.put("this", this);
		stdop<stdstr> result;
		m.call(result);
		return result;
	}

	bool /*var-non-null*/ ButtonSegment::enabled() {
		auto m = ManagedCall("ButtonSegment", "enabled");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ButtonSegment> /*non-null*/ ButtonSegment::ctorMain(_ctorMain p) {
		auto m = ManagedCall("ButtonSegment", "ButtonSegment");
		m.put("value", p.value);
		m.put("icon", p.icon);
		m.put("label", p.label);
		m.put("tooltip", p.tooltip);
		m.put("enabled", p.enabled);
		shptr<class ButtonSegment> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Widget> /*var-nullable*/ CupertinoApp::home() {
		auto m = ManagedCall("CupertinoApp", "home");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	shptr<class CupertinoThemeData> /*var-nullable*/ CupertinoApp::theme() {
		auto m = ManagedCall("CupertinoApp", "theme");
		m.put("this", this);
		shptr<class CupertinoThemeData> result;
		m.call(result);
		return result;
	}

	stdop<stdstr> /*var-nullable*/ CupertinoApp::initialRoute() {
		auto m = ManagedCall("CupertinoApp", "initialRoute");
		m.put("this", this);
		stdop<stdstr> result;
		m.call(result);
		return result;
	}

	shptr<class RouteInformationProvider> /*var-nullable*/ CupertinoApp::routeInformationProvider() {
		auto m = ManagedCall("CupertinoApp", "routeInformationProvider");
		m.put("this", this);
		shptr<class RouteInformationProvider> result;
		m.call(result);
		return result;
	}

	shptr<class BackButtonDispatcher> /*var-nullable*/ CupertinoApp::backButtonDispatcher() {
		auto m = ManagedCall("CupertinoApp", "backButtonDispatcher");
		m.put("this", this);
		shptr<class BackButtonDispatcher> result;
		m.call(result);
		return result;
	}

	stdstr /*var-non-null*/ CupertinoApp::title() {
		auto m = ManagedCall("CupertinoApp", "title");
		m.put("this", this);
		stdstr result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*var-nullable*/ CupertinoApp::color() {
		auto m = ManagedCall("CupertinoApp", "color");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Locale> /*var-nullable*/ CupertinoApp::locale() {
		auto m = ManagedCall("CupertinoApp", "locale");
		m.put("this", this);
		shptr<class Locale> result;
		m.call(result);
		return result;
	}

	bool /*var-non-null*/ CupertinoApp::showPerformanceOverlay() {
		auto m = ManagedCall("CupertinoApp", "showPerformanceOverlay");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	bool /*var-non-null*/ CupertinoApp::checkerboardRasterCacheImages() {
		auto m = ManagedCall("CupertinoApp", "checkerboardRasterCacheImages");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	bool /*var-non-null*/ CupertinoApp::checkerboardOffscreenLayers() {
		auto m = ManagedCall("CupertinoApp", "checkerboardOffscreenLayers");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	bool /*var-non-null*/ CupertinoApp::showSemanticsDebugger() {
		auto m = ManagedCall("CupertinoApp", "showSemanticsDebugger");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	bool /*var-non-null*/ CupertinoApp::debugShowCheckedModeBanner() {
		auto m = ManagedCall("CupertinoApp", "debugShowCheckedModeBanner");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	stdop<stdstr> /*var-nullable*/ CupertinoApp::restorationScopeId() {
		auto m = ManagedCall("CupertinoApp", "restorationScopeId");
		m.put("this", this);
		stdop<stdstr> result;
		m.call(result);
		return result;
	}

	shptr<class ScrollBehavior> /*var-nullable*/ CupertinoApp::scrollBehavior() {
		auto m = ManagedCall("CupertinoApp", "scrollBehavior");
		m.put("this", this);
		shptr<class ScrollBehavior> result;
		m.call(result);
		return result;
	}

	bool /*var-non-null*/ CupertinoApp::useInheritedMediaQuery() {
		auto m = ManagedCall("CupertinoApp", "useInheritedMediaQuery");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class HeroController> /*non-null*/ CupertinoApp::createCupertinoHeroController() {
		auto m = ManagedCall("CupertinoApp", "createCupertinoHeroController");
		shptr<class HeroController> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class CupertinoApp> /*non-null*/ CupertinoApp::ctorMain(_ctorMain p) {
		auto m = ManagedCall("CupertinoApp", "CupertinoApp");
		m.put("key", p.key);
		m.put("navigatorKey", p.navigatorKey);
		m.put("home", p.home);
		m.put("theme", p.theme);
//		m.put("routes", p.routes, true);
		m.put("initialRoute", p.initialRoute);
//		m.put("onGenerateRoute", p.onGenerateRoute);
//		m.put("onGenerateInitialRoutes", p.onGenerateInitialRoutes);
//		m.put("onUnknownRoute", p.onUnknownRoute);
		m.put("navigatorObservers", p.navigatorObservers);
		m.put("builder", p.builder);
		m.put("title", p.title);
//		m.put("onGenerateTitle", p.onGenerateTitle);
		m.put("color", p.color);
		m.put("locale", p.locale);
//		m.put("localizationsDelegates", p.localizationsDelegates);
//		m.put("localeListResolutionCallback", p.localeListResolutionCallback);
//		m.put("localeResolutionCallback", p.localeResolutionCallback);
//		m.put("supportedLocales", p.supportedLocales, true);
		m.put("showPerformanceOverlay", p.showPerformanceOverlay);
		m.put("checkerboardRasterCacheImages", p.checkerboardRasterCacheImages);
		m.put("checkerboardOffscreenLayers", p.checkerboardOffscreenLayers);
		m.put("showSemanticsDebugger", p.showSemanticsDebugger);
		m.put("debugShowCheckedModeBanner", p.debugShowCheckedModeBanner);
//		m.put("shortcuts", p.shortcuts);
//		m.put("actions", p.actions);
		m.put("restorationScopeId", p.restorationScopeId);
		m.put("scrollBehavior", p.scrollBehavior);
		m.put("useInheritedMediaQuery", p.useInheritedMediaQuery);
		shptr<class CupertinoApp> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class ObstructingPreferredSizeWidget> /*var-nullable*/ CupertinoPageScaffold::navigationBar() {
		auto m = ManagedCall("CupertinoPageScaffold", "navigationBar");
		m.put("this", this);
		shptr<class ObstructingPreferredSizeWidget> result;
		m.call(result);
		return result;
	}

	shptr<class Widget> /*var-non-null*/ CupertinoPageScaffold::child() {
		auto m = ManagedCall("CupertinoPageScaffold", "child");
		m.put("this", this);
		shptr<class Widget> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*var-nullable*/ CupertinoPageScaffold::backgroundColor() {
		auto m = ManagedCall("CupertinoPageScaffold", "backgroundColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	bool /*var-non-null*/ CupertinoPageScaffold::resizeToAvoidBottomInset() {
		auto m = ManagedCall("CupertinoPageScaffold", "resizeToAvoidBottomInset");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class CupertinoPageScaffold> /*non-null*/ CupertinoPageScaffold::ctorMain(_ctorMain p) {
		auto m = ManagedCall("CupertinoPageScaffold", "CupertinoPageScaffold");
		m.put("key", p.key);
		m.put("navigationBar", p.navigationBar);
		m.put("backgroundColor", p.backgroundColor);
		m.put("resizeToAvoidBottomInset", p.resizeToAvoidBottomInset);
		m.put("child", p.child, true);
		shptr<class CupertinoPageScaffold> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Widget> /*var-nullable*/ CupertinoNavigationBar::leading() {
		auto m = ManagedCall("CupertinoNavigationBar", "leading");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	bool /*var-non-null*/ CupertinoNavigationBar::automaticallyImplyLeading() {
		auto m = ManagedCall("CupertinoNavigationBar", "automaticallyImplyLeading");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	bool /*var-non-null*/ CupertinoNavigationBar::automaticallyImplyMiddle() {
		auto m = ManagedCall("CupertinoNavigationBar", "automaticallyImplyMiddle");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	stdop<stdstr> /*var-nullable*/ CupertinoNavigationBar::previousPageTitle() {
		auto m = ManagedCall("CupertinoNavigationBar", "previousPageTitle");
		m.put("this", this);
		stdop<stdstr> result;
		m.call(result);
		return result;
	}

	shptr<class Widget> /*var-nullable*/ CupertinoNavigationBar::middle() {
		auto m = ManagedCall("CupertinoNavigationBar", "middle");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	shptr<class Widget> /*var-nullable*/ CupertinoNavigationBar::trailing() {
		auto m = ManagedCall("CupertinoNavigationBar", "trailing");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ CupertinoNavigationBar::backgroundColor() {
		auto m = ManagedCall("CupertinoNavigationBar", "backgroundColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	stdop<Brightness> /*var-nullable*/ CupertinoNavigationBar::brightness() {
		auto m = ManagedCall("CupertinoNavigationBar", "brightness");
		m.put("this", this);
		stdop<Brightness> result;
		m.call(result);
		return result;
	}

	shptr<class EdgeInsetsDirectional> /*var-nullable*/ CupertinoNavigationBar::padding() {
		auto m = ManagedCall("CupertinoNavigationBar", "padding");
		m.put("this", this);
		shptr<class EdgeInsetsDirectional> result;
		m.call(result);
		return result;
	}

	shptr<class Border> /*var-nullable*/ CupertinoNavigationBar::border() {
		auto m = ManagedCall("CupertinoNavigationBar", "border");
		m.put("this", this);
		shptr<class Border> result;
		m.call(result);
		return result;
	}

	bool /*var-non-null*/ CupertinoNavigationBar::transitionBetweenRoutes() {
		auto m = ManagedCall("CupertinoNavigationBar", "transitionBetweenRoutes");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Size> /*get-non-null*/ CupertinoNavigationBar::preferredSize() {
		auto m = ManagedCall("CupertinoNavigationBar", "preferredSize");
		m.put("this", this);
		shptr<class Size> result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ CupertinoNavigationBar::shouldFullyObstruct(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("CupertinoNavigationBar", "shouldFullyObstruct");
		m.put("this", this);
		m.put("context", context, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class CupertinoNavigationBar> /*non-null*/ CupertinoNavigationBar::ctorMain(_ctorMain p) {
		auto m = ManagedCall("CupertinoNavigationBar", "CupertinoNavigationBar");
		m.put("key", p.key);
		m.put("leading", p.leading);
		m.put("automaticallyImplyLeading", p.automaticallyImplyLeading);
		m.put("automaticallyImplyMiddle", p.automaticallyImplyMiddle);
		m.put("previousPageTitle", p.previousPageTitle);
		m.put("middle", p.middle);
		m.put("trailing", p.trailing);
		m.put("border", p.border);
		m.put("backgroundColor", p.backgroundColor);
		m.put("brightness", p.brightness);
		m.put("padding", p.padding);
		m.put("transitionBetweenRoutes", p.transitionBetweenRoutes);
//		m.put("heroTag", p.heroTag, true);
		shptr<class CupertinoNavigationBar> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Widget> /*var-nullable*/ CupertinoSliverNavigationBar::largeTitle() {
		auto m = ManagedCall("CupertinoSliverNavigationBar", "largeTitle");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	shptr<class Widget> /*var-nullable*/ CupertinoSliverNavigationBar::leading() {
		auto m = ManagedCall("CupertinoSliverNavigationBar", "leading");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	bool /*var-non-null*/ CupertinoSliverNavigationBar::automaticallyImplyLeading() {
		auto m = ManagedCall("CupertinoSliverNavigationBar", "automaticallyImplyLeading");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	bool /*var-non-null*/ CupertinoSliverNavigationBar::automaticallyImplyTitle() {
		auto m = ManagedCall("CupertinoSliverNavigationBar", "automaticallyImplyTitle");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	bool /*var-non-null*/ CupertinoSliverNavigationBar::alwaysShowMiddle() {
		auto m = ManagedCall("CupertinoSliverNavigationBar", "alwaysShowMiddle");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	stdop<stdstr> /*var-nullable*/ CupertinoSliverNavigationBar::previousPageTitle() {
		auto m = ManagedCall("CupertinoSliverNavigationBar", "previousPageTitle");
		m.put("this", this);
		stdop<stdstr> result;
		m.call(result);
		return result;
	}

	shptr<class Widget> /*var-nullable*/ CupertinoSliverNavigationBar::middle() {
		auto m = ManagedCall("CupertinoSliverNavigationBar", "middle");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	shptr<class Widget> /*var-nullable*/ CupertinoSliverNavigationBar::trailing() {
		auto m = ManagedCall("CupertinoSliverNavigationBar", "trailing");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ CupertinoSliverNavigationBar::backgroundColor() {
		auto m = ManagedCall("CupertinoSliverNavigationBar", "backgroundColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	stdop<Brightness> /*var-nullable*/ CupertinoSliverNavigationBar::brightness() {
		auto m = ManagedCall("CupertinoSliverNavigationBar", "brightness");
		m.put("this", this);
		stdop<Brightness> result;
		m.call(result);
		return result;
	}

	shptr<class EdgeInsetsDirectional> /*var-nullable*/ CupertinoSliverNavigationBar::padding() {
		auto m = ManagedCall("CupertinoSliverNavigationBar", "padding");
		m.put("this", this);
		shptr<class EdgeInsetsDirectional> result;
		m.call(result);
		return result;
	}

	shptr<class Border> /*var-nullable*/ CupertinoSliverNavigationBar::border() {
		auto m = ManagedCall("CupertinoSliverNavigationBar", "border");
		m.put("this", this);
		shptr<class Border> result;
		m.call(result);
		return result;
	}

	bool /*var-non-null*/ CupertinoSliverNavigationBar::transitionBetweenRoutes() {
		auto m = ManagedCall("CupertinoSliverNavigationBar", "transitionBetweenRoutes");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	bool /*var-non-null*/ CupertinoSliverNavigationBar::stretch() {
		auto m = ManagedCall("CupertinoSliverNavigationBar", "stretch");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	bool /*get-non-null*/ CupertinoSliverNavigationBar::opaque() {
		auto m = ManagedCall("CupertinoSliverNavigationBar", "opaque");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class CupertinoSliverNavigationBar> /*non-null*/ CupertinoSliverNavigationBar::ctorMain(_ctorMain p) {
		auto m = ManagedCall("CupertinoSliverNavigationBar", "CupertinoSliverNavigationBar");
		m.put("key", p.key);
		m.put("largeTitle", p.largeTitle);
		m.put("leading", p.leading);
		m.put("automaticallyImplyLeading", p.automaticallyImplyLeading);
		m.put("automaticallyImplyTitle", p.automaticallyImplyTitle);
		m.put("alwaysShowMiddle", p.alwaysShowMiddle);
		m.put("previousPageTitle", p.previousPageTitle);
		m.put("middle", p.middle);
		m.put("trailing", p.trailing);
		m.put("border", p.border);
		m.put("backgroundColor", p.backgroundColor);
		m.put("brightness", p.brightness);
		m.put("padding", p.padding);
		m.put("transitionBetweenRoutes", p.transitionBetweenRoutes);
//		m.put("heroTag", p.heroTag, true);
		m.put("stretch", p.stretch);
		shptr<class CupertinoSliverNavigationBar> result;
		m.check(m.call(result, true));
		return result;
	}

	double /*var-non-null*/ CupertinoSlider::value() {
		auto m = ManagedCall("CupertinoSlider", "value");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	double /*var-non-null*/ CupertinoSlider::minimal() {
		auto m = ManagedCall("CupertinoSlider", "min");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	double /*var-non-null*/ CupertinoSlider::maximal() {
		auto m = ManagedCall("CupertinoSlider", "max");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	stdop<int64> /*var-nullable*/ CupertinoSlider::divisions() {
		auto m = ManagedCall("CupertinoSlider", "divisions");
		m.put("this", this);
		stdop<int64> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ CupertinoSlider::activeColor() {
		auto m = ManagedCall("CupertinoSlider", "activeColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-non-null*/ CupertinoSlider::thumbColor() {
		auto m = ManagedCall("CupertinoSlider", "thumbColor");
		m.put("this", this);
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class CupertinoSlider> /*non-null*/ CupertinoSlider::ctorMain(_ctorMain p) {
		auto m = ManagedCall("CupertinoSlider", "CupertinoSlider");
		m.put("key", p.key);
		m.put("value", p.value);
		m.put("onChanged", p.onChanged);
		m.put("onChangeStart", p.onChangeStart);
		m.put("onChangeEnd", p.onChangeEnd);
		m.put("min", p.min);
		m.put("max", p.max);
		m.put("divisions", p.divisions);
		m.put("activeColor", p.activeColor);
		m.put("thumbColor", p.thumbColor, true);
		shptr<class CupertinoSlider> result;
		m.check(m.call(result, true));
		return result;
	}

	bool /*var-non-null*/ CupertinoSwitch::value() {
		auto m = ManagedCall("CupertinoSwitch", "value");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*var-nullable*/ CupertinoSwitch::activeColor() {
		auto m = ManagedCall("CupertinoSwitch", "activeColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ CupertinoSwitch::trackColor() {
		auto m = ManagedCall("CupertinoSwitch", "trackColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ CupertinoSwitch::thumbColor() {
		auto m = ManagedCall("CupertinoSwitch", "thumbColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ CupertinoSwitch::focusColor() {
		auto m = ManagedCall("CupertinoSwitch", "focusColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class FocusNode> /*var-nullable*/ CupertinoSwitch::focusNode() {
		auto m = ManagedCall("CupertinoSwitch", "focusNode");
		m.put("this", this);
		shptr<class FocusNode> result;
		m.call(result);
		return result;
	}

	bool /*var-non-null*/ CupertinoSwitch::autofocus() {
		auto m = ManagedCall("CupertinoSwitch", "autofocus");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	stdop<bool> /*var-nullable*/ CupertinoSwitch::applyTheme() {
		auto m = ManagedCall("CupertinoSwitch", "applyTheme");
		m.put("this", this);
		stdop<bool> result;
		m.call(result);
		return result;
	}

	DragStartBehavior /*var-non-null*/ CupertinoSwitch::dragStartBehavior() {
		auto m = ManagedCall("CupertinoSwitch", "dragStartBehavior");
		m.put("this", this);
		DragStartBehavior result;
		m.check(m.call(result));
		return result;
	}

	shptr<class CupertinoSwitch> /*non-null*/ CupertinoSwitch::ctorMain(_ctorMain p) {
		auto m = ManagedCall("CupertinoSwitch", "CupertinoSwitch");
		m.put("key", p.key);
		m.put("value", p.value);
		m.put("onChanged", p.onChanged);
		m.put("activeColor", p.activeColor);
		m.put("trackColor", p.trackColor);
		m.put("thumbColor", p.thumbColor);
		m.put("applyTheme", p.applyTheme);
		m.put("focusColor", p.focusColor);
		m.put("focusNode", p.focusNode);
		m.put("onFocusChange", p.onFocusChange);
		m.put("autofocus", p.autofocus);
		m.put("dragStartBehavior", p.dragStartBehavior);
		shptr<class CupertinoSwitch> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Color> /*var-nullable*/ CupertinoActivityIndicator::color() {
		auto m = ManagedCall("CupertinoActivityIndicator", "color");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	bool /*var-non-null*/ CupertinoActivityIndicator::animating() {
		auto m = ManagedCall("CupertinoActivityIndicator", "animating");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	double /*var-non-null*/ CupertinoActivityIndicator::radius() {
		auto m = ManagedCall("CupertinoActivityIndicator", "radius");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	double /*var-non-null*/ CupertinoActivityIndicator::progress() {
		auto m = ManagedCall("CupertinoActivityIndicator", "progress");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	shptr<class CupertinoActivityIndicator> /*non-null*/ CupertinoActivityIndicator::ctorMain(_ctorMain p) {
		auto m = ManagedCall("CupertinoActivityIndicator", "CupertinoActivityIndicator");
		m.put("key", p.key);
		m.put("color", p.color);
		m.put("animating", p.animating);
		m.put("radius", p.radius);
		shptr<class CupertinoActivityIndicator> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class CupertinoActivityIndicator> /*non-null*/ CupertinoActivityIndicator::partiallyRevealed(_partiallyRevealed p) {
		auto m = ManagedCall("CupertinoActivityIndicator", "partiallyRevealed");
		m.put("key", p.key);
		m.put("color", p.color);
		m.put("radius", p.radius);
		m.put("progress", p.progress);
		shptr<class CupertinoActivityIndicator> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Widget> /*var-non-null*/ CupertinoButton::child() {
		auto m = ManagedCall("CupertinoButton", "child");
		m.put("this", this);
		shptr<class Widget> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class EdgeInsetsGeometry> /*var-nullable*/ CupertinoButton::padding() {
		auto m = ManagedCall("CupertinoButton", "padding");
		m.put("this", this);
		shptr<class EdgeInsetsGeometry> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ CupertinoButton::color() {
		auto m = ManagedCall("CupertinoButton", "color");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-non-null*/ CupertinoButton::disabledColor() {
		auto m = ManagedCall("CupertinoButton", "disabledColor");
		m.put("this", this);
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	stdop<double> /*var-nullable*/ CupertinoButton::minSize() {
		auto m = ManagedCall("CupertinoButton", "minSize");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ CupertinoButton::pressedOpacity() {
		auto m = ManagedCall("CupertinoButton", "pressedOpacity");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	shptr<class BorderRadius> /*var-nullable*/ CupertinoButton::borderRadius() {
		auto m = ManagedCall("CupertinoButton", "borderRadius");
		m.put("this", this);
		shptr<class BorderRadius> result;
		m.call(result);
		return result;
	}

	shptr<class AlignmentGeometry> /*var-non-null*/ CupertinoButton::alignment() {
		auto m = ManagedCall("CupertinoButton", "alignment");
		m.put("this", this);
		shptr<class AlignmentGeometry> result;
		m.check(m.call(result));
		return result;
	}

	bool /*get-non-null*/ CupertinoButton::enabled() {
		auto m = ManagedCall("CupertinoButton", "enabled");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class CupertinoButton> /*non-null*/ CupertinoButton::ctorMain(_ctorMain p) {
		auto m = ManagedCall("CupertinoButton", "CupertinoButton");
		m.put("key", p.key);
		m.put("child", p.child, true);
		m.put("padding", p.padding);
		m.put("color", p.color);
		m.put("disabledColor", p.disabledColor, true);
		m.put("minSize", p.minSize);
		m.put("pressedOpacity", p.pressedOpacity);
		m.put("borderRadius", p.borderRadius);
		m.put("alignment", p.alignment, true);
		m.put("onPressed", p.onPressed);
		shptr<class CupertinoButton> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class CupertinoButton> /*non-null*/ CupertinoButton::filled(_filled p) {
		auto m = ManagedCall("CupertinoButton", "filled");
		m.put("key", p.key);
		m.put("child", p.child, true);
		m.put("padding", p.padding);
		m.put("disabledColor", p.disabledColor, true);
		m.put("minSize", p.minSize);
		m.put("pressedOpacity", p.pressedOpacity);
		m.put("borderRadius", p.borderRadius);
		m.put("alignment", p.alignment, true);
		m.put("onPressed", p.onPressed);
		shptr<class CupertinoButton> result;
		m.check(m.call(result, true));
		return result;
	}

	stdop<bool> /*var-nullable*/ CupertinoCheckbox::value() {
		auto m = ManagedCall("CupertinoCheckbox", "value");
		m.put("this", this);
		stdop<bool> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ CupertinoCheckbox::activeColor() {
		auto m = ManagedCall("CupertinoCheckbox", "activeColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ CupertinoCheckbox::inactiveColor() {
		auto m = ManagedCall("CupertinoCheckbox", "inactiveColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ CupertinoCheckbox::checkColor() {
		auto m = ManagedCall("CupertinoCheckbox", "checkColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	bool /*var-non-null*/ CupertinoCheckbox::tristate() {
		auto m = ManagedCall("CupertinoCheckbox", "tristate");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*var-nullable*/ CupertinoCheckbox::focusColor() {
		auto m = ManagedCall("CupertinoCheckbox", "focusColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class FocusNode> /*var-nullable*/ CupertinoCheckbox::focusNode() {
		auto m = ManagedCall("CupertinoCheckbox", "focusNode");
		m.put("this", this);
		shptr<class FocusNode> result;
		m.call(result);
		return result;
	}

	bool /*var-non-null*/ CupertinoCheckbox::autofocus() {
		auto m = ManagedCall("CupertinoCheckbox", "autofocus");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class BorderSide> /*var-nullable*/ CupertinoCheckbox::side() {
		auto m = ManagedCall("CupertinoCheckbox", "side");
		m.put("this", this);
		shptr<class BorderSide> result;
		m.call(result);
		return result;
	}

	shptr<class OutlinedBorder> /*var-nullable*/ CupertinoCheckbox::shape() {
		auto m = ManagedCall("CupertinoCheckbox", "shape");
		m.put("this", this);
		shptr<class OutlinedBorder> result;
		m.call(result);
		return result;
	}

	double /*var-non-null*/ CupertinoCheckbox::width() {
		auto m = ManagedCall("CupertinoCheckbox", "width");
		double result;
		m.check(m.call(result));
		return result;
	}

	shptr<class CupertinoCheckbox> /*non-null*/ CupertinoCheckbox::ctorMain(_ctorMain p) {
		auto m = ManagedCall("CupertinoCheckbox", "CupertinoCheckbox");
		m.put("key", p.key);
		m.put("value", p.value);
		m.put("tristate", p.tristate);
		m.put("onChanged", p.onChanged);
		m.put("activeColor", p.activeColor);
		m.put("inactiveColor", p.inactiveColor);
		m.put("checkColor", p.checkColor);
		m.put("focusColor", p.focusColor);
		m.put("focusNode", p.focusNode);
		m.put("autofocus", p.autofocus);
		m.put("side", p.side);
		m.put("shape", p.shape);
		shptr<class CupertinoCheckbox> result;
		m.check(m.call(result, true));
		return result;
	}

	double /*var-non-null*/ CupertinoContextMenu::kOpenBorderRadius() {
		auto m = ManagedCall("CupertinoContextMenu", "kOpenBorderRadius");
		double result;
		m.check(m.call(result));
		return result;
	}

	double /*var-non-null*/ CupertinoContextMenu::animationOpensAt() {
		auto m = ManagedCall("CupertinoContextMenu", "animationOpensAt");
		double result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Widget> /*var-nullable*/ CupertinoContextMenu::child() {
		auto m = ManagedCall("CupertinoContextMenu", "child");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	bool /*var-non-null*/ CupertinoContextMenu::enableHapticFeedback() {
		auto m = ManagedCall("CupertinoContextMenu", "enableHapticFeedback");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class CupertinoContextMenu> /*non-null*/ CupertinoContextMenu::ctorMain(_ctorMain p) {
		auto m = ManagedCall("CupertinoContextMenu", "CupertinoContextMenu");
		m.put("key", p.key);
		m.put("actions", p.actions);
		m.put("child", p.child, true);
		m.put("enableHapticFeedback", p.enableHapticFeedback);
		//		m.put("previewBuilder", p.previewBuilder);
		shptr<class CupertinoContextMenu> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class CupertinoContextMenu> /*non-null*/ CupertinoContextMenu::builder(_builder p) {
		auto m = ManagedCall("CupertinoContextMenu", "builder");
		m.put("key", p.key);
		m.put("actions", p.actions);
		m.put("builder", p.builder, true);
		m.put("enableHapticFeedback", p.enableHapticFeedback);
		shptr<class CupertinoContextMenu> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Widget> /*var-non-null*/ CupertinoContextMenuAction::child() {
		auto m = ManagedCall("CupertinoContextMenuAction", "child");
		m.put("this", this);
		shptr<class Widget> result;
		m.check(m.call(result));
		return result;
	}

	bool /*var-non-null*/ CupertinoContextMenuAction::isDefaultAction() {
		auto m = ManagedCall("CupertinoContextMenuAction", "isDefaultAction");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	bool /*var-non-null*/ CupertinoContextMenuAction::isDestructiveAction() {
		auto m = ManagedCall("CupertinoContextMenuAction", "isDestructiveAction");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class IconData> /*var-nullable*/ CupertinoContextMenuAction::trailingIcon() {
		auto m = ManagedCall("CupertinoContextMenuAction", "trailingIcon");
		m.put("this", this);
		shptr<class IconData> result;
		m.call(result);
		return result;
	}

	shptr<class CupertinoContextMenuAction> /*non-null*/ CupertinoContextMenuAction::ctorMain(_ctorMain p) {
		auto m = ManagedCall("CupertinoContextMenuAction", "CupertinoContextMenuAction");
		m.put("key", p.key);
		m.put("child", p.child, true);
		m.put("isDefaultAction", p.isDefaultAction);
		m.put("isDestructiveAction", p.isDestructiveAction);
		m.put("onPressed", p.onPressed);
		m.put("trailingIcon", p.trailingIcon);
		shptr<class CupertinoContextMenuAction> result;
		m.check(m.call(result, true));
		return result;
	}

	CupertinoDatePickerMode /*var-non-null*/ CupertinoDatePicker::mode() {
		auto m = ManagedCall("CupertinoDatePicker", "mode");
		m.put("this", this);
		CupertinoDatePickerMode result;
		m.check(m.call(result));
		return result;
	}

	shptr<class DateTime> /*var-non-null*/ CupertinoDatePicker::initialDateTime() {
		auto m = ManagedCall("CupertinoDatePicker", "initialDateTime");
		m.put("this", this);
		shptr<class DateTime> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class DateTime> /*var-nullable*/ CupertinoDatePicker::minimumDate() {
		auto m = ManagedCall("CupertinoDatePicker", "minimumDate");
		m.put("this", this);
		shptr<class DateTime> result;
		m.call(result);
		return result;
	}

	shptr<class DateTime> /*var-nullable*/ CupertinoDatePicker::maximumDate() {
		auto m = ManagedCall("CupertinoDatePicker", "maximumDate");
		m.put("this", this);
		shptr<class DateTime> result;
		m.call(result);
		return result;
	}

	int64 /*var-non-null*/ CupertinoDatePicker::minimumYear() {
		auto m = ManagedCall("CupertinoDatePicker", "minimumYear");
		m.put("this", this);
		int64 result;
		m.check(m.call(result));
		return result;
	}

	stdop<int64> /*var-nullable*/ CupertinoDatePicker::maximumYear() {
		auto m = ManagedCall("CupertinoDatePicker", "maximumYear");
		m.put("this", this);
		stdop<int64> result;
		m.call(result);
		return result;
	}

	int64 /*var-non-null*/ CupertinoDatePicker::minuteInterval() {
		auto m = ManagedCall("CupertinoDatePicker", "minuteInterval");
		m.put("this", this);
		int64 result;
		m.check(m.call(result));
		return result;
	}

	bool /*var-non-null*/ CupertinoDatePicker::use24hFormat() {
		auto m = ManagedCall("CupertinoDatePicker", "use24hFormat");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	stdop<DatePickerDateOrder> /*var-nullable*/ CupertinoDatePicker::dateOrder() {
		auto m = ManagedCall("CupertinoDatePicker", "dateOrder");
		m.put("this", this);
		stdop<DatePickerDateOrder> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ CupertinoDatePicker::backgroundColor() {
		auto m = ManagedCall("CupertinoDatePicker", "backgroundColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	bool /*var-non-null*/ CupertinoDatePicker::showDayOfWeek() {
		auto m = ManagedCall("CupertinoDatePicker", "showDayOfWeek");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	double /*var-non-null*/ CupertinoDatePicker::itemExtent() {
		auto m = ManagedCall("CupertinoDatePicker", "itemExtent");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	shptr<class CupertinoDatePicker> /*non-null*/ CupertinoDatePicker::ctorMain(_ctorMain p) {
		auto m = ManagedCall("CupertinoDatePicker", "CupertinoDatePicker");
		m.put("key", p.key);
		m.put("mode", p.mode);
		m.put("onDateTimeChanged", p.onDateTimeChanged, true);
		m.put("initialDateTime", p.initialDateTime);
		m.put("minimumDate", p.minimumDate);
		m.put("maximumDate", p.maximumDate);
		m.put("minimumYear", p.minimumYear);
		m.put("maximumYear", p.maximumYear);
		m.put("minuteInterval", p.minuteInterval);
		m.put("use24hFormat", p.use24hFormat);
		m.put("dateOrder", p.dateOrder);
		m.put("backgroundColor", p.backgroundColor);
		m.put("showDayOfWeek", p.showDayOfWeek);
		m.put("itemExtent", p.itemExtent);
		shptr<class CupertinoDatePicker> result;
		m.check(m.call(result, true));
		return result;
	}

	CupertinoTimerPickerMode /*var-non-null*/ CupertinoTimerPicker::mode() {
		auto m = ManagedCall("CupertinoTimerPicker", "mode");
		m.put("this", this);
		CupertinoTimerPickerMode result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Duration> /*var-non-null*/ CupertinoTimerPicker::initialTimerDuration() {
		auto m = ManagedCall("CupertinoTimerPicker", "initialTimerDuration");
		m.put("this", this);
		shptr<class Duration> result;
		m.check(m.call(result));
		return result;
	}

	int64 /*var-non-null*/ CupertinoTimerPicker::minuteInterval() {
		auto m = ManagedCall("CupertinoTimerPicker", "minuteInterval");
		m.put("this", this);
		int64 result;
		m.check(m.call(result));
		return result;
	}

	int64 /*var-non-null*/ CupertinoTimerPicker::secondInterval() {
		auto m = ManagedCall("CupertinoTimerPicker", "secondInterval");
		m.put("this", this);
		int64 result;
		m.check(m.call(result));
		return result;
	}

	shptr<class AlignmentGeometry> /*var-non-null*/ CupertinoTimerPicker::alignment() {
		auto m = ManagedCall("CupertinoTimerPicker", "alignment");
		m.put("this", this);
		shptr<class AlignmentGeometry> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*var-nullable*/ CupertinoTimerPicker::backgroundColor() {
		auto m = ManagedCall("CupertinoTimerPicker", "backgroundColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	double /*var-non-null*/ CupertinoTimerPicker::itemExtent() {
		auto m = ManagedCall("CupertinoTimerPicker", "itemExtent");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	shptr<class CupertinoTimerPicker> /*non-null*/ CupertinoTimerPicker::ctorMain(_ctorMain p) {
		auto m = ManagedCall("CupertinoTimerPicker", "CupertinoTimerPicker");
		m.put("key", p.key);
		m.put("mode", p.mode);
		m.put("initialTimerDuration", p.initialTimerDuration, true);
		m.put("minuteInterval", p.minuteInterval);
		m.put("secondInterval", p.secondInterval);
		m.put("alignment", p.alignment, true);
		m.put("backgroundColor", p.backgroundColor);
		m.put("itemExtent", p.itemExtent);
		m.put("onTimerDurationChanged", p.onTimerDurationChanged, true);
		shptr<class CupertinoTimerPicker> result;
		m.check(m.call(result, true));
		return result;
	}

	double /*var-non-null*/ CupertinoPicker::diameterRatio() {
		auto m = ManagedCall("CupertinoPicker", "diameterRatio");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*var-nullable*/ CupertinoPicker::backgroundColor() {
		auto m = ManagedCall("CupertinoPicker", "backgroundColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	double /*var-non-null*/ CupertinoPicker::offAxisFraction() {
		auto m = ManagedCall("CupertinoPicker", "offAxisFraction");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	bool /*var-non-null*/ CupertinoPicker::useMagnifier() {
		auto m = ManagedCall("CupertinoPicker", "useMagnifier");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	double /*var-non-null*/ CupertinoPicker::magnification() {
		auto m = ManagedCall("CupertinoPicker", "magnification");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	double /*var-non-null*/ CupertinoPicker::itemExtent() {
		auto m = ManagedCall("CupertinoPicker", "itemExtent");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	double /*var-non-null*/ CupertinoPicker::squeeze() {
		auto m = ManagedCall("CupertinoPicker", "squeeze");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ListWheelChildDelegate> /*var-non-null*/ CupertinoPicker::childDelegate() {
		auto m = ManagedCall("CupertinoPicker", "childDelegate");
		m.put("this", this);
		shptr<class ListWheelChildDelegate> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Widget> /*var-nullable*/ CupertinoPicker::selectionOverlay() {
		auto m = ManagedCall("CupertinoPicker", "selectionOverlay");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	shptr<class CupertinoPicker> /*non-null*/ CupertinoPicker::ctorMain(_ctorMain p) {
		auto m = ManagedCall("CupertinoPicker", "CupertinoPicker");
		m.put("key", p.key);
		m.put("diameterRatio", p.diameterRatio);
		m.put("backgroundColor", p.backgroundColor);
		m.put("offAxisFraction", p.offAxisFraction);
		m.put("useMagnifier", p.useMagnifier);
		m.put("magnification", p.magnification);
		m.put("scrollController", p.scrollController);
		m.put("squeeze", p.squeeze);
		m.put("itemExtent", p.itemExtent);
		m.put("onSelectedItemChanged", p.onSelectedItemChanged);
		m.put("children", p.children);
		//		m.put("selectionOverlay", p.selectionOverlay);
		m.put("looping", p.looping);
		shptr<class CupertinoPicker> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class CupertinoPicker> /*non-null*/ CupertinoPicker::builder(_builder p) {
		auto m = ManagedCall("CupertinoPicker", "builder");
		m.put("key", p.key);
		m.put("diameterRatio", p.diameterRatio);
		m.put("backgroundColor", p.backgroundColor);
		m.put("offAxisFraction", p.offAxisFraction);
		m.put("useMagnifier", p.useMagnifier);
		m.put("magnification", p.magnification);
		m.put("scrollController", p.scrollController);
		m.put("squeeze", p.squeeze);
		m.put("itemExtent", p.itemExtent);
		m.put("onSelectedItemChanged", p.onSelectedItemChanged);
		m.put("itemBuilder", p.itemBuilder, true);
		m.put("childCount", p.childCount);
		//		m.put("selectionOverlay", p.selectionOverlay);
		shptr<class CupertinoPicker> result;
		m.check(m.call(result, true));
		return result;
	}

	bool /*var-non-null*/ CupertinoPopupSurface::isSurfacePainted() {
		auto m = ManagedCall("CupertinoPopupSurface", "isSurfacePainted");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Widget> /*var-nullable*/ CupertinoPopupSurface::child() {
		auto m = ManagedCall("CupertinoPopupSurface", "child");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	shptr<class CupertinoPopupSurface> /*non-null*/ CupertinoPopupSurface::ctorMain(_ctorMain p) {
		auto m = ManagedCall("CupertinoPopupSurface", "CupertinoPopupSurface");
		m.put("key", p.key);
		m.put("isSurfacePainted", p.isSurfacePainted);
		m.put("child", p.child);
		shptr<class CupertinoPopupSurface> result;
		m.check(m.call(result, true));
		return result;
	}

	double /*var-non-null*/ CupertinoScrollbar::defaultThickness() {
		auto m = ManagedCall("CupertinoScrollbar", "defaultThickness");
		double result;
		m.check(m.call(result));
		return result;
	}

	double /*var-non-null*/ CupertinoScrollbar::defaultThicknessWhileDragging() {
		auto m = ManagedCall("CupertinoScrollbar", "defaultThicknessWhileDragging");
		double result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Radius> /*var-non-null*/ CupertinoScrollbar::defaultRadius() {
		auto m = ManagedCall("CupertinoScrollbar", "defaultRadius");
		shptr<class Radius> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Radius> /*var-non-null*/ CupertinoScrollbar::defaultRadiusWhileDragging() {
		auto m = ManagedCall("CupertinoScrollbar", "defaultRadiusWhileDragging");
		shptr<class Radius> result;
		m.check(m.call(result));
		return result;
	}

	double /*var-non-null*/ CupertinoScrollbar::thicknessWhileDragging() {
		auto m = ManagedCall("CupertinoScrollbar", "thicknessWhileDragging");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Radius> /*var-non-null*/ CupertinoScrollbar::radiusWhileDragging() {
		auto m = ManagedCall("CupertinoScrollbar", "radiusWhileDragging");
		m.put("this", this);
		shptr<class Radius> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class CupertinoScrollbar> /*non-null*/ CupertinoScrollbar::ctorMain(_ctorMain p) {
		auto m = ManagedCall("CupertinoScrollbar", "CupertinoScrollbar");
		m.put("key", p.key);
		m.put("child", p.child, true);
		m.put("controller", p.controller);
		m.put("thumbVisibility", p.thumbVisibility);
		m.put("thickness", p.thickness);
		m.put("thicknessWhileDragging", p.thicknessWhileDragging);
		m.put("radius", p.radius, true);
		m.put("radiusWhileDragging", p.radiusWhileDragging, true);
		m.put("notificationPredicate", p.notificationPredicate);
		m.put("scrollbarOrientation", p.scrollbarOrientation);
		shptr<class CupertinoScrollbar> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class TextEditingController> /*var-nullable*/ CupertinoSearchTextField::controller() {
		auto m = ManagedCall("CupertinoSearchTextField", "controller");
		m.put("this", this);
		shptr<class TextEditingController> result;
		m.call(result);
		return result;
	}

	shptr<class TextStyle> /*var-nullable*/ CupertinoSearchTextField::style() {
		auto m = ManagedCall("CupertinoSearchTextField", "style");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.call(result);
		return result;
	}

	stdop<stdstr> /*var-nullable*/ CupertinoSearchTextField::placeholder() {
		auto m = ManagedCall("CupertinoSearchTextField", "placeholder");
		m.put("this", this);
		stdop<stdstr> result;
		m.call(result);
		return result;
	}

	shptr<class TextStyle> /*var-nullable*/ CupertinoSearchTextField::placeholderStyle() {
		auto m = ManagedCall("CupertinoSearchTextField", "placeholderStyle");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.call(result);
		return result;
	}

	shptr<class BoxDecoration> /*var-nullable*/ CupertinoSearchTextField::decoration() {
		auto m = ManagedCall("CupertinoSearchTextField", "decoration");
		m.put("this", this);
		shptr<class BoxDecoration> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ CupertinoSearchTextField::backgroundColor() {
		auto m = ManagedCall("CupertinoSearchTextField", "backgroundColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class BorderRadius> /*var-nullable*/ CupertinoSearchTextField::borderRadius() {
		auto m = ManagedCall("CupertinoSearchTextField", "borderRadius");
		m.put("this", this);
		shptr<class BorderRadius> result;
		m.call(result);
		return result;
	}

	shptr<class TextInputType> /*var-nullable*/ CupertinoSearchTextField::keyboardType() {
		auto m = ManagedCall("CupertinoSearchTextField", "keyboardType");
		m.put("this", this);
		shptr<class TextInputType> result;
		m.call(result);
		return result;
	}

	shptr<class EdgeInsetsGeometry> /*var-non-null*/ CupertinoSearchTextField::padding() {
		auto m = ManagedCall("CupertinoSearchTextField", "padding");
		m.put("this", this);
		shptr<class EdgeInsetsGeometry> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*var-non-null*/ CupertinoSearchTextField::itemColor() {
		auto m = ManagedCall("CupertinoSearchTextField", "itemColor");
		m.put("this", this);
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	double /*var-non-null*/ CupertinoSearchTextField::itemSize() {
		auto m = ManagedCall("CupertinoSearchTextField", "itemSize");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	shptr<class EdgeInsetsGeometry> /*var-non-null*/ CupertinoSearchTextField::prefixInsets() {
		auto m = ManagedCall("CupertinoSearchTextField", "prefixInsets");
		m.put("this", this);
		shptr<class EdgeInsetsGeometry> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Widget> /*var-non-null*/ CupertinoSearchTextField::prefixIcon() {
		auto m = ManagedCall("CupertinoSearchTextField", "prefixIcon");
		m.put("this", this);
		shptr<class Widget> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class EdgeInsetsGeometry> /*var-non-null*/ CupertinoSearchTextField::suffixInsets() {
		auto m = ManagedCall("CupertinoSearchTextField", "suffixInsets");
		m.put("this", this);
		shptr<class EdgeInsetsGeometry> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Icon> /*var-non-null*/ CupertinoSearchTextField::suffixIcon() {
		auto m = ManagedCall("CupertinoSearchTextField", "suffixIcon");
		m.put("this", this);
		shptr<class Icon> result;
		m.check(m.call(result));
		return result;
	}

	OverlayVisibilityMode /*var-non-null*/ CupertinoSearchTextField::suffixMode() {
		auto m = ManagedCall("CupertinoSearchTextField", "suffixMode");
		m.put("this", this);
		OverlayVisibilityMode result;
		m.check(m.call(result));
		return result;
	}

	stdop<stdstr> /*var-nullable*/ CupertinoSearchTextField::restorationId() {
		auto m = ManagedCall("CupertinoSearchTextField", "restorationId");
		m.put("this", this);
		stdop<stdstr> result;
		m.call(result);
		return result;
	}

	shptr<class FocusNode> /*var-nullable*/ CupertinoSearchTextField::focusNode() {
		auto m = ManagedCall("CupertinoSearchTextField", "focusNode");
		m.put("this", this);
		shptr<class FocusNode> result;
		m.call(result);
		return result;
	}

	bool /*var-non-null*/ CupertinoSearchTextField::autofocus() {
		auto m = ManagedCall("CupertinoSearchTextField", "autofocus");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	bool /*var-non-null*/ CupertinoSearchTextField::autocorrect() {
		auto m = ManagedCall("CupertinoSearchTextField", "autocorrect");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	stdop<SmartQuotesType> /*var-nullable*/ CupertinoSearchTextField::smartQuotesType() {
		auto m = ManagedCall("CupertinoSearchTextField", "smartQuotesType");
		m.put("this", this);
		stdop<SmartQuotesType> result;
		m.call(result);
		return result;
	}

	stdop<SmartDashesType> /*var-nullable*/ CupertinoSearchTextField::smartDashesType() {
		auto m = ManagedCall("CupertinoSearchTextField", "smartDashesType");
		m.put("this", this);
		stdop<SmartDashesType> result;
		m.call(result);
		return result;
	}

	bool /*var-non-null*/ CupertinoSearchTextField::enableIMEPersonalizedLearning() {
		auto m = ManagedCall("CupertinoSearchTextField", "enableIMEPersonalizedLearning");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	stdop<bool> /*var-nullable*/ CupertinoSearchTextField::enabled() {
		auto m = ManagedCall("CupertinoSearchTextField", "enabled");
		m.put("this", this);
		stdop<bool> result;
		m.call(result);
		return result;
	}

	shptr<class CupertinoSearchTextField> /*non-null*/ CupertinoSearchTextField::ctorMain(_ctorMain p) {
		auto m = ManagedCall("CupertinoSearchTextField", "CupertinoSearchTextField");
		m.put("key", p.key);
		m.put("controller", p.controller);
		m.put("onChanged", p.onChanged);
		m.put("onSubmitted", p.onSubmitted);
		m.put("style", p.style);
		m.put("placeholder", p.placeholder);
		m.put("placeholderStyle", p.placeholderStyle);
		m.put("decoration", p.decoration);
		m.put("backgroundColor", p.backgroundColor);
		m.put("borderRadius", p.borderRadius);
		//		m.put("keyboardType", p.keyboardType);
		//		m.put("padding", p.padding, true);
		//		m.put("itemColor", p.itemColor, true);
		m.put("itemSize", p.itemSize);
		//		m.put("prefixInsets", p.prefixInsets, true);
		//		m.put("prefixIcon", p.prefixIcon, true);
		//		m.put("suffixInsets", p.suffixInsets, true);
		//		m.put("suffixIcon", p.suffixIcon, true);
		m.put("suffixMode", p.suffixMode);
		m.put("onSuffixTap", p.onSuffixTap);
		m.put("restorationId", p.restorationId);
		m.put("focusNode", p.focusNode);
		m.put("smartQuotesType", p.smartQuotesType);
		m.put("smartDashesType", p.smartDashesType);
		m.put("enableIMEPersonalizedLearning", p.enableIMEPersonalizedLearning);
		m.put("autofocus", p.autofocus);
		m.put("onTap", p.onTap);
		m.put("autocorrect", p.autocorrect);
		m.put("enabled", p.enabled);
		shptr<class CupertinoSearchTextField> result;
		m.check(m.call(result, true));
		return result;
	}

	int64 /*var-non-null*/ CupertinoTabBar::currentIndex() {
		auto m = ManagedCall("CupertinoTabBar", "currentIndex");
		m.put("this", this);
		int64 result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*var-nullable*/ CupertinoTabBar::backgroundColor() {
		auto m = ManagedCall("CupertinoTabBar", "backgroundColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ CupertinoTabBar::activeColor() {
		auto m = ManagedCall("CupertinoTabBar", "activeColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-non-null*/ CupertinoTabBar::inactiveColor() {
		auto m = ManagedCall("CupertinoTabBar", "inactiveColor");
		m.put("this", this);
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	double /*var-non-null*/ CupertinoTabBar::iconSize() {
		auto m = ManagedCall("CupertinoTabBar", "iconSize");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	double /*var-non-null*/ CupertinoTabBar::height() {
		auto m = ManagedCall("CupertinoTabBar", "height");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Border> /*var-nullable*/ CupertinoTabBar::border() {
		auto m = ManagedCall("CupertinoTabBar", "border");
		m.put("this", this);
		shptr<class Border> result;
		m.call(result);
		return result;
	}

	shptr<class Size> /*get-non-null*/ CupertinoTabBar::preferredSize() {
		auto m = ManagedCall("CupertinoTabBar", "preferredSize");
		m.put("this", this);
		shptr<class Size> result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ CupertinoTabBar::opaque(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("CupertinoTabBar", "opaque");
		m.put("this", this);
		m.put("context", context, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class CupertinoTabBar> /*non-null*/ CupertinoTabBar::copyWith(_copyWith p) {
		auto m = ManagedCall("CupertinoTabBar", "copyWith");
		m.put("this", this);
		m.put("key", p.key);
		m.put("items", p.items);
		m.put("backgroundColor", p.backgroundColor);
		m.put("activeColor", p.activeColor);
		m.put("inactiveColor", p.inactiveColor);
		m.put("iconSize", p.iconSize);
		m.put("height", p.height);
		m.put("border", p.border);
		m.put("currentIndex", p.currentIndex);
		m.put("onTap", p.onTap);
		shptr<class CupertinoTabBar> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class CupertinoTabBar> /*non-null*/ CupertinoTabBar::ctorMain(_ctorMain p) {
		auto m = ManagedCall("CupertinoTabBar", "CupertinoTabBar");
		m.put("key", p.key);
		m.put("items", p.items);
		m.put("onTap", p.onTap);
		m.put("currentIndex", p.currentIndex);
		m.put("backgroundColor", p.backgroundColor);
		m.put("activeColor", p.activeColor);
		m.put("inactiveColor", p.inactiveColor, true);
		m.put("iconSize", p.iconSize);
		m.put("height", p.height);
		m.put("border", p.border);
		shptr<class CupertinoTabBar> result;
		m.check(m.call(result, true));
		return result;
	}

	stdop<int64> /*var-nullable*/ CupertinoSlidingSegmentedControl::groupValue() {
		auto m = ManagedCall("CupertinoSlidingSegmentedControl", "groupValue");
		m.put("this", this);
		stdop<int64> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-non-null*/ CupertinoSlidingSegmentedControl::backgroundColor() {
		auto m = ManagedCall("CupertinoSlidingSegmentedControl", "backgroundColor");
		m.put("this", this);
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*var-non-null*/ CupertinoSlidingSegmentedControl::thumbColor() {
		auto m = ManagedCall("CupertinoSlidingSegmentedControl", "thumbColor");
		m.put("this", this);
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class EdgeInsetsGeometry> /*var-non-null*/ CupertinoSlidingSegmentedControl::padding() {
		auto m = ManagedCall("CupertinoSlidingSegmentedControl", "padding");
		m.put("this", this);
		shptr<class EdgeInsetsGeometry> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class CupertinoSlidingSegmentedControl> /*non-null*/ CupertinoSlidingSegmentedControl::ctorMain(_ctorMain p) {
		auto m = ManagedCall("CupertinoSlidingSegmentedControl", "CupertinoSlidingSegmentedControl");
		m.put("key", p.key);
		m.put("children", p.children);
		m.put("onValueChanged", p.onValueChanged, true);
		m.put("groupValue", p.groupValue);
		m.put("thumbColor", p.thumbColor, true);
		m.put("padding", p.padding, true);
		m.put("backgroundColor", p.backgroundColor, true);
		shptr<class CupertinoSlidingSegmentedControl> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class ScrollPhysics> /*var-nullable*/ ScrollPhysics::parent() {
		auto m = ManagedCall("ScrollPhysics", "parent");
		m.put("this", this);
		shptr<class ScrollPhysics> result;
		m.call(result);
		return result;
	}

	shptr<class SpringDescription> /*get-non-null*/ ScrollPhysics::spring() {
		auto m = ManagedCall("ScrollPhysics", "spring");
		m.put("this", this);
		shptr<class SpringDescription> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Tolerance> /*get-non-null*/ ScrollPhysics::tolerance() {
		auto m = ManagedCall("ScrollPhysics", "tolerance");
		m.put("this", this);
		shptr<class Tolerance> result;
		m.check(m.call(result));
		return result;
	}

	double /*get-non-null*/ ScrollPhysics::minFlingDistance() {
		auto m = ManagedCall("ScrollPhysics", "minFlingDistance");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	double /*get-non-null*/ ScrollPhysics::minFlingVelocity() {
		auto m = ManagedCall("ScrollPhysics", "minFlingVelocity");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	double /*get-non-null*/ ScrollPhysics::maxFlingVelocity() {
		auto m = ManagedCall("ScrollPhysics", "maxFlingVelocity");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	stdop<double> /*get-nullable*/ ScrollPhysics::dragStartDistanceMotionThreshold() {
		auto m = ManagedCall("ScrollPhysics", "dragStartDistanceMotionThreshold");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	bool /*get-non-null*/ ScrollPhysics::allowImplicitScrolling() {
		auto m = ManagedCall("ScrollPhysics", "allowImplicitScrolling");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	bool /*get-non-null*/ ScrollPhysics::allowUserScrolling() {
		auto m = ManagedCall("ScrollPhysics", "allowUserScrolling");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ScrollPhysics> /*non-null*/ ScrollPhysics::applyTo(/*nullable*/ shptr<class ScrollPhysics> ancestor) {
		auto m = ManagedCall("ScrollPhysics", "applyTo");
		m.put("this", this);
		m.put("ancestor", ancestor);
		shptr<class ScrollPhysics> result;
		m.check(m.call(result));
		return result;
	}

	double /*non-null*/ ScrollPhysics::applyPhysicsToUserOffset(/*non-null*/ shptr<class ScrollMetrics> position, /*non-null*/ double offset) {
		auto m = ManagedCall("ScrollPhysics", "applyPhysicsToUserOffset");
		m.put("this", this);
		m.put("position", position, true);
		m.put("offset", offset);
		double result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ ScrollPhysics::shouldAcceptUserOffset(/*non-null*/ shptr<class ScrollMetrics> position) {
		auto m = ManagedCall("ScrollPhysics", "shouldAcceptUserOffset");
		m.put("this", this);
		m.put("position", position, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ ScrollPhysics::recommendDeferredLoading(/*non-null*/ double velocity, /*non-null*/ shptr<class ScrollMetrics> metrics, /*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("ScrollPhysics", "recommendDeferredLoading");
		m.put("this", this);
		m.put("velocity", velocity);
		m.put("metrics", metrics, true);
		m.put("context", context, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	double /*non-null*/ ScrollPhysics::applyBoundaryConditions(/*non-null*/ shptr<class ScrollMetrics> position, /*non-null*/ double value) {
		auto m = ManagedCall("ScrollPhysics", "applyBoundaryConditions");
		m.put("this", this);
		m.put("position", position, true);
		m.put("value", value);
		double result;
		m.check(m.call(result));
		return result;
	}

	double /*non-null*/ ScrollPhysics::adjustPositionForNewDimensions(_adjustPositionForNewDimensions p) {
		auto m = ManagedCall("ScrollPhysics", "adjustPositionForNewDimensions");
		m.put("this", this);
		m.put("oldPosition", p.oldPosition, true);
		m.put("newPosition", p.newPosition, true);
		m.put("isScrolling", p.isScrolling);
		m.put("velocity", p.velocity);
		double result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Simulation> /*nullable*/ ScrollPhysics::createBallisticSimulation(/*non-null*/ shptr<class ScrollMetrics> position, /*non-null*/ double velocity) {
		auto m = ManagedCall("ScrollPhysics", "createBallisticSimulation");
		m.put("this", this);
		m.put("position", position, true);
		m.put("velocity", velocity);
		shptr<class Simulation> result;
		m.call(result);
		return result;
	}

	shptr<class Tolerance> /*non-null*/ ScrollPhysics::toleranceFor(/*non-null*/ shptr<class ScrollMetrics> metrics) {
		auto m = ManagedCall("ScrollPhysics", "toleranceFor");
		m.put("this", this);
		m.put("metrics", metrics, true);
		shptr<class Tolerance> result;
		m.check(m.call(result));
		return result;
	}

	double /*non-null*/ ScrollPhysics::carriedMomentum(/*non-null*/ double existingVelocity) {
		auto m = ManagedCall("ScrollPhysics", "carriedMomentum");
		m.put("this", this);
		m.put("existingVelocity", existingVelocity);
		double result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ScrollPhysics> /*non-null*/ ScrollPhysics::ctorMain(_ctorMain p) {
		auto m = ManagedCall("ScrollPhysics", "ScrollPhysics");
		m.put("parent", p.parent);
		shptr<class ScrollPhysics> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class RangeMaintainingScrollPhysics> /*non-null*/ RangeMaintainingScrollPhysics::applyTo(/*nullable*/ shptr<class ScrollPhysics> ancestor) {
		auto m = ManagedCall("RangeMaintainingScrollPhysics", "applyTo");
		m.put("this", this);
		m.put("ancestor", ancestor);
		shptr<class RangeMaintainingScrollPhysics> result;
		m.check(m.call(result));
		return result;
	}

	double /*non-null*/ RangeMaintainingScrollPhysics::adjustPositionForNewDimensions(_adjustPositionForNewDimensions p) {
		auto m = ManagedCall("RangeMaintainingScrollPhysics", "adjustPositionForNewDimensions");
		m.put("this", this);
		m.put("oldPosition", p.oldPosition, true);
		m.put("newPosition", p.newPosition, true);
		m.put("isScrolling", p.isScrolling);
		m.put("velocity", p.velocity);
		double result;
		m.check(m.call(result));
		return result;
	}

	shptr<class RangeMaintainingScrollPhysics> /*non-null*/ RangeMaintainingScrollPhysics::ctorMain(_ctorMain p) {
		auto m = ManagedCall("RangeMaintainingScrollPhysics", "RangeMaintainingScrollPhysics");
		m.put("parent", p.parent);
		shptr<class RangeMaintainingScrollPhysics> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class ClampingScrollPhysics> /*non-null*/ ClampingScrollPhysics::applyTo(/*nullable*/ shptr<class ScrollPhysics> ancestor) {
		auto m = ManagedCall("ClampingScrollPhysics", "applyTo");
		m.put("this", this);
		m.put("ancestor", ancestor);
		shptr<class ClampingScrollPhysics> result;
		m.check(m.call(result));
		return result;
	}

	double /*non-null*/ ClampingScrollPhysics::applyBoundaryConditions(/*non-null*/ shptr<class ScrollMetrics> position, /*non-null*/ double value) {
		auto m = ManagedCall("ClampingScrollPhysics", "applyBoundaryConditions");
		m.put("this", this);
		m.put("position", position, true);
		m.put("value", value);
		double result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Simulation> /*nullable*/ ClampingScrollPhysics::createBallisticSimulation(/*non-null*/ shptr<class ScrollMetrics> position, /*non-null*/ double velocity) {
		auto m = ManagedCall("ClampingScrollPhysics", "createBallisticSimulation");
		m.put("this", this);
		m.put("position", position, true);
		m.put("velocity", velocity);
		shptr<class Simulation> result;
		m.call(result);
		return result;
	}

	shptr<class ClampingScrollPhysics> /*non-null*/ ClampingScrollPhysics::ctorMain(_ctorMain p) {
		auto m = ManagedCall("ClampingScrollPhysics", "ClampingScrollPhysics");
		m.put("parent", p.parent);
		shptr<class ClampingScrollPhysics> result;
		m.check(m.call(result, true));
		return result;
	}

	ScrollDecelerationRate /*var-non-null*/ BouncingScrollPhysics::decelerationRate() {
		auto m = ManagedCall("BouncingScrollPhysics", "decelerationRate");
		m.put("this", this);
		ScrollDecelerationRate result;
		m.check(m.call(result));
		return result;
	}

	double /*get-non-null*/ BouncingScrollPhysics::minFlingVelocity() {
		auto m = ManagedCall("BouncingScrollPhysics", "minFlingVelocity");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	double /*get-non-null*/ BouncingScrollPhysics::dragStartDistanceMotionThreshold() {
		auto m = ManagedCall("BouncingScrollPhysics", "dragStartDistanceMotionThreshold");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	double /*get-non-null*/ BouncingScrollPhysics::maxFlingVelocity() {
		auto m = ManagedCall("BouncingScrollPhysics", "maxFlingVelocity");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	shptr<class SpringDescription> /*get-non-null*/ BouncingScrollPhysics::spring() {
		auto m = ManagedCall("BouncingScrollPhysics", "spring");
		m.put("this", this);
		shptr<class SpringDescription> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class BouncingScrollPhysics> /*non-null*/ BouncingScrollPhysics::applyTo(/*nullable*/ shptr<class ScrollPhysics> ancestor) {
		auto m = ManagedCall("BouncingScrollPhysics", "applyTo");
		m.put("this", this);
		m.put("ancestor", ancestor);
		shptr<class BouncingScrollPhysics> result;
		m.check(m.call(result));
		return result;
	}

	double /*non-null*/ BouncingScrollPhysics::frictionFactor(/*non-null*/ double overscrollFraction) {
		auto m = ManagedCall("BouncingScrollPhysics", "frictionFactor");
		m.put("this", this);
		m.put("overscrollFraction", overscrollFraction);
		double result;
		m.check(m.call(result));
		return result;
	}

	double /*non-null*/ BouncingScrollPhysics::applyPhysicsToUserOffset(/*non-null*/ shptr<class ScrollMetrics> position, /*non-null*/ double offset) {
		auto m = ManagedCall("BouncingScrollPhysics", "applyPhysicsToUserOffset");
		m.put("this", this);
		m.put("position", position, true);
		m.put("offset", offset);
		double result;
		m.check(m.call(result));
		return result;
	}

	double /*non-null*/ BouncingScrollPhysics::applyBoundaryConditions(/*non-null*/ shptr<class ScrollMetrics> position, /*non-null*/ double value) {
		auto m = ManagedCall("BouncingScrollPhysics", "applyBoundaryConditions");
		m.put("this", this);
		m.put("position", position, true);
		m.put("value", value);
		double result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Simulation> /*nullable*/ BouncingScrollPhysics::createBallisticSimulation(/*non-null*/ shptr<class ScrollMetrics> position, /*non-null*/ double velocity) {
		auto m = ManagedCall("BouncingScrollPhysics", "createBallisticSimulation");
		m.put("this", this);
		m.put("position", position, true);
		m.put("velocity", velocity);
		shptr<class Simulation> result;
		m.call(result);
		return result;
	}

	double /*non-null*/ BouncingScrollPhysics::carriedMomentum(/*non-null*/ double existingVelocity) {
		auto m = ManagedCall("BouncingScrollPhysics", "carriedMomentum");
		m.put("this", this);
		m.put("existingVelocity", existingVelocity);
		double result;
		m.check(m.call(result));
		return result;
	}

	shptr<class BouncingScrollPhysics> /*non-null*/ BouncingScrollPhysics::ctorMain(_ctorMain p) {
		auto m = ManagedCall("BouncingScrollPhysics", "BouncingScrollPhysics");
		m.put("decelerationRate", p.decelerationRate);
		m.put("parent", p.parent);
		shptr<class BouncingScrollPhysics> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class AlwaysScrollableScrollPhysics> /*non-null*/ AlwaysScrollableScrollPhysics::applyTo(/*nullable*/ shptr<class ScrollPhysics> ancestor) {
		auto m = ManagedCall("AlwaysScrollableScrollPhysics", "applyTo");
		m.put("this", this);
		m.put("ancestor", ancestor);
		shptr<class AlwaysScrollableScrollPhysics> result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ AlwaysScrollableScrollPhysics::shouldAcceptUserOffset(/*non-null*/ shptr<class ScrollMetrics> position) {
		auto m = ManagedCall("AlwaysScrollableScrollPhysics", "shouldAcceptUserOffset");
		m.put("this", this);
		m.put("position", position, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class AlwaysScrollableScrollPhysics> /*non-null*/ AlwaysScrollableScrollPhysics::ctorMain(_ctorMain p) {
		auto m = ManagedCall("AlwaysScrollableScrollPhysics", "AlwaysScrollableScrollPhysics");
		m.put("parent", p.parent);
		shptr<class AlwaysScrollableScrollPhysics> result;
		m.check(m.call(result, true));
		return result;
	}

	bool /*get-non-null*/ NeverScrollableScrollPhysics::allowUserScrolling() {
		auto m = ManagedCall("NeverScrollableScrollPhysics", "allowUserScrolling");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	bool /*get-non-null*/ NeverScrollableScrollPhysics::allowImplicitScrolling() {
		auto m = ManagedCall("NeverScrollableScrollPhysics", "allowImplicitScrolling");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class NeverScrollableScrollPhysics> /*non-null*/ NeverScrollableScrollPhysics::applyTo(/*nullable*/ shptr<class ScrollPhysics> ancestor) {
		auto m = ManagedCall("NeverScrollableScrollPhysics", "applyTo");
		m.put("this", this);
		m.put("ancestor", ancestor);
		shptr<class NeverScrollableScrollPhysics> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class NeverScrollableScrollPhysics> /*non-null*/ NeverScrollableScrollPhysics::ctorMain(_ctorMain p) {
		auto m = ManagedCall("NeverScrollableScrollPhysics", "NeverScrollableScrollPhysics");
		m.put("parent", p.parent);
		shptr<class NeverScrollableScrollPhysics> result;
		m.check(m.call(result, true));
		return result;
	}

	AndroidOverscrollIndicator /*get-non-null*/ ScrollBehavior::androidOverscrollIndicator() {
		auto m = ManagedCall("ScrollBehavior", "androidOverscrollIndicator");
		m.put("this", this);
		AndroidOverscrollIndicator result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ScrollBehavior> /*non-null*/ ScrollBehavior::copyWith(_copyWith p) {
		auto m = ManagedCall("ScrollBehavior", "copyWith");
		m.put("this", this);
		m.put("scrollbars", p.scrollbars);
		m.put("overscroll", p.overscroll);
		m.put("dragDevices", p.dragDevices);
		m.put("pointerAxisModifiers", p.pointerAxisModifiers);
		m.put("physics", p.physics);
		m.put("platform", p.platform);
		m.put("androidOverscrollIndicator", p.androidOverscrollIndicator);
		shptr<class ScrollBehavior> result;
		m.check(m.call(result));
		return result;
	}

	TargetPlatform /*non-null*/ ScrollBehavior::getPlatform(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("ScrollBehavior", "getPlatform");
		m.put("this", this);
		m.put("context", context, true);
		TargetPlatform result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Widget> /*non-null*/ ScrollBehavior::buildScrollbar(/*non-null*/ shptr<class BuildContext> context, /*non-null*/ shptr<class Widget> child, /*non-null*/ shptr<class ScrollableDetails> details) {
		auto m = ManagedCall("ScrollBehavior", "buildScrollbar");
		m.put("this", this);
		m.put("context", context, true);
		m.put("child", child, true);
		m.put("details", details, true);
		shptr<class Widget> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Widget> /*non-null*/ ScrollBehavior::buildOverscrollIndicator(/*non-null*/ shptr<class BuildContext> context, /*non-null*/ shptr<class Widget> child, /*non-null*/ shptr<class ScrollableDetails> details) {
		auto m = ManagedCall("ScrollBehavior", "buildOverscrollIndicator");
		m.put("this", this);
		m.put("context", context, true);
		m.put("child", child, true);
		m.put("details", details, true);
		shptr<class Widget> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ScrollPhysics> /*non-null*/ ScrollBehavior::getScrollPhysics(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("ScrollBehavior", "getScrollPhysics");
		m.put("this", this);
		m.put("context", context, true);
		shptr<class ScrollPhysics> result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ ScrollBehavior::shouldNotify(/*non-null*/ shptr<class ScrollBehavior> oldDelegate) {
		auto m = ManagedCall("ScrollBehavior", "shouldNotify");
		m.put("this", this);
		m.put("oldDelegate", oldDelegate, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ScrollBehavior> /*non-null*/ ScrollBehavior::ctorMain(_ctorMain p) {
		auto m = ManagedCall("ScrollBehavior", "ScrollBehavior");
		m.put("androidOverscrollIndicator", p.androidOverscrollIndicator);
		shptr<class ScrollBehavior> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class ScrollBehavior> /*var-non-null*/ ScrollConfiguration::behavior() {
		auto m = ManagedCall("ScrollConfiguration", "behavior");
		m.put("this", this);
		shptr<class ScrollBehavior> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ScrollBehavior> /*non-null*/ ScrollConfiguration::of(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("ScrollConfiguration", "of");
		m.put("context", context, true);
		shptr<class ScrollBehavior> result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ ScrollConfiguration::updateShouldNotify(/*non-null*/ shptr<class ScrollConfiguration> oldWidget) {
		auto m = ManagedCall("ScrollConfiguration", "updateShouldNotify");
		m.put("this", this);
		m.put("oldWidget", oldWidget, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ScrollConfiguration> /*non-null*/ ScrollConfiguration::ctorMain(_ctorMain p) {
		auto m = ManagedCall("ScrollConfiguration", "ScrollConfiguration");
		m.put("key", p.key);
		m.put("behavior", p.behavior, true);
		m.put("child", p.child, true);
		shptr<class ScrollConfiguration> result;
		m.check(m.call(result, true));
		return result;
	}

	bool /*var-non-null*/ ScrollController::keepScrollOffset() {
		auto m = ManagedCall("ScrollController", "keepScrollOffset");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	stdop<stdstr> /*var-nullable*/ ScrollController::debugLabel() {
		auto m = ManagedCall("ScrollController", "debugLabel");
		m.put("this", this);
		stdop<stdstr> result;
		m.call(result);
		return result;
	}

	double /*get-non-null*/ ScrollController::initialScrollOffset() {
		auto m = ManagedCall("ScrollController", "initialScrollOffset");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	bool /*get-non-null*/ ScrollController::hasClients() {
		auto m = ManagedCall("ScrollController", "hasClients");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ScrollPosition> /*get-non-null*/ ScrollController::position() {
		auto m = ManagedCall("ScrollController", "position");
		m.put("this", this);
		shptr<class ScrollPosition> result;
		m.check(m.call(result));
		return result;
	}

	double /*get-non-null*/ ScrollController::offset() {
		auto m = ManagedCall("ScrollController", "offset");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	void ScrollController::animateTo(/*non-null*/ double offset, _animateTo p) {
		auto m = ManagedCall("ScrollController", "animateTo");
		m.put("this", this);
		m.put("offset", offset);
		m.put("duration", p.duration, true);
		m.put("curve", p.curve, true);
		m.call();
	}

	void ScrollController::jumpTo(/*non-null*/ double value) {
		auto m = ManagedCall("ScrollController", "jumpTo");
		m.put("this", this);
		m.put("value", value);
		m.call();
	}

	void ScrollController::attach(/*non-null*/ shptr<class ScrollPosition> position) {
		auto m = ManagedCall("ScrollController", "attach");
		m.put("this", this);
		m.put("position", position, true);
		m.call();
	}

	void ScrollController::detach(/*non-null*/ shptr<class ScrollPosition> position) {
		auto m = ManagedCall("ScrollController", "detach");
		m.put("this", this);
		m.put("position", position, true);
		m.call();
	}

	void ScrollController::dispose() {
		auto m = ManagedCall("ScrollController", "dispose");
		m.put("this", this);
		m.call();
	}

	shptr<class ScrollPosition> /*non-null*/ ScrollController::createScrollPosition(/*non-null*/ shptr<class ScrollPhysics> physics, /*non-null*/ shptr<class ScrollContext> context, /*nullable*/ shptr<class ScrollPosition> oldPosition) {
		auto m = ManagedCall("ScrollController", "createScrollPosition");
		m.put("this", this);
		m.put("physics", physics, true);
		m.put("context", context, true);
		m.put("oldPosition", oldPosition);
		shptr<class ScrollPosition> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ScrollController> /*non-null*/ ScrollController::ctorMain(_ctorMain p) {
		auto m = ManagedCall("ScrollController", "ScrollController");
		m.put("initialScrollOffset", p.initialScrollOffset);
		m.put("keepScrollOffset", p.keepScrollOffset);
		m.put("debugLabel", p.debugLabel);
		m.put("onAttach", p.onAttach);
		m.put("onDetach", p.onDetach);
		shptr<class ScrollController> result;
		m.check(m.call(result, true));
		return result;
	}

	stdop<double> /*var-nullable*/ ListView::itemExtent() {
		auto m = ManagedCall("ListView", "itemExtent");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	shptr<class Widget> /*var-nullable*/ ListView::prototypeItem() {
		auto m = ManagedCall("ListView", "prototypeItem");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	shptr<class SliverChildDelegate> /*var-non-null*/ ListView::childrenDelegate() {
		auto m = ManagedCall("ListView", "childrenDelegate");
		m.put("this", this);
		shptr<class SliverChildDelegate> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Widget> /*non-null*/ ListView::buildChildLayout(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("ListView", "buildChildLayout");
		m.put("this", this);
		m.put("context", context, true);
		shptr<class Widget> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ListView> /*non-null*/ ListView::ctorMain(_ctorMain p) {
		auto m = ManagedCall("ListView", "ListView");
		m.put("key", p.key);
		m.put("scrollDirection", p.scrollDirection);
		m.put("reverse", p.reverse);
		m.put("controller", p.controller);
		m.put("primary", p.primary);
		m.put("physics", p.physics);
		m.put("shrinkWrap", p.shrinkWrap);
		m.put("padding", p.padding);
		m.put("itemExtent", p.itemExtent);
		m.put("prototypeItem", p.prototypeItem);
		m.put("addAutomaticKeepAlives", p.addAutomaticKeepAlives);
		m.put("addRepaintBoundaries", p.addRepaintBoundaries);
		m.put("addSemanticIndexes", p.addSemanticIndexes);
		m.put("cacheExtent", p.cacheExtent);
		m.put("children", p.children);
		m.put("semanticChildCount", p.semanticChildCount);
		m.put("dragStartBehavior", p.dragStartBehavior);
		m.put("keyboardDismissBehavior", p.keyboardDismissBehavior);
		m.put("restorationId", p.restorationId);
		m.put("clipBehavior", p.clipBehavior);
		shptr<class ListView> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class ListView> /*non-null*/ ListView::builder(_builder p) {
		auto m = ManagedCall("ListView", "builder");
		m.put("key", p.key);
		m.put("scrollDirection", p.scrollDirection);
		m.put("reverse", p.reverse);
		m.put("controller", p.controller);
		m.put("primary", p.primary);
		m.put("physics", p.physics);
		m.put("shrinkWrap", p.shrinkWrap);
		m.put("padding", p.padding);
		m.put("itemExtent", p.itemExtent);
		m.put("prototypeItem", p.prototypeItem);
		m.put("itemBuilder", p.itemBuilder, true);
		m.put("findChildIndexCallback", p.findChildIndexCallback);
		m.put("itemCount", p.itemCount);
		m.put("addAutomaticKeepAlives", p.addAutomaticKeepAlives);
		m.put("addRepaintBoundaries", p.addRepaintBoundaries);
		m.put("addSemanticIndexes", p.addSemanticIndexes);
		m.put("cacheExtent", p.cacheExtent);
		m.put("semanticChildCount", p.semanticChildCount);
		m.put("dragStartBehavior", p.dragStartBehavior);
		m.put("keyboardDismissBehavior", p.keyboardDismissBehavior);
		m.put("restorationId", p.restorationId);
		m.put("clipBehavior", p.clipBehavior);
		shptr<class ListView> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class ListView> /*non-null*/ ListView::separated(_separated p) {
		auto m = ManagedCall("ListView", "separated");
		m.put("key", p.key);
		m.put("scrollDirection", p.scrollDirection);
		m.put("reverse", p.reverse);
		m.put("controller", p.controller);
		m.put("primary", p.primary);
		m.put("physics", p.physics);
		m.put("shrinkWrap", p.shrinkWrap);
		m.put("padding", p.padding);
		m.put("itemBuilder", p.itemBuilder, true);
		m.put("findChildIndexCallback", p.findChildIndexCallback);
		m.put("separatorBuilder", p.separatorBuilder, true);
		m.put("itemCount", p.itemCount);
		m.put("addAutomaticKeepAlives", p.addAutomaticKeepAlives);
		m.put("addRepaintBoundaries", p.addRepaintBoundaries);
		m.put("addSemanticIndexes", p.addSemanticIndexes);
		m.put("cacheExtent", p.cacheExtent);
		m.put("dragStartBehavior", p.dragStartBehavior);
		m.put("keyboardDismissBehavior", p.keyboardDismissBehavior);
		m.put("restorationId", p.restorationId);
		m.put("clipBehavior", p.clipBehavior);
		shptr<class ListView> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class ListView> /*non-null*/ ListView::custom(_custom p) {
		auto m = ManagedCall("ListView", "custom");
		m.put("key", p.key);
		m.put("scrollDirection", p.scrollDirection);
		m.put("reverse", p.reverse);
		m.put("controller", p.controller);
		m.put("primary", p.primary);
		m.put("physics", p.physics);
		m.put("shrinkWrap", p.shrinkWrap);
		m.put("padding", p.padding);
		m.put("itemExtent", p.itemExtent);
		m.put("prototypeItem", p.prototypeItem);
		m.put("childrenDelegate", p.childrenDelegate, true);
		m.put("cacheExtent", p.cacheExtent);
		m.put("semanticChildCount", p.semanticChildCount);
		m.put("dragStartBehavior", p.dragStartBehavior);
		m.put("keyboardDismissBehavior", p.keyboardDismissBehavior);
		m.put("restorationId", p.restorationId);
		m.put("clipBehavior", p.clipBehavior);
		shptr<class ListView> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Widget> /*var-nullable*/ ListTile::leading() {
		auto m = ManagedCall("ListTile", "leading");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	shptr<class Widget> /*var-nullable*/ ListTile::title() {
		auto m = ManagedCall("ListTile", "title");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	shptr<class Widget> /*var-nullable*/ ListTile::subtitle() {
		auto m = ManagedCall("ListTile", "subtitle");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	shptr<class Widget> /*var-nullable*/ ListTile::trailing() {
		auto m = ManagedCall("ListTile", "trailing");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	bool /*var-non-null*/ ListTile::isThreeLine() {
		auto m = ManagedCall("ListTile", "isThreeLine");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	stdop<bool> /*var-nullable*/ ListTile::dense() {
		auto m = ManagedCall("ListTile", "dense");
		m.put("this", this);
		stdop<bool> result;
		m.call(result);
		return result;
	}

	shptr<class VisualDensity> /*var-nullable*/ ListTile::visualDensity() {
		auto m = ManagedCall("ListTile", "visualDensity");
		m.put("this", this);
		shptr<class VisualDensity> result;
		m.call(result);
		return result;
	}

	shptr<class ShapeBorder> /*var-nullable*/ ListTile::shape() {
		auto m = ManagedCall("ListTile", "shape");
		m.put("this", this);
		shptr<class ShapeBorder> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ ListTile::selectedColor() {
		auto m = ManagedCall("ListTile", "selectedColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ ListTile::iconColor() {
		auto m = ManagedCall("ListTile", "iconColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ ListTile::textColor() {
		auto m = ManagedCall("ListTile", "textColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class TextStyle> /*var-nullable*/ ListTile::titleTextStyle() {
		auto m = ManagedCall("ListTile", "titleTextStyle");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.call(result);
		return result;
	}

	shptr<class TextStyle> /*var-nullable*/ ListTile::subtitleTextStyle() {
		auto m = ManagedCall("ListTile", "subtitleTextStyle");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.call(result);
		return result;
	}

	shptr<class TextStyle> /*var-nullable*/ ListTile::leadingAndTrailingTextStyle() {
		auto m = ManagedCall("ListTile", "leadingAndTrailingTextStyle");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.call(result);
		return result;
	}

	stdop<ListTileStyle> /*var-nullable*/ ListTile::style() {
		auto m = ManagedCall("ListTile", "style");
		m.put("this", this);
		stdop<ListTileStyle> result;
		m.call(result);
		return result;
	}

	shptr<class EdgeInsetsGeometry> /*var-nullable*/ ListTile::contentPadding() {
		auto m = ManagedCall("ListTile", "contentPadding");
		m.put("this", this);
		shptr<class EdgeInsetsGeometry> result;
		m.call(result);
		return result;
	}

	bool /*var-non-null*/ ListTile::enabled() {
		auto m = ManagedCall("ListTile", "enabled");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class MouseCursor> /*var-nullable*/ ListTile::mouseCursor() {
		auto m = ManagedCall("ListTile", "mouseCursor");
		m.put("this", this);
		shptr<class MouseCursor> result;
		m.call(result);
		return result;
	}

	bool /*var-non-null*/ ListTile::selected() {
		auto m = ManagedCall("ListTile", "selected");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*var-nullable*/ ListTile::focusColor() {
		auto m = ManagedCall("ListTile", "focusColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ ListTile::hoverColor() {
		auto m = ManagedCall("ListTile", "hoverColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ ListTile::splashColor() {
		auto m = ManagedCall("ListTile", "splashColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class FocusNode> /*var-nullable*/ ListTile::focusNode() {
		auto m = ManagedCall("ListTile", "focusNode");
		m.put("this", this);
		shptr<class FocusNode> result;
		m.call(result);
		return result;
	}

	bool /*var-non-null*/ ListTile::autofocus() {
		auto m = ManagedCall("ListTile", "autofocus");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*var-nullable*/ ListTile::tileColor() {
		auto m = ManagedCall("ListTile", "tileColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ ListTile::selectedTileColor() {
		auto m = ManagedCall("ListTile", "selectedTileColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	stdop<bool> /*var-nullable*/ ListTile::enableFeedback() {
		auto m = ManagedCall("ListTile", "enableFeedback");
		m.put("this", this);
		stdop<bool> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ ListTile::horizontalTitleGap() {
		auto m = ManagedCall("ListTile", "horizontalTitleGap");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ ListTile::minVerticalPadding() {
		auto m = ManagedCall("ListTile", "minVerticalPadding");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ ListTile::minLeadingWidth() {
		auto m = ManagedCall("ListTile", "minLeadingWidth");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	stdop<ListTileTitleAlignment> /*var-nullable*/ ListTile::titleAlignment() {
		auto m = ManagedCall("ListTile", "titleAlignment");
		m.put("this", this);
		stdop<ListTileTitleAlignment> result;
		m.call(result);
		return result;
	}

	shptr<class ListTile> /*non-null*/ ListTile::ctorMain(_ctorMain p) {
		auto m = ManagedCall("ListTile", "ListTile");
		m.put("key", p.key);
		m.put("leading", p.leading);
		m.put("title", p.title);
		m.put("subtitle", p.subtitle);
		m.put("trailing", p.trailing);
		m.put("isThreeLine", p.isThreeLine);
		m.put("dense", p.dense);
		m.put("visualDensity", p.visualDensity);
		m.put("shape", p.shape);
		m.put("style", p.style);
		m.put("selectedColor", p.selectedColor);
		m.put("iconColor", p.iconColor);
		m.put("textColor", p.textColor);
		m.put("titleTextStyle", p.titleTextStyle);
		m.put("subtitleTextStyle", p.subtitleTextStyle);
		m.put("leadingAndTrailingTextStyle", p.leadingAndTrailingTextStyle);
		m.put("contentPadding", p.contentPadding);
		m.put("enabled", p.enabled);
		m.put("onTap", p.onTap);
		m.put("onLongPress", p.onLongPress);
		m.put("onFocusChange", p.onFocusChange);
		m.put("mouseCursor", p.mouseCursor);
		m.put("selected", p.selected);
		m.put("focusColor", p.focusColor);
		m.put("hoverColor", p.hoverColor);
		m.put("splashColor", p.splashColor);
		m.put("focusNode", p.focusNode);
		m.put("autofocus", p.autofocus);
		m.put("tileColor", p.tileColor);
		m.put("selectedTileColor", p.selectedTileColor);
		m.put("enableFeedback", p.enableFeedback);
		m.put("horizontalTitleGap", p.horizontalTitleGap);
		m.put("minVerticalPadding", p.minVerticalPadding);
		m.put("minLeadingWidth", p.minLeadingWidth);
		m.put("titleAlignment", p.titleAlignment);
		shptr<class ListTile> result;
		m.check(m.call(result, true));
		return result;
	}

	bool /*var-non-null*/ GlowingOverscrollIndicator::showLeading() {
		auto m = ManagedCall("GlowingOverscrollIndicator", "showLeading");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	bool /*var-non-null*/ GlowingOverscrollIndicator::showTrailing() {
		auto m = ManagedCall("GlowingOverscrollIndicator", "showTrailing");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	AxisDirection /*var-non-null*/ GlowingOverscrollIndicator::axisDirection() {
		auto m = ManagedCall("GlowingOverscrollIndicator", "axisDirection");
		m.put("this", this);
		AxisDirection result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*var-non-null*/ GlowingOverscrollIndicator::color() {
		auto m = ManagedCall("GlowingOverscrollIndicator", "color");
		m.put("this", this);
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Widget> /*var-nullable*/ GlowingOverscrollIndicator::child() {
		auto m = ManagedCall("GlowingOverscrollIndicator", "child");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	Axis /*get-non-null*/ GlowingOverscrollIndicator::axis() {
		auto m = ManagedCall("GlowingOverscrollIndicator", "axis");
		m.put("this", this);
		Axis result;
		m.check(m.call(result));
		return result;
	}

	shptr<class GlowingOverscrollIndicator> /*non-null*/ GlowingOverscrollIndicator::ctorMain(_ctorMain p) {
		auto m = ManagedCall("GlowingOverscrollIndicator", "GlowingOverscrollIndicator");
		m.put("key", p.key);
		m.put("showLeading", p.showLeading);
		m.put("showTrailing", p.showTrailing);
		m.put("axisDirection", p.axisDirection);
		m.put("color", p.color, true);
//		m.put("notificationPredicate", p.notificationPredicate, true);
		m.put("child", p.child);
		shptr<class GlowingOverscrollIndicator> result;
		m.check(m.call(result, true));
		return result;
	}

	AxisDirection /*var-non-null*/ StretchingOverscrollIndicator::axisDirection() {
		auto m = ManagedCall("StretchingOverscrollIndicator", "axisDirection");
		m.put("this", this);
		AxisDirection result;
		m.check(m.call(result));
		return result;
	}

	Clip /*var-non-null*/ StretchingOverscrollIndicator::clipBehavior() {
		auto m = ManagedCall("StretchingOverscrollIndicator", "clipBehavior");
		m.put("this", this);
		Clip result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Widget> /*var-nullable*/ StretchingOverscrollIndicator::child() {
		auto m = ManagedCall("StretchingOverscrollIndicator", "child");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	Axis /*get-non-null*/ StretchingOverscrollIndicator::axis() {
		auto m = ManagedCall("StretchingOverscrollIndicator", "axis");
		m.put("this", this);
		Axis result;
		m.check(m.call(result));
		return result;
	}

	shptr<class StretchingOverscrollIndicator> /*non-null*/ StretchingOverscrollIndicator::ctorMain(_ctorMain p) {
		auto m = ManagedCall("StretchingOverscrollIndicator", "StretchingOverscrollIndicator");
		m.put("key", p.key);
		m.put("axisDirection", p.axisDirection);
//		m.put("notificationPredicate", p.notificationPredicate, true);
		m.put("clipBehavior", p.clipBehavior);
		m.put("child", p.child);
		shptr<class StretchingOverscrollIndicator> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Widget> /*var-non-null*/ Scrollbar::child() {
		auto m = ManagedCall("Scrollbar", "child");
		m.put("this", this);
		shptr<class Widget> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ScrollController> /*var-nullable*/ Scrollbar::controller() {
		auto m = ManagedCall("Scrollbar", "controller");
		m.put("this", this);
		shptr<class ScrollController> result;
		m.call(result);
		return result;
	}

	stdop<bool> /*var-nullable*/ Scrollbar::thumbVisibility() {
		auto m = ManagedCall("Scrollbar", "thumbVisibility");
		m.put("this", this);
		stdop<bool> result;
		m.call(result);
		return result;
	}

	stdop<bool> /*var-nullable*/ Scrollbar::trackVisibility() {
		auto m = ManagedCall("Scrollbar", "trackVisibility");
		m.put("this", this);
		stdop<bool> result;
		m.call(result);
		return result;
	}

	stdop<bool> /*var-nullable*/ Scrollbar::showTrackOnHover() {
		auto m = ManagedCall("Scrollbar", "showTrackOnHover");
		m.put("this", this);
		stdop<bool> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ Scrollbar::thickness() {
		auto m = ManagedCall("Scrollbar", "thickness");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	shptr<class Radius> /*var-nullable*/ Scrollbar::radius() {
		auto m = ManagedCall("Scrollbar", "radius");
		m.put("this", this);
		shptr<class Radius> result;
		m.call(result);
		return result;
	}

	stdop<bool> /*var-nullable*/ Scrollbar::interactive() {
		auto m = ManagedCall("Scrollbar", "interactive");
		m.put("this", this);
		stdop<bool> result;
		m.call(result);
		return result;
	}

	stdop<ScrollbarOrientation> /*var-nullable*/ Scrollbar::scrollbarOrientation() {
		auto m = ManagedCall("Scrollbar", "scrollbarOrientation");
		m.put("this", this);
		stdop<ScrollbarOrientation> result;
		m.call(result);
		return result;
	}

	shptr<class Scrollbar> /*non-null*/ Scrollbar::ctorMain(_ctorMain p) {
		auto m = ManagedCall("Scrollbar", "Scrollbar");
		m.put("key", p.key);
		m.put("child", p.child, true);
		m.put("controller", p.controller);
		m.put("thumbVisibility", p.thumbVisibility);
		m.put("trackVisibility", p.trackVisibility);
		m.put("thickness", p.thickness);
		m.put("radius", p.radius);
		m.put("notificationPredicate", p.notificationPredicate);
		m.put("interactive", p.interactive);
		m.put("scrollbarOrientation", p.scrollbarOrientation);
		m.put("showTrackOnHover", p.showTrackOnHover);
		shptr<class Scrollbar> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Widget> /*var-non-null*/ RawScrollbar::child() {
		auto m = ManagedCall("RawScrollbar", "child");
		m.put("this", this);
		shptr<class Widget> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ScrollController> /*var-nullable*/ RawScrollbar::controller() {
		auto m = ManagedCall("RawScrollbar", "controller");
		m.put("this", this);
		shptr<class ScrollController> result;
		m.call(result);
		return result;
	}

	stdop<bool> /*var-nullable*/ RawScrollbar::thumbVisibility() {
		auto m = ManagedCall("RawScrollbar", "thumbVisibility");
		m.put("this", this);
		stdop<bool> result;
		m.call(result);
		return result;
	}

	shptr<class OutlinedBorder> /*var-nullable*/ RawScrollbar::shape() {
		auto m = ManagedCall("RawScrollbar", "shape");
		m.put("this", this);
		shptr<class OutlinedBorder> result;
		m.call(result);
		return result;
	}

	shptr<class Radius> /*var-nullable*/ RawScrollbar::radius() {
		auto m = ManagedCall("RawScrollbar", "radius");
		m.put("this", this);
		shptr<class Radius> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ RawScrollbar::thickness() {
		auto m = ManagedCall("RawScrollbar", "thickness");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ RawScrollbar::thumbColor() {
		auto m = ManagedCall("RawScrollbar", "thumbColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	double /*var-non-null*/ RawScrollbar::minThumbLength() {
		auto m = ManagedCall("RawScrollbar", "minThumbLength");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	stdop<double> /*var-nullable*/ RawScrollbar::minOverscrollLength() {
		auto m = ManagedCall("RawScrollbar", "minOverscrollLength");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	stdop<bool> /*var-nullable*/ RawScrollbar::trackVisibility() {
		auto m = ManagedCall("RawScrollbar", "trackVisibility");
		m.put("this", this);
		stdop<bool> result;
		m.call(result);
		return result;
	}

	shptr<class Radius> /*var-nullable*/ RawScrollbar::trackRadius() {
		auto m = ManagedCall("RawScrollbar", "trackRadius");
		m.put("this", this);
		shptr<class Radius> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ RawScrollbar::trackColor() {
		auto m = ManagedCall("RawScrollbar", "trackColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ RawScrollbar::trackBorderColor() {
		auto m = ManagedCall("RawScrollbar", "trackBorderColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Duration> /*var-non-null*/ RawScrollbar::fadeDuration() {
		auto m = ManagedCall("RawScrollbar", "fadeDuration");
		m.put("this", this);
		shptr<class Duration> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Duration> /*var-non-null*/ RawScrollbar::timeToFade() {
		auto m = ManagedCall("RawScrollbar", "timeToFade");
		m.put("this", this);
		shptr<class Duration> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Duration> /*var-non-null*/ RawScrollbar::pressDuration() {
		auto m = ManagedCall("RawScrollbar", "pressDuration");
		m.put("this", this);
		shptr<class Duration> result;
		m.check(m.call(result));
		return result;
	}

	stdop<bool> /*var-nullable*/ RawScrollbar::interactive() {
		auto m = ManagedCall("RawScrollbar", "interactive");
		m.put("this", this);
		stdop<bool> result;
		m.call(result);
		return result;
	}

	stdop<ScrollbarOrientation> /*var-nullable*/ RawScrollbar::scrollbarOrientation() {
		auto m = ManagedCall("RawScrollbar", "scrollbarOrientation");
		m.put("this", this);
		stdop<ScrollbarOrientation> result;
		m.call(result);
		return result;
	}

	double /*var-non-null*/ RawScrollbar::mainAxisMargin() {
		auto m = ManagedCall("RawScrollbar", "mainAxisMargin");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	double /*var-non-null*/ RawScrollbar::crossAxisMargin() {
		auto m = ManagedCall("RawScrollbar", "crossAxisMargin");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	shptr<class EdgeInsets> /*var-nullable*/ RawScrollbar::padding() {
		auto m = ManagedCall("RawScrollbar", "padding");
		m.put("this", this);
		shptr<class EdgeInsets> result;
		m.call(result);
		return result;
	}

	shptr<class RawScrollbar> /*non-null*/ RawScrollbar::ctorMain(_ctorMain p) {
		auto m = ManagedCall("RawScrollbar", "RawScrollbar");
		m.put("key", p.key);
		m.put("child", p.child, true);
		m.put("controller", p.controller);
		m.put("thumbVisibility", p.thumbVisibility);
		m.put("shape", p.shape);
		m.put("radius", p.radius);
		m.put("thickness", p.thickness);
		m.put("thumbColor", p.thumbColor);
		m.put("minThumbLength", p.minThumbLength);
		m.put("minOverscrollLength", p.minOverscrollLength);
		m.put("trackVisibility", p.trackVisibility);
		m.put("trackRadius", p.trackRadius);
		m.put("trackColor", p.trackColor);
		m.put("trackBorderColor", p.trackBorderColor);
		m.put("fadeDuration", p.fadeDuration, true);
		m.put("timeToFade", p.timeToFade, true);
		m.put("pressDuration", p.pressDuration, true);
//		m.put("notificationPredicate", p.notificationPredicate, true);
		m.put("interactive", p.interactive);
		m.put("scrollbarOrientation", p.scrollbarOrientation);
		m.put("mainAxisMargin", p.mainAxisMargin);
		m.put("crossAxisMargin", p.crossAxisMargin);
		m.put("padding", p.padding);
		shptr<class RawScrollbar> result;
		m.check(m.call(result, true));
		return result;
	}

	stdop<int64> /*var-nullable*/ DataTable::sortColumnIndex() {
		auto m = ManagedCall("DataTable", "sortColumnIndex");
		m.put("this", this);
		stdop<int64> result;
		m.call(result);
		return result;
	}

	bool /*var-non-null*/ DataTable::sortAscending() {
		auto m = ManagedCall("DataTable", "sortAscending");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Decoration> /*var-nullable*/ DataTable::decoration() {
		auto m = ManagedCall("DataTable", "decoration");
		m.put("this", this);
		shptr<class Decoration> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ DataTable::dataRowMinHeight() {
		auto m = ManagedCall("DataTable", "dataRowMinHeight");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ DataTable::dataRowMaxHeight() {
		auto m = ManagedCall("DataTable", "dataRowMaxHeight");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	shptr<class TextStyle> /*var-nullable*/ DataTable::dataTextStyle() {
		auto m = ManagedCall("DataTable", "dataTextStyle");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ DataTable::headingRowHeight() {
		auto m = ManagedCall("DataTable", "headingRowHeight");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	shptr<class TextStyle> /*var-nullable*/ DataTable::headingTextStyle() {
		auto m = ManagedCall("DataTable", "headingTextStyle");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ DataTable::horizontalMargin() {
		auto m = ManagedCall("DataTable", "horizontalMargin");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ DataTable::columnSpacing() {
		auto m = ManagedCall("DataTable", "columnSpacing");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	bool /*var-non-null*/ DataTable::showCheckboxColumn() {
		auto m = ManagedCall("DataTable", "showCheckboxColumn");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	stdop<double> /*var-nullable*/ DataTable::dividerThickness() {
		auto m = ManagedCall("DataTable", "dividerThickness");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	bool /*var-non-null*/ DataTable::showBottomBorder() {
		auto m = ManagedCall("DataTable", "showBottomBorder");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	stdop<double> /*var-nullable*/ DataTable::checkboxHorizontalMargin() {
		auto m = ManagedCall("DataTable", "checkboxHorizontalMargin");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	shptr<class TableBorder> /*var-nullable*/ DataTable::border() {
		auto m = ManagedCall("DataTable", "border");
		m.put("this", this);
		shptr<class TableBorder> result;
		m.call(result);
		return result;
	}

	Clip /*var-non-null*/ DataTable::clipBehavior() {
		auto m = ManagedCall("DataTable", "clipBehavior");
		m.put("this", this);
		Clip result;
		m.check(m.call(result));
		return result;
	}

	stdop<double> /*get-nullable*/ DataTable::dataRowHeight() {
		auto m = ManagedCall("DataTable", "dataRowHeight");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	shptr<class DataTable> /*non-null*/ DataTable::ctorMain(_ctorMain p) {
		auto m = ManagedCall("DataTable", "DataTable");
		m.put("key", p.key);
		m.put("columns", p.columns);
		m.put("sortColumnIndex", p.sortColumnIndex);
		m.put("sortAscending", p.sortAscending);
		m.put("onSelectAll", p.onSelectAll);
		m.put("decoration", p.decoration);
		m.put("dataRowColor", p.dataRowColor);
		m.put("dataRowHeight", p.dataRowHeight);
		m.put("dataRowMinHeight", p.dataRowMinHeight);
		m.put("dataRowMaxHeight", p.dataRowMaxHeight);
		m.put("dataTextStyle", p.dataTextStyle);
		m.put("headingRowColor", p.headingRowColor);
		m.put("headingRowHeight", p.headingRowHeight);
		m.put("headingTextStyle", p.headingTextStyle);
		m.put("horizontalMargin", p.horizontalMargin);
		m.put("columnSpacing", p.columnSpacing);
		m.put("showCheckboxColumn", p.showCheckboxColumn);
		m.put("showBottomBorder", p.showBottomBorder);
		m.put("dividerThickness", p.dividerThickness);
		m.put("rows", p.rows);
		m.put("checkboxHorizontalMargin", p.checkboxHorizontalMargin);
		m.put("border", p.border);
		m.put("clipBehavior", p.clipBehavior);
		shptr<class DataTable> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Widget> /*var-non-null*/ DataColumn::label() {
		auto m = ManagedCall("DataColumn", "label");
		m.put("this", this);
		shptr<class Widget> result;
		m.check(m.call(result));
		return result;
	}

	stdop<stdstr> /*var-nullable*/ DataColumn::tooltip() {
		auto m = ManagedCall("DataColumn", "tooltip");
		m.put("this", this);
		stdop<stdstr> result;
		m.call(result);
		return result;
	}

	bool /*var-non-null*/ DataColumn::numeric() {
		auto m = ManagedCall("DataColumn", "numeric");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class DataColumn> /*non-null*/ DataColumn::ctorMain(_ctorMain p) {
		auto m = ManagedCall("DataColumn", "DataColumn");
		m.put("label", p.label, true);
		m.put("tooltip", p.tooltip);
		m.put("numeric", p.numeric);
		m.put("onSort", p.onSort);
		m.put("mouseCursor", p.mouseCursor);
		shptr<class DataColumn> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class LocalKey> /*var-nullable*/ DataRow::key() {
		auto m = ManagedCall("DataRow", "key");
		m.put("this", this);
		shptr<class LocalKey> result;
		m.call(result);
		return result;
	}

	bool /*var-non-null*/ DataRow::selected() {
		auto m = ManagedCall("DataRow", "selected");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class DataRow> /*non-null*/ DataRow::ctorMain(_ctorMain p) {
		auto m = ManagedCall("DataRow", "DataRow");
		m.put("key", p.key);
		m.put("selected", p.selected);
		m.put("onSelectChanged", p.onSelectChanged);
		m.put("onLongPress", p.onLongPress);
		m.put("color", p.color);
		m.put("mouseCursor", p.mouseCursor);
		m.put("cells", p.cells);
		shptr<class DataRow> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class DataRow> /*non-null*/ DataRow::byIndex(_byIndex p) {
		auto m = ManagedCall("DataRow", "byIndex");
		m.put("index", p.index);
		m.put("selected", p.selected);
		m.put("onSelectChanged", p.onSelectChanged);
		m.put("onLongPress", p.onLongPress);
		m.put("color", p.color);
		m.put("mouseCursor", p.mouseCursor);
		m.put("cells", p.cells);
		shptr<class DataRow> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class DataCell> /*var-non-null*/ DataCell::empty() {
		auto m = ManagedCall("DataCell", "empty");
		shptr<class DataCell> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Widget> /*var-non-null*/ DataCell::child() {
		auto m = ManagedCall("DataCell", "child");
		m.put("this", this);
		shptr<class Widget> result;
		m.check(m.call(result));
		return result;
	}

	bool /*var-non-null*/ DataCell::placeholder() {
		auto m = ManagedCall("DataCell", "placeholder");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	bool /*var-non-null*/ DataCell::showEditIcon() {
		auto m = ManagedCall("DataCell", "showEditIcon");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class DataCell> /*non-null*/ DataCell::ctorMain(/*non-null*/ shptr<class Widget> child, _ctorMain p) {
		auto m = ManagedCall("DataCell", "DataCell");
		m.put("child", child, true);
		m.put("placeholder", p.placeholder);
		m.put("showEditIcon", p.showEditIcon);
		m.put("onTap", p.onTap);
		m.put("onLongPress", p.onLongPress);
		m.put("onTapDown", p.onTapDown);
		m.put("onDoubleTap", p.onDoubleTap);
		m.put("onTapCancel", p.onTapCancel);
		shptr<class DataCell> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class CustomScrollView> /*non-null*/ CustomScrollView::ctorMain(_ctorMain p) {
		auto m = ManagedCall("CustomScrollView", "CustomScrollView");
		m.put("key", p.key);
		m.put("scrollDirection", p.scrollDirection);
		m.put("reverse", p.reverse);
		m.put("controller", p.controller);
		m.put("primary", p.primary);
		m.put("physics", p.physics);
		m.put("scrollBehavior", p.scrollBehavior);
		m.put("shrinkWrap", p.shrinkWrap);
		m.put("center", p.center);
		m.put("anchor", p.anchor);
		m.put("cacheExtent", p.cacheExtent);
		m.put("slivers", p.slivers);
		m.put("semanticChildCount", p.semanticChildCount);
		m.put("dragStartBehavior", p.dragStartBehavior);
		m.put("keyboardDismissBehavior", p.keyboardDismissBehavior);
		m.put("restorationId", p.restorationId);
		m.put("clipBehavior", p.clipBehavior);
		shptr<class CustomScrollView> result;
		m.check(m.call(result, true));
		return result;
	}

	int64 /*var-non-null*/ PageController::initialPage() {
		auto m = ManagedCall("PageController", "initialPage");
		m.put("this", this);
		int64 result;
		m.check(m.call(result));
		return result;
	}

	bool /*var-non-null*/ PageController::keepPage() {
		auto m = ManagedCall("PageController", "keepPage");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	double /*var-non-null*/ PageController::viewportFraction() {
		auto m = ManagedCall("PageController", "viewportFraction");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	stdop<double> /*get-nullable*/ PageController::page() {
		auto m = ManagedCall("PageController", "page");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	void PageController::jumpToPage(/*non-null*/ int64 page) {
		auto m = ManagedCall("PageController", "jumpToPage");
		m.put("this", this);
		m.put("page", page);
		m.call();
	}

	shptr<class ScrollPosition> /*non-null*/ PageController::createScrollPosition(/*non-null*/ shptr<class ScrollPhysics> physics, /*non-null*/ shptr<class ScrollContext> context, /*nullable*/ shptr<class ScrollPosition> oldPosition) {
		auto m = ManagedCall("PageController", "createScrollPosition");
		m.put("this", this);
		m.put("physics", physics, true);
		m.put("context", context, true);
		m.put("oldPosition", oldPosition);
		shptr<class ScrollPosition> result;
		m.check(m.call(result));
		return result;
	}

	void PageController::attach(/*non-null*/ shptr<class ScrollPosition> position) {
		auto m = ManagedCall("PageController", "attach");
		m.put("this", this);
		m.put("position", position, true);
		m.call();
	}

	shptr<class PageController> /*non-null*/ PageController::ctorMain(_ctorMain p) {
		auto m = ManagedCall("PageController", "PageController");
		m.put("initialPage", p.initialPage);
		m.put("keepPage", p.keepPage);
		m.put("viewportFraction", p.viewportFraction);
		shptr<class PageController> result;
		m.check(m.call(result, true));
		return result;
	}

	bool /*var-non-null*/ PageView::allowImplicitScrolling() {
		auto m = ManagedCall("PageView", "allowImplicitScrolling");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	stdop<stdstr> /*var-nullable*/ PageView::restorationId() {
		auto m = ManagedCall("PageView", "restorationId");
		m.put("this", this);
		stdop<stdstr> result;
		m.call(result);
		return result;
	}

	Axis /*var-non-null*/ PageView::scrollDirection() {
		auto m = ManagedCall("PageView", "scrollDirection");
		m.put("this", this);
		Axis result;
		m.check(m.call(result));
		return result;
	}

	bool /*var-non-null*/ PageView::reverse() {
		auto m = ManagedCall("PageView", "reverse");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class PageController> /*var-non-null*/ PageView::controller() {
		auto m = ManagedCall("PageView", "controller");
		m.put("this", this);
		shptr<class PageController> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ScrollPhysics> /*var-nullable*/ PageView::physics() {
		auto m = ManagedCall("PageView", "physics");
		m.put("this", this);
		shptr<class ScrollPhysics> result;
		m.call(result);
		return result;
	}

	bool /*var-non-null*/ PageView::pageSnapping() {
		auto m = ManagedCall("PageView", "pageSnapping");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class SliverChildDelegate> /*var-non-null*/ PageView::childrenDelegate() {
		auto m = ManagedCall("PageView", "childrenDelegate");
		m.put("this", this);
		shptr<class SliverChildDelegate> result;
		m.check(m.call(result));
		return result;
	}

	DragStartBehavior /*var-non-null*/ PageView::dragStartBehavior() {
		auto m = ManagedCall("PageView", "dragStartBehavior");
		m.put("this", this);
		DragStartBehavior result;
		m.check(m.call(result));
		return result;
	}

	Clip /*var-non-null*/ PageView::clipBehavior() {
		auto m = ManagedCall("PageView", "clipBehavior");
		m.put("this", this);
		Clip result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ScrollBehavior> /*var-nullable*/ PageView::scrollBehavior() {
		auto m = ManagedCall("PageView", "scrollBehavior");
		m.put("this", this);
		shptr<class ScrollBehavior> result;
		m.call(result);
		return result;
	}

	bool /*var-non-null*/ PageView::padEnds() {
		auto m = ManagedCall("PageView", "padEnds");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class PageView> /*non-null*/ PageView::ctorMain(_ctorMain p) {
		auto m = ManagedCall("PageView", "PageView");
		m.put("key", p.key);
		m.put("scrollDirection", p.scrollDirection);
		m.put("reverse", p.reverse);
		m.put("controller", p.controller);
		m.put("physics", p.physics);
		m.put("pageSnapping", p.pageSnapping);
		m.put("onPageChanged", p.onPageChanged);
		m.put("children", p.children);
		m.put("dragStartBehavior", p.dragStartBehavior);
		m.put("allowImplicitScrolling", p.allowImplicitScrolling);
		m.put("restorationId", p.restorationId);
		m.put("clipBehavior", p.clipBehavior);
		m.put("scrollBehavior", p.scrollBehavior);
		m.put("padEnds", p.padEnds);
		shptr<class PageView> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class PageView> /*non-null*/ PageView::builder(_builder p) {
		auto m = ManagedCall("PageView", "builder");
		m.put("key", p.key);
		m.put("scrollDirection", p.scrollDirection);
		m.put("reverse", p.reverse);
		m.put("controller", p.controller);
		m.put("physics", p.physics);
		m.put("pageSnapping", p.pageSnapping);
		m.put("onPageChanged", p.onPageChanged);
		m.put("itemBuilder", p.itemBuilder, true);
		m.put("findChildIndexCallback", p.findChildIndexCallback);
		m.put("itemCount", p.itemCount);
		m.put("dragStartBehavior", p.dragStartBehavior);
		m.put("allowImplicitScrolling", p.allowImplicitScrolling);
		m.put("restorationId", p.restorationId);
		m.put("clipBehavior", p.clipBehavior);
		m.put("scrollBehavior", p.scrollBehavior);
		m.put("padEnds", p.padEnds);
		shptr<class PageView> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class PageView> /*non-null*/ PageView::custom(_custom p) {
		auto m = ManagedCall("PageView", "custom");
		m.put("key", p.key);
		m.put("scrollDirection", p.scrollDirection);
		m.put("reverse", p.reverse);
		m.put("controller", p.controller);
		m.put("physics", p.physics);
		m.put("pageSnapping", p.pageSnapping);
		m.put("onPageChanged", p.onPageChanged);
		m.put("childrenDelegate", p.childrenDelegate, true);
		m.put("dragStartBehavior", p.dragStartBehavior);
		m.put("allowImplicitScrolling", p.allowImplicitScrolling);
		m.put("restorationId", p.restorationId);
		m.put("clipBehavior", p.clipBehavior);
		m.put("scrollBehavior", p.scrollBehavior);
		m.put("padEnds", p.padEnds);
		shptr<class PageView> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class SliverGridDelegate> /*var-non-null*/ GridView::gridDelegate() {
		auto m = ManagedCall("GridView", "gridDelegate");
		m.put("this", this);
		shptr<class SliverGridDelegate> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class SliverChildDelegate> /*var-non-null*/ GridView::childrenDelegate() {
		auto m = ManagedCall("GridView", "childrenDelegate");
		m.put("this", this);
		shptr<class SliverChildDelegate> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Widget> /*non-null*/ GridView::buildChildLayout(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("GridView", "buildChildLayout");
		m.put("this", this);
		m.put("context", context, true);
		shptr<class Widget> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class GridView> /*non-null*/ GridView::ctorMain(_ctorMain p) {
		auto m = ManagedCall("GridView", "GridView");
		m.put("key", p.key);
		m.put("scrollDirection", p.scrollDirection);
		m.put("reverse", p.reverse);
		m.put("controller", p.controller);
		m.put("primary", p.primary);
		m.put("physics", p.physics);
		m.put("shrinkWrap", p.shrinkWrap);
		m.put("padding", p.padding);
		m.put("gridDelegate", p.gridDelegate, true);
		m.put("addAutomaticKeepAlives", p.addAutomaticKeepAlives);
		m.put("addRepaintBoundaries", p.addRepaintBoundaries);
		m.put("addSemanticIndexes", p.addSemanticIndexes);
		m.put("cacheExtent", p.cacheExtent);
		m.put("children", p.children);
		m.put("semanticChildCount", p.semanticChildCount);
		m.put("dragStartBehavior", p.dragStartBehavior);
		m.put("clipBehavior", p.clipBehavior);
		m.put("keyboardDismissBehavior", p.keyboardDismissBehavior);
		m.put("restorationId", p.restorationId);
		shptr<class GridView> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class GridView> /*non-null*/ GridView::builder(_builder p) {
		auto m = ManagedCall("GridView", "builder");
		m.put("key", p.key);
		m.put("scrollDirection", p.scrollDirection);
		m.put("reverse", p.reverse);
		m.put("controller", p.controller);
		m.put("primary", p.primary);
		m.put("physics", p.physics);
		m.put("shrinkWrap", p.shrinkWrap);
		m.put("padding", p.padding);
		m.put("gridDelegate", p.gridDelegate, true);
		m.put("itemBuilder", p.itemBuilder, true);
		m.put("findChildIndexCallback", p.findChildIndexCallback);
		m.put("itemCount", p.itemCount);
		m.put("addAutomaticKeepAlives", p.addAutomaticKeepAlives);
		m.put("addRepaintBoundaries", p.addRepaintBoundaries);
		m.put("addSemanticIndexes", p.addSemanticIndexes);
		m.put("cacheExtent", p.cacheExtent);
		m.put("semanticChildCount", p.semanticChildCount);
		m.put("dragStartBehavior", p.dragStartBehavior);
		m.put("keyboardDismissBehavior", p.keyboardDismissBehavior);
		m.put("restorationId", p.restorationId);
		m.put("clipBehavior", p.clipBehavior);
		shptr<class GridView> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class GridView> /*non-null*/ GridView::custom(_custom p) {
		auto m = ManagedCall("GridView", "custom");
		m.put("key", p.key);
		m.put("scrollDirection", p.scrollDirection);
		m.put("reverse", p.reverse);
		m.put("controller", p.controller);
		m.put("primary", p.primary);
		m.put("physics", p.physics);
		m.put("shrinkWrap", p.shrinkWrap);
		m.put("padding", p.padding);
		m.put("gridDelegate", p.gridDelegate, true);
		m.put("childrenDelegate", p.childrenDelegate, true);
		m.put("cacheExtent", p.cacheExtent);
		m.put("semanticChildCount", p.semanticChildCount);
		m.put("dragStartBehavior", p.dragStartBehavior);
		m.put("keyboardDismissBehavior", p.keyboardDismissBehavior);
		m.put("restorationId", p.restorationId);
		m.put("clipBehavior", p.clipBehavior);
		shptr<class GridView> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class GridView> /*non-null*/ GridView::count(_count p) {
		auto m = ManagedCall("GridView", "count");
		m.put("key", p.key);
		m.put("scrollDirection", p.scrollDirection);
		m.put("reverse", p.reverse);
		m.put("controller", p.controller);
		m.put("primary", p.primary);
		m.put("physics", p.physics);
		m.put("shrinkWrap", p.shrinkWrap);
		m.put("padding", p.padding);
		m.put("crossAxisCount", p.crossAxisCount);
		m.put("mainAxisSpacing", p.mainAxisSpacing);
		m.put("crossAxisSpacing", p.crossAxisSpacing);
		m.put("childAspectRatio", p.childAspectRatio);
		m.put("addAutomaticKeepAlives", p.addAutomaticKeepAlives);
		m.put("addRepaintBoundaries", p.addRepaintBoundaries);
		m.put("addSemanticIndexes", p.addSemanticIndexes);
		m.put("cacheExtent", p.cacheExtent);
		m.put("children", p.children);
		m.put("semanticChildCount", p.semanticChildCount);
		m.put("dragStartBehavior", p.dragStartBehavior);
		m.put("keyboardDismissBehavior", p.keyboardDismissBehavior);
		m.put("restorationId", p.restorationId);
		m.put("clipBehavior", p.clipBehavior);
		shptr<class GridView> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class GridView> /*non-null*/ GridView::extent(_extent p) {
		auto m = ManagedCall("GridView", "extent");
		m.put("key", p.key);
		m.put("scrollDirection", p.scrollDirection);
		m.put("reverse", p.reverse);
		m.put("controller", p.controller);
		m.put("primary", p.primary);
		m.put("physics", p.physics);
		m.put("shrinkWrap", p.shrinkWrap);
		m.put("padding", p.padding);
		m.put("maxCrossAxisExtent", p.maxCrossAxisExtent);
		m.put("mainAxisSpacing", p.mainAxisSpacing);
		m.put("crossAxisSpacing", p.crossAxisSpacing);
		m.put("childAspectRatio", p.childAspectRatio);
		m.put("addAutomaticKeepAlives", p.addAutomaticKeepAlives);
		m.put("addRepaintBoundaries", p.addRepaintBoundaries);
		m.put("addSemanticIndexes", p.addSemanticIndexes);
		m.put("cacheExtent", p.cacheExtent);
		m.put("children", p.children);
		m.put("semanticChildCount", p.semanticChildCount);
		m.put("dragStartBehavior", p.dragStartBehavior);
		m.put("keyboardDismissBehavior", p.keyboardDismissBehavior);
		m.put("restorationId", p.restorationId);
		m.put("clipBehavior", p.clipBehavior);
		shptr<class GridView> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Widget> /*var-nullable*/ GridTile::header() {
		auto m = ManagedCall("GridTile", "header");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	shptr<class Widget> /*var-nullable*/ GridTile::footer() {
		auto m = ManagedCall("GridTile", "footer");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	shptr<class Widget> /*var-non-null*/ GridTile::child() {
		auto m = ManagedCall("GridTile", "child");
		m.put("this", this);
		shptr<class Widget> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class GridTile> /*non-null*/ GridTile::ctorMain(_ctorMain p) {
		auto m = ManagedCall("GridTile", "GridTile");
		m.put("key", p.key);
		m.put("header", p.header);
		m.put("footer", p.footer);
		m.put("child", p.child, true);
		shptr<class GridTile> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Color> /*var-nullable*/ GridTileBar::backgroundColor() {
		auto m = ManagedCall("GridTileBar", "backgroundColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Widget> /*var-nullable*/ GridTileBar::leading() {
		auto m = ManagedCall("GridTileBar", "leading");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	shptr<class Widget> /*var-nullable*/ GridTileBar::title() {
		auto m = ManagedCall("GridTileBar", "title");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	shptr<class Widget> /*var-nullable*/ GridTileBar::subtitle() {
		auto m = ManagedCall("GridTileBar", "subtitle");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	shptr<class Widget> /*var-nullable*/ GridTileBar::trailing() {
		auto m = ManagedCall("GridTileBar", "trailing");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	shptr<class GridTileBar> /*non-null*/ GridTileBar::ctorMain(_ctorMain p) {
		auto m = ManagedCall("GridTileBar", "GridTileBar");
		m.put("key", p.key);
		m.put("backgroundColor", p.backgroundColor);
		m.put("leading", p.leading);
		m.put("title", p.title);
		m.put("subtitle", p.subtitle);
		m.put("trailing", p.trailing);
		shptr<class GridTileBar> result;
		m.check(m.call(result, true));
		return result;
	}

	Axis /*var-non-null*/ SingleChildScrollView::scrollDirection() {
		auto m = ManagedCall("SingleChildScrollView", "scrollDirection");
		m.put("this", this);
		Axis result;
		m.check(m.call(result));
		return result;
	}

	bool /*var-non-null*/ SingleChildScrollView::reverse() {
		auto m = ManagedCall("SingleChildScrollView", "reverse");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class EdgeInsetsGeometry> /*var-nullable*/ SingleChildScrollView::padding() {
		auto m = ManagedCall("SingleChildScrollView", "padding");
		m.put("this", this);
		shptr<class EdgeInsetsGeometry> result;
		m.call(result);
		return result;
	}

	shptr<class ScrollController> /*var-nullable*/ SingleChildScrollView::controller() {
		auto m = ManagedCall("SingleChildScrollView", "controller");
		m.put("this", this);
		shptr<class ScrollController> result;
		m.call(result);
		return result;
	}

	stdop<bool> /*var-nullable*/ SingleChildScrollView::primary() {
		auto m = ManagedCall("SingleChildScrollView", "primary");
		m.put("this", this);
		stdop<bool> result;
		m.call(result);
		return result;
	}

	shptr<class ScrollPhysics> /*var-nullable*/ SingleChildScrollView::physics() {
		auto m = ManagedCall("SingleChildScrollView", "physics");
		m.put("this", this);
		shptr<class ScrollPhysics> result;
		m.call(result);
		return result;
	}

	shptr<class Widget> /*var-nullable*/ SingleChildScrollView::child() {
		auto m = ManagedCall("SingleChildScrollView", "child");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	DragStartBehavior /*var-non-null*/ SingleChildScrollView::dragStartBehavior() {
		auto m = ManagedCall("SingleChildScrollView", "dragStartBehavior");
		m.put("this", this);
		DragStartBehavior result;
		m.check(m.call(result));
		return result;
	}

	Clip /*var-non-null*/ SingleChildScrollView::clipBehavior() {
		auto m = ManagedCall("SingleChildScrollView", "clipBehavior");
		m.put("this", this);
		Clip result;
		m.check(m.call(result));
		return result;
	}

	stdop<stdstr> /*var-nullable*/ SingleChildScrollView::restorationId() {
		auto m = ManagedCall("SingleChildScrollView", "restorationId");
		m.put("this", this);
		stdop<stdstr> result;
		m.call(result);
		return result;
	}

	ScrollViewKeyboardDismissBehavior /*var-non-null*/ SingleChildScrollView::keyboardDismissBehavior() {
		auto m = ManagedCall("SingleChildScrollView", "keyboardDismissBehavior");
		m.put("this", this);
		ScrollViewKeyboardDismissBehavior result;
		m.check(m.call(result));
		return result;
	}

	shptr<class SingleChildScrollView> /*non-null*/ SingleChildScrollView::ctorMain(_ctorMain p) {
		auto m = ManagedCall("SingleChildScrollView", "SingleChildScrollView");
		m.put("key", p.key);
		m.put("scrollDirection", p.scrollDirection);
		m.put("reverse", p.reverse);
		m.put("padding", p.padding);
		m.put("primary", p.primary);
		m.put("physics", p.physics);
		m.put("controller", p.controller);
		m.put("child", p.child);
		m.put("dragStartBehavior", p.dragStartBehavior);
		m.put("clipBehavior", p.clipBehavior);
		m.put("restorationId", p.restorationId);
		m.put("keyboardDismissBehavior", p.keyboardDismissBehavior);
		shptr<class SingleChildScrollView> result;
		m.check(m.call(result, true));
		return result;
	}

	int64 /*var-non-null*/ ReorderableListView::itemCount() {
		auto m = ManagedCall("ReorderableListView", "itemCount");
		m.put("this", this);
		int64 result;
		m.check(m.call(result));
		return result;
	}

	bool /*var-non-null*/ ReorderableListView::buildDefaultDragHandles() {
		auto m = ManagedCall("ReorderableListView", "buildDefaultDragHandles");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class EdgeInsets> /*var-nullable*/ ReorderableListView::padding() {
		auto m = ManagedCall("ReorderableListView", "padding");
		m.put("this", this);
		shptr<class EdgeInsets> result;
		m.call(result);
		return result;
	}

	shptr<class Widget> /*var-nullable*/ ReorderableListView::header() {
		auto m = ManagedCall("ReorderableListView", "header");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	shptr<class Widget> /*var-nullable*/ ReorderableListView::footer() {
		auto m = ManagedCall("ReorderableListView", "footer");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	Axis /*var-non-null*/ ReorderableListView::scrollDirection() {
		auto m = ManagedCall("ReorderableListView", "scrollDirection");
		m.put("this", this);
		Axis result;
		m.check(m.call(result));
		return result;
	}

	bool /*var-non-null*/ ReorderableListView::reverse() {
		auto m = ManagedCall("ReorderableListView", "reverse");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ScrollController> /*var-nullable*/ ReorderableListView::scrollController() {
		auto m = ManagedCall("ReorderableListView", "scrollController");
		m.put("this", this);
		shptr<class ScrollController> result;
		m.call(result);
		return result;
	}

	stdop<bool> /*var-nullable*/ ReorderableListView::primary() {
		auto m = ManagedCall("ReorderableListView", "primary");
		m.put("this", this);
		stdop<bool> result;
		m.call(result);
		return result;
	}

	shptr<class ScrollPhysics> /*var-nullable*/ ReorderableListView::physics() {
		auto m = ManagedCall("ReorderableListView", "physics");
		m.put("this", this);
		shptr<class ScrollPhysics> result;
		m.call(result);
		return result;
	}

	bool /*var-non-null*/ ReorderableListView::shrinkWrap() {
		auto m = ManagedCall("ReorderableListView", "shrinkWrap");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	double /*var-non-null*/ ReorderableListView::anchor() {
		auto m = ManagedCall("ReorderableListView", "anchor");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	stdop<double> /*var-nullable*/ ReorderableListView::cacheExtent() {
		auto m = ManagedCall("ReorderableListView", "cacheExtent");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	DragStartBehavior /*var-non-null*/ ReorderableListView::dragStartBehavior() {
		auto m = ManagedCall("ReorderableListView", "dragStartBehavior");
		m.put("this", this);
		DragStartBehavior result;
		m.check(m.call(result));
		return result;
	}

	ScrollViewKeyboardDismissBehavior /*var-non-null*/ ReorderableListView::keyboardDismissBehavior() {
		auto m = ManagedCall("ReorderableListView", "keyboardDismissBehavior");
		m.put("this", this);
		ScrollViewKeyboardDismissBehavior result;
		m.check(m.call(result));
		return result;
	}

	stdop<stdstr> /*var-nullable*/ ReorderableListView::restorationId() {
		auto m = ManagedCall("ReorderableListView", "restorationId");
		m.put("this", this);
		stdop<stdstr> result;
		m.call(result);
		return result;
	}

	Clip /*var-non-null*/ ReorderableListView::clipBehavior() {
		auto m = ManagedCall("ReorderableListView", "clipBehavior");
		m.put("this", this);
		Clip result;
		m.check(m.call(result));
		return result;
	}

	stdop<double> /*var-nullable*/ ReorderableListView::itemExtent() {
		auto m = ManagedCall("ReorderableListView", "itemExtent");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	shptr<class Widget> /*var-nullable*/ ReorderableListView::prototypeItem() {
		auto m = ManagedCall("ReorderableListView", "prototypeItem");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ ReorderableListView::autoScrollerVelocityScalar() {
		auto m = ManagedCall("ReorderableListView", "autoScrollerVelocityScalar");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	shptr<class ReorderableListView> /*non-null*/ ReorderableListView::ctorMain(_ctorMain p) {
		auto m = ManagedCall("ReorderableListView", "ReorderableListView");
		m.put("key", p.key);
		m.put("children", p.children);
		m.put("onReorder", p.onReorder, true);
		m.put("onReorderStart", p.onReorderStart);
		m.put("onReorderEnd", p.onReorderEnd);
		m.put("itemExtent", p.itemExtent);
		m.put("prototypeItem", p.prototypeItem);
		m.put("proxyDecorator", p.proxyDecorator);
		m.put("buildDefaultDragHandles", p.buildDefaultDragHandles);
		m.put("padding", p.padding);
		m.put("header", p.header);
		m.put("footer", p.footer);
		m.put("scrollDirection", p.scrollDirection);
		m.put("reverse", p.reverse);
		m.put("scrollController", p.scrollController);
		m.put("primary", p.primary);
		m.put("physics", p.physics);
		m.put("shrinkWrap", p.shrinkWrap);
		m.put("anchor", p.anchor);
		m.put("cacheExtent", p.cacheExtent);
		m.put("dragStartBehavior", p.dragStartBehavior);
		m.put("keyboardDismissBehavior", p.keyboardDismissBehavior);
		m.put("restorationId", p.restorationId);
		m.put("clipBehavior", p.clipBehavior);
		m.put("autoScrollerVelocityScalar", p.autoScrollerVelocityScalar);
		shptr<class ReorderableListView> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class ReorderableListView> /*non-null*/ ReorderableListView::builder(_builder p) {
		auto m = ManagedCall("ReorderableListView", "builder");
		m.put("key", p.key);
		m.put("itemBuilder", p.itemBuilder, true);
		m.put("itemCount", p.itemCount);
		m.put("onReorder", p.onReorder, true);
		m.put("onReorderStart", p.onReorderStart);
		m.put("onReorderEnd", p.onReorderEnd);
		m.put("itemExtent", p.itemExtent);
		m.put("prototypeItem", p.prototypeItem);
		m.put("proxyDecorator", p.proxyDecorator);
		m.put("buildDefaultDragHandles", p.buildDefaultDragHandles);
		m.put("padding", p.padding);
		m.put("header", p.header);
		m.put("footer", p.footer);
		m.put("scrollDirection", p.scrollDirection);
		m.put("reverse", p.reverse);
		m.put("scrollController", p.scrollController);
		m.put("primary", p.primary);
		m.put("physics", p.physics);
		m.put("shrinkWrap", p.shrinkWrap);
		m.put("anchor", p.anchor);
		m.put("cacheExtent", p.cacheExtent);
		m.put("dragStartBehavior", p.dragStartBehavior);
		m.put("keyboardDismissBehavior", p.keyboardDismissBehavior);
		m.put("restorationId", p.restorationId);
		m.put("clipBehavior", p.clipBehavior);
		m.put("autoScrollerVelocityScalar", p.autoScrollerVelocityScalar);
		shptr<class ReorderableListView> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class SliverList> /*non-null*/ SliverList::ctorMain(_ctorMain p) {
		auto m = ManagedCall("SliverList", "SliverList");
		m.put("key", p.key);
		m.put("delegate", p.delegate, true);
		shptr<class SliverList> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class SliverList> /*non-null*/ SliverList::builder(_builder p) {
		auto m = ManagedCall("SliverList", "builder");
		m.put("key", p.key);
		m.put("itemBuilder", p.itemBuilder, true);
		m.put("findChildIndexCallback", p.findChildIndexCallback);
		m.put("itemCount", p.itemCount);
		m.put("addAutomaticKeepAlives", p.addAutomaticKeepAlives);
		m.put("addRepaintBoundaries", p.addRepaintBoundaries);
		m.put("addSemanticIndexes", p.addSemanticIndexes);
		shptr<class SliverList> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class SliverList> /*non-null*/ SliverList::separated(_separated p) {
		auto m = ManagedCall("SliverList", "separated");
		m.put("key", p.key);
		m.put("itemBuilder", p.itemBuilder, true);
		m.put("findChildIndexCallback", p.findChildIndexCallback);
		m.put("separatorBuilder", p.separatorBuilder, true);
		m.put("itemCount", p.itemCount);
		m.put("addAutomaticKeepAlives", p.addAutomaticKeepAlives);
		m.put("addRepaintBoundaries", p.addRepaintBoundaries);
		m.put("addSemanticIndexes", p.addSemanticIndexes);
		shptr<class SliverList> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class SliverList> /*non-null*/ SliverList::list(_list p) {
		auto m = ManagedCall("SliverList", "list");
		m.put("key", p.key);
		m.put("children", p.children);
		m.put("addAutomaticKeepAlives", p.addAutomaticKeepAlives);
		m.put("addRepaintBoundaries", p.addRepaintBoundaries);
		m.put("addSemanticIndexes", p.addSemanticIndexes);
		shptr<class SliverList> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class SliverGridDelegate> /*var-non-null*/ SliverGrid::gridDelegate() {
		auto m = ManagedCall("SliverGrid", "gridDelegate");
		m.put("this", this);
		shptr<class SliverGridDelegate> result;
		m.check(m.call(result));
		return result;
	}

	double /*non-null*/ SliverGrid::estimateMaxScrollOffset(/*nullable*/ shptr<class SliverConstraints> constraints, /*non-null*/ int64 firstIndex, /*non-null*/ int64 lastIndex, /*non-null*/ double leadingScrollOffset, /*non-null*/ double trailingScrollOffset) {
		auto m = ManagedCall("SliverGrid", "estimateMaxScrollOffset");
		m.put("this", this);
		m.put("constraints", constraints);
		m.put("firstIndex", firstIndex);
		m.put("lastIndex", lastIndex);
		m.put("leadingScrollOffset", leadingScrollOffset);
		m.put("trailingScrollOffset", trailingScrollOffset);
		double result;
		m.check(m.call(result));
		return result;
	}

	shptr<class SliverGrid> /*non-null*/ SliverGrid::ctorMain(_ctorMain p) {
		auto m = ManagedCall("SliverGrid", "SliverGrid");
		m.put("key", p.key);
		m.put("delegate", p.delegate, true);
		m.put("gridDelegate", p.gridDelegate, true);
		shptr<class SliverGrid> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class SliverGrid> /*non-null*/ SliverGrid::builder(_builder p) {
		auto m = ManagedCall("SliverGrid", "builder");
		m.put("key", p.key);
		m.put("gridDelegate", p.gridDelegate, true);
		m.put("itemBuilder", p.itemBuilder, true);
		m.put("findChildIndexCallback", p.findChildIndexCallback);
		m.put("itemCount", p.itemCount);
		m.put("addAutomaticKeepAlives", p.addAutomaticKeepAlives);
		m.put("addRepaintBoundaries", p.addRepaintBoundaries);
		m.put("addSemanticIndexes", p.addSemanticIndexes);
		shptr<class SliverGrid> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class SliverGrid> /*non-null*/ SliverGrid::count(_count p) {
		auto m = ManagedCall("SliverGrid", "count");
		m.put("key", p.key);
		m.put("crossAxisCount", p.crossAxisCount);
		m.put("mainAxisSpacing", p.mainAxisSpacing);
		m.put("crossAxisSpacing", p.crossAxisSpacing);
		m.put("childAspectRatio", p.childAspectRatio);
		m.put("children", p.children);
		shptr<class SliverGrid> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class SliverGrid> /*non-null*/ SliverGrid::extent(_extent p) {
		auto m = ManagedCall("SliverGrid", "extent");
		m.put("key", p.key);
		m.put("maxCrossAxisExtent", p.maxCrossAxisExtent);
		m.put("mainAxisSpacing", p.mainAxisSpacing);
		m.put("crossAxisSpacing", p.crossAxisSpacing);
		m.put("childAspectRatio", p.childAspectRatio);
		m.put("children", p.children);
		shptr<class SliverGrid> result;
		m.check(m.call(result, true));
		return result;
	}

	int64 /*var-non-null*/ SliverGridDelegateWithFixedCrossAxisCount::crossAxisCount() {
		auto m = ManagedCall("SliverGridDelegateWithFixedCrossAxisCount", "crossAxisCount");
		m.put("this", this);
		int64 result;
		m.check(m.call(result));
		return result;
	}

	double /*var-non-null*/ SliverGridDelegateWithFixedCrossAxisCount::mainAxisSpacing() {
		auto m = ManagedCall("SliverGridDelegateWithFixedCrossAxisCount", "mainAxisSpacing");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	double /*var-non-null*/ SliverGridDelegateWithFixedCrossAxisCount::crossAxisSpacing() {
		auto m = ManagedCall("SliverGridDelegateWithFixedCrossAxisCount", "crossAxisSpacing");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	double /*var-non-null*/ SliverGridDelegateWithFixedCrossAxisCount::childAspectRatio() {
		auto m = ManagedCall("SliverGridDelegateWithFixedCrossAxisCount", "childAspectRatio");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	stdop<double> /*var-nullable*/ SliverGridDelegateWithFixedCrossAxisCount::mainAxisExtent() {
		auto m = ManagedCall("SliverGridDelegateWithFixedCrossAxisCount", "mainAxisExtent");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	shptr<class SliverGridLayout> /*non-null*/ SliverGridDelegateWithFixedCrossAxisCount::getLayout(/*non-null*/ shptr<class SliverConstraints> constraints) {
		auto m = ManagedCall("SliverGridDelegateWithFixedCrossAxisCount", "getLayout");
		m.put("this", this);
		m.put("constraints", constraints, true);
		shptr<class SliverGridLayout> result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ SliverGridDelegateWithFixedCrossAxisCount::shouldRelayout(/*non-null*/ shptr<class SliverGridDelegateWithFixedCrossAxisCount> oldDelegate) {
		auto m = ManagedCall("SliverGridDelegateWithFixedCrossAxisCount", "shouldRelayout");
		m.put("this", this);
		m.put("oldDelegate", oldDelegate, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class SliverGridDelegateWithFixedCrossAxisCount> /*non-null*/ SliverGridDelegateWithFixedCrossAxisCount::ctorMain(_ctorMain p) {
		auto m = ManagedCall("SliverGridDelegateWithFixedCrossAxisCount", "SliverGridDelegateWithFixedCrossAxisCount");
		m.put("crossAxisCount", p.crossAxisCount);
		m.put("mainAxisSpacing", p.mainAxisSpacing);
		m.put("crossAxisSpacing", p.crossAxisSpacing);
		m.put("childAspectRatio", p.childAspectRatio);
		m.put("mainAxisExtent", p.mainAxisExtent);
		shptr<class SliverGridDelegateWithFixedCrossAxisCount> result;
		m.check(m.call(result, true));
		return result;
	}

	double /*var-non-null*/ SliverGridDelegateWithMaxCrossAxisExtent::maxCrossAxisExtent() {
		auto m = ManagedCall("SliverGridDelegateWithMaxCrossAxisExtent", "maxCrossAxisExtent");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	double /*var-non-null*/ SliverGridDelegateWithMaxCrossAxisExtent::mainAxisSpacing() {
		auto m = ManagedCall("SliverGridDelegateWithMaxCrossAxisExtent", "mainAxisSpacing");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	double /*var-non-null*/ SliverGridDelegateWithMaxCrossAxisExtent::crossAxisSpacing() {
		auto m = ManagedCall("SliverGridDelegateWithMaxCrossAxisExtent", "crossAxisSpacing");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	double /*var-non-null*/ SliverGridDelegateWithMaxCrossAxisExtent::childAspectRatio() {
		auto m = ManagedCall("SliverGridDelegateWithMaxCrossAxisExtent", "childAspectRatio");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	stdop<double> /*var-nullable*/ SliverGridDelegateWithMaxCrossAxisExtent::mainAxisExtent() {
		auto m = ManagedCall("SliverGridDelegateWithMaxCrossAxisExtent", "mainAxisExtent");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	shptr<class SliverGridLayout> /*non-null*/ SliverGridDelegateWithMaxCrossAxisExtent::getLayout(/*non-null*/ shptr<class SliverConstraints> constraints) {
		auto m = ManagedCall("SliverGridDelegateWithMaxCrossAxisExtent", "getLayout");
		m.put("this", this);
		m.put("constraints", constraints, true);
		shptr<class SliverGridLayout> result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ SliverGridDelegateWithMaxCrossAxisExtent::shouldRelayout(/*non-null*/ shptr<class SliverGridDelegateWithMaxCrossAxisExtent> oldDelegate) {
		auto m = ManagedCall("SliverGridDelegateWithMaxCrossAxisExtent", "shouldRelayout");
		m.put("this", this);
		m.put("oldDelegate", oldDelegate, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class SliverGridDelegateWithMaxCrossAxisExtent> /*non-null*/ SliverGridDelegateWithMaxCrossAxisExtent::ctorMain(_ctorMain p) {
		auto m = ManagedCall("SliverGridDelegateWithMaxCrossAxisExtent", "SliverGridDelegateWithMaxCrossAxisExtent");
		m.put("maxCrossAxisExtent", p.maxCrossAxisExtent);
		m.put("mainAxisSpacing", p.mainAxisSpacing);
		m.put("crossAxisSpacing", p.crossAxisSpacing);
		m.put("childAspectRatio", p.childAspectRatio);
		m.put("mainAxisExtent", p.mainAxisExtent);
		shptr<class SliverGridDelegateWithMaxCrossAxisExtent> result;
		m.check(m.call(result, true));
		return result;
	}

	bool /*var-non-null*/ SliverChildListDelegate::addAutomaticKeepAlives() {
		auto m = ManagedCall("SliverChildListDelegate", "addAutomaticKeepAlives");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	bool /*var-non-null*/ SliverChildListDelegate::addRepaintBoundaries() {
		auto m = ManagedCall("SliverChildListDelegate", "addRepaintBoundaries");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	bool /*var-non-null*/ SliverChildListDelegate::addSemanticIndexes() {
		auto m = ManagedCall("SliverChildListDelegate", "addSemanticIndexes");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	int64 /*var-non-null*/ SliverChildListDelegate::semanticIndexOffset() {
		auto m = ManagedCall("SliverChildListDelegate", "semanticIndexOffset");
		m.put("this", this);
		int64 result;
		m.check(m.call(result));
		return result;
	}

	stdop<int64> /*get-nullable*/ SliverChildListDelegate::estimatedChildCount() {
		auto m = ManagedCall("SliverChildListDelegate", "estimatedChildCount");
		m.put("this", this);
		stdop<int64> result;
		m.call(result);
		return result;
	}

	stdop<int64> /*nullable*/ SliverChildListDelegate::findIndexByKey(/*non-null*/ shptr<class Key> key) {
		auto m = ManagedCall("SliverChildListDelegate", "findIndexByKey");
		m.put("this", this);
		m.put("key", key, true);
		stdop<int64> result;
		m.call(result);
		return result;
	}

	bool /*non-null*/ SliverChildListDelegate::shouldRebuild(/*non-null*/ shptr<class SliverChildListDelegate> oldDelegate) {
		auto m = ManagedCall("SliverChildListDelegate", "shouldRebuild");
		m.put("this", this);
		m.put("oldDelegate", oldDelegate, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class SliverChildListDelegate> /*non-null*/ SliverChildListDelegate::ctorMain(/*non-null*/ stdvec<shptr<class Widget>> children, _ctorMain p) {
		auto m = ManagedCall("SliverChildListDelegate", "SliverChildListDelegate");
		m.put("children", children);
		m.put("addAutomaticKeepAlives", p.addAutomaticKeepAlives);
		m.put("addRepaintBoundaries", p.addRepaintBoundaries);
		m.put("addSemanticIndexes", p.addSemanticIndexes);
//		m.put("semanticIndexCallback", p.semanticIndexCallback, true);
		m.put("semanticIndexOffset", p.semanticIndexOffset);
		shptr<class SliverChildListDelegate> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class SliverChildListDelegate> /*non-null*/ SliverChildListDelegate::fixed(/*non-null*/ stdvec<shptr<class Widget>> children, _fixed p) {
		auto m = ManagedCall("SliverChildListDelegate", "fixed");
		m.put("children", children);
		m.put("addAutomaticKeepAlives", p.addAutomaticKeepAlives);
		m.put("addRepaintBoundaries", p.addRepaintBoundaries);
		m.put("addSemanticIndexes", p.addSemanticIndexes);
//		m.put("semanticIndexCallback", p.semanticIndexCallback, true);
		m.put("semanticIndexOffset", p.semanticIndexOffset);
		shptr<class SliverChildListDelegate> result;
		m.check(m.call(result, true));
		return result;
	}

	stdop<int64> /*var-nullable*/ SliverChildBuilderDelegate::childCount() {
		auto m = ManagedCall("SliverChildBuilderDelegate", "childCount");
		m.put("this", this);
		stdop<int64> result;
		m.call(result);
		return result;
	}

	bool /*var-non-null*/ SliverChildBuilderDelegate::addAutomaticKeepAlives() {
		auto m = ManagedCall("SliverChildBuilderDelegate", "addAutomaticKeepAlives");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	bool /*var-non-null*/ SliverChildBuilderDelegate::addRepaintBoundaries() {
		auto m = ManagedCall("SliverChildBuilderDelegate", "addRepaintBoundaries");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	bool /*var-non-null*/ SliverChildBuilderDelegate::addSemanticIndexes() {
		auto m = ManagedCall("SliverChildBuilderDelegate", "addSemanticIndexes");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	int64 /*var-non-null*/ SliverChildBuilderDelegate::semanticIndexOffset() {
		auto m = ManagedCall("SliverChildBuilderDelegate", "semanticIndexOffset");
		m.put("this", this);
		int64 result;
		m.check(m.call(result));
		return result;
	}

	stdop<int64> /*get-nullable*/ SliverChildBuilderDelegate::estimatedChildCount() {
		auto m = ManagedCall("SliverChildBuilderDelegate", "estimatedChildCount");
		m.put("this", this);
		stdop<int64> result;
		m.call(result);
		return result;
	}

	stdop<int64> /*nullable*/ SliverChildBuilderDelegate::findIndexByKey(/*non-null*/ shptr<class Key> key) {
		auto m = ManagedCall("SliverChildBuilderDelegate", "findIndexByKey");
		m.put("this", this);
		m.put("key", key, true);
		stdop<int64> result;
		m.call(result);
		return result;
	}

	bool /*non-null*/ SliverChildBuilderDelegate::shouldRebuild(/*non-null*/ shptr<class SliverChildBuilderDelegate> oldDelegate) {
		auto m = ManagedCall("SliverChildBuilderDelegate", "shouldRebuild");
		m.put("this", this);
		m.put("oldDelegate", oldDelegate, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class SliverChildBuilderDelegate> /*non-null*/ SliverChildBuilderDelegate::ctorMain(/*non-null*/ stdfunc<shptr<class Widget>(shptr<class BuildContext>, int64)> /*(BuildContext, int) -> Widget*/ builder, _ctorMain p) {
		auto m = ManagedCall("SliverChildBuilderDelegate", "SliverChildBuilderDelegate");
		m.put("builder", builder, true);
		m.put("findChildIndexCallback", p.findChildIndexCallback);
		m.put("childCount", p.childCount);
		m.put("addAutomaticKeepAlives", p.addAutomaticKeepAlives);
		m.put("addRepaintBoundaries", p.addRepaintBoundaries);
		m.put("addSemanticIndexes", p.addSemanticIndexes);
//		m.put("semanticIndexCallback", p.semanticIndexCallback, true);
		m.put("semanticIndexOffset", p.semanticIndexOffset);
		shptr<class SliverChildBuilderDelegate> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Widget> /*var-non-null*/ Dismissible::child() {
		auto m = ManagedCall("Dismissible", "child");
		m.put("this", this);
		shptr<class Widget> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Widget> /*var-nullable*/ Dismissible::background() {
		auto m = ManagedCall("Dismissible", "background");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	shptr<class Widget> /*var-nullable*/ Dismissible::secondaryBackground() {
		auto m = ManagedCall("Dismissible", "secondaryBackground");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	DismissDirection /*var-non-null*/ Dismissible::direction() {
		auto m = ManagedCall("Dismissible", "direction");
		m.put("this", this);
		DismissDirection result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Duration> /*var-nullable*/ Dismissible::resizeDuration() {
		auto m = ManagedCall("Dismissible", "resizeDuration");
		m.put("this", this);
		shptr<class Duration> result;
		m.call(result);
		return result;
	}

	shptr<class Duration> /*var-non-null*/ Dismissible::movementDuration() {
		auto m = ManagedCall("Dismissible", "movementDuration");
		m.put("this", this);
		shptr<class Duration> result;
		m.check(m.call(result));
		return result;
	}

	double /*var-non-null*/ Dismissible::crossAxisEndOffset() {
		auto m = ManagedCall("Dismissible", "crossAxisEndOffset");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	DragStartBehavior /*var-non-null*/ Dismissible::dragStartBehavior() {
		auto m = ManagedCall("Dismissible", "dragStartBehavior");
		m.put("this", this);
		DragStartBehavior result;
		m.check(m.call(result));
		return result;
	}

	HitTestBehavior /*var-non-null*/ Dismissible::behavior() {
		auto m = ManagedCall("Dismissible", "behavior");
		m.put("this", this);
		HitTestBehavior result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Dismissible> /*non-null*/ Dismissible::ctorMain(_ctorMain p) {
		auto m = ManagedCall("Dismissible", "Dismissible");
		m.put("key", p.key, true);
		m.put("child", p.child, true);
		m.put("background", p.background);
		m.put("secondaryBackground", p.secondaryBackground);
//		m.put("confirmDismiss", p.confirmDismiss);
		m.put("onResize", p.onResize);
//		m.put("onUpdate", p.onUpdate);
		m.put("onDismissed", p.onDismissed);
		m.put("direction", p.direction);
		m.put("resizeDuration", p.resizeDuration);
//		m.put("dismissThresholds", p.dismissThresholds, true);
		m.put("movementDuration", p.movementDuration, true);
		m.put("crossAxisEndOffset", p.crossAxisEndOffset);
		m.put("dragStartBehavior", p.dragStartBehavior);
		m.put("behavior", p.behavior);
		shptr<class Dismissible> result;
		m.check(m.call(result, true));
		return result;
	}

	double /*get-non-null*/ DraggableScrollableController::size() {
		auto m = ManagedCall("DraggableScrollableController", "size");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	double /*get-non-null*/ DraggableScrollableController::pixels() {
		auto m = ManagedCall("DraggableScrollableController", "pixels");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	bool /*get-non-null*/ DraggableScrollableController::isAttached() {
		auto m = ManagedCall("DraggableScrollableController", "isAttached");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	double /*non-null*/ DraggableScrollableController::sizeToPixels(/*non-null*/ double size) {
		auto m = ManagedCall("DraggableScrollableController", "sizeToPixels");
		m.put("this", this);
		m.put("size", size);
		double result;
		m.check(m.call(result));
		return result;
	}

	double /*non-null*/ DraggableScrollableController::pixelsToSize(/*non-null*/ double pixels) {
		auto m = ManagedCall("DraggableScrollableController", "pixelsToSize");
		m.put("this", this);
		m.put("pixels", pixels);
		double result;
		m.check(m.call(result));
		return result;
	}

	void DraggableScrollableController::animateTo(/*non-null*/ double size, _animateTo p) {
		auto m = ManagedCall("DraggableScrollableController", "animateTo");
		m.put("this", this);
		m.put("size", size);
		m.put("duration", p.duration, true);
		m.put("curve", p.curve, true);
		m.call();
	}

	void DraggableScrollableController::jumpTo(/*non-null*/ double size) {
		auto m = ManagedCall("DraggableScrollableController", "jumpTo");
		m.put("this", this);
		m.put("size", size);
		m.call();
	}

	void DraggableScrollableController::reset() {
		auto m = ManagedCall("DraggableScrollableController", "reset");
		m.put("this", this);
		m.call();
	}

	shptr<class DraggableScrollableController> /*non-null*/ DraggableScrollableController::ctorMain() {
		auto m = ManagedCall("DraggableScrollableController", "DraggableScrollableController");
		shptr<class DraggableScrollableController> result;
		m.check(m.call(result, true));
		return result;
	}

	double /*var-non-null*/ DraggableScrollableSheet::initialChildSize() {
		auto m = ManagedCall("DraggableScrollableSheet", "initialChildSize");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	double /*var-non-null*/ DraggableScrollableSheet::minChildSize() {
		auto m = ManagedCall("DraggableScrollableSheet", "minChildSize");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	double /*var-non-null*/ DraggableScrollableSheet::maxChildSize() {
		auto m = ManagedCall("DraggableScrollableSheet", "maxChildSize");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	bool /*var-non-null*/ DraggableScrollableSheet::expand() {
		auto m = ManagedCall("DraggableScrollableSheet", "expand");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	bool /*var-non-null*/ DraggableScrollableSheet::snap() {
		auto m = ManagedCall("DraggableScrollableSheet", "snap");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Duration> /*var-nullable*/ DraggableScrollableSheet::snapAnimationDuration() {
		auto m = ManagedCall("DraggableScrollableSheet", "snapAnimationDuration");
		m.put("this", this);
		shptr<class Duration> result;
		m.call(result);
		return result;
	}

	shptr<class DraggableScrollableController> /*var-nullable*/ DraggableScrollableSheet::controller() {
		auto m = ManagedCall("DraggableScrollableSheet", "controller");
		m.put("this", this);
		shptr<class DraggableScrollableController> result;
		m.call(result);
		return result;
	}

	bool /*var-non-null*/ DraggableScrollableSheet::shouldCloseOnMinExtent() {
		auto m = ManagedCall("DraggableScrollableSheet", "shouldCloseOnMinExtent");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class DraggableScrollableSheet> /*non-null*/ DraggableScrollableSheet::ctorMain(_ctorMain p) {
		auto m = ManagedCall("DraggableScrollableSheet", "DraggableScrollableSheet");
		m.put("key", p.key);
		m.put("initialChildSize", p.initialChildSize);
		m.put("minChildSize", p.minChildSize);
		m.put("maxChildSize", p.maxChildSize);
		m.put("expand", p.expand);
		m.put("snap", p.snap);
		m.put("snapSizes", p.snapSizes);
		m.put("snapAnimationDuration", p.snapAnimationDuration);
		m.put("controller", p.controller);
		m.put("shouldCloseOnMinExtent", p.shouldCloseOnMinExtent);
		m.put("builder", p.builder, true);
		shptr<class DraggableScrollableSheet> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class ScrollController> /*var-nullable*/ ListWheelScrollView::controller() {
		auto m = ManagedCall("ListWheelScrollView", "controller");
		m.put("this", this);
		shptr<class ScrollController> result;
		m.call(result);
		return result;
	}

	shptr<class ScrollPhysics> /*var-nullable*/ ListWheelScrollView::physics() {
		auto m = ManagedCall("ListWheelScrollView", "physics");
		m.put("this", this);
		shptr<class ScrollPhysics> result;
		m.call(result);
		return result;
	}

	double /*var-non-null*/ ListWheelScrollView::diameterRatio() {
		auto m = ManagedCall("ListWheelScrollView", "diameterRatio");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	double /*var-non-null*/ ListWheelScrollView::perspective() {
		auto m = ManagedCall("ListWheelScrollView", "perspective");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	double /*var-non-null*/ ListWheelScrollView::offAxisFraction() {
		auto m = ManagedCall("ListWheelScrollView", "offAxisFraction");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	bool /*var-non-null*/ ListWheelScrollView::useMagnifier() {
		auto m = ManagedCall("ListWheelScrollView", "useMagnifier");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	double /*var-non-null*/ ListWheelScrollView::magnification() {
		auto m = ManagedCall("ListWheelScrollView", "magnification");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	double /*var-non-null*/ ListWheelScrollView::overAndUnderCenterOpacity() {
		auto m = ManagedCall("ListWheelScrollView", "overAndUnderCenterOpacity");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	double /*var-non-null*/ ListWheelScrollView::itemExtent() {
		auto m = ManagedCall("ListWheelScrollView", "itemExtent");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	double /*var-non-null*/ ListWheelScrollView::squeeze() {
		auto m = ManagedCall("ListWheelScrollView", "squeeze");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	bool /*var-non-null*/ ListWheelScrollView::renderChildrenOutsideViewport() {
		auto m = ManagedCall("ListWheelScrollView", "renderChildrenOutsideViewport");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ListWheelChildDelegate> /*var-non-null*/ ListWheelScrollView::childDelegate() {
		auto m = ManagedCall("ListWheelScrollView", "childDelegate");
		m.put("this", this);
		shptr<class ListWheelChildDelegate> result;
		m.check(m.call(result));
		return result;
	}

	Clip /*var-non-null*/ ListWheelScrollView::clipBehavior() {
		auto m = ManagedCall("ListWheelScrollView", "clipBehavior");
		m.put("this", this);
		Clip result;
		m.check(m.call(result));
		return result;
	}

	stdop<stdstr> /*var-nullable*/ ListWheelScrollView::restorationId() {
		auto m = ManagedCall("ListWheelScrollView", "restorationId");
		m.put("this", this);
		stdop<stdstr> result;
		m.call(result);
		return result;
	}

	shptr<class ScrollBehavior> /*var-nullable*/ ListWheelScrollView::scrollBehavior() {
		auto m = ManagedCall("ListWheelScrollView", "scrollBehavior");
		m.put("this", this);
		shptr<class ScrollBehavior> result;
		m.call(result);
		return result;
	}

	shptr<class ListWheelScrollView> /*non-null*/ ListWheelScrollView::ctorMain(_ctorMain p) {
		auto m = ManagedCall("ListWheelScrollView", "ListWheelScrollView");
		m.put("key", p.key);
		m.put("controller", p.controller);
		m.put("physics", p.physics);
		m.put("diameterRatio", p.diameterRatio);
		m.put("perspective", p.perspective);
		m.put("offAxisFraction", p.offAxisFraction);
		m.put("useMagnifier", p.useMagnifier);
		m.put("magnification", p.magnification);
		m.put("overAndUnderCenterOpacity", p.overAndUnderCenterOpacity);
		m.put("itemExtent", p.itemExtent);
		m.put("squeeze", p.squeeze);
		m.put("onSelectedItemChanged", p.onSelectedItemChanged);
		m.put("renderChildrenOutsideViewport", p.renderChildrenOutsideViewport);
		m.put("clipBehavior", p.clipBehavior);
		m.put("restorationId", p.restorationId);
		m.put("scrollBehavior", p.scrollBehavior);
		m.put("children", p.children);
		shptr<class ListWheelScrollView> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class ThemeData> /*var-non-null*/ Theme::data() {
		auto m = ManagedCall("Theme", "data");
		m.put("this", this);
		shptr<class ThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Widget> /*var-non-null*/ Theme::child() {
		auto m = ManagedCall("Theme", "child");
		m.put("this", this);
		shptr<class Widget> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ThemeData> /*non-null*/ Theme::of(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("Theme", "of");
		m.put("context", context, true);
		shptr<class ThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Theme> /*non-null*/ Theme::ctorMain(_ctorMain p) {
		auto m = ManagedCall("Theme", "Theme");
		m.put("key", p.key);
		m.put("data", p.data, true);
		m.put("child", p.child, true);
		shptr<class Theme> result;
		m.check(m.call(result, true));
		return result;
	}

	bool /*var-non-null*/ ThemeData::applyElevationOverlayColor() {
		auto m = ManagedCall("ThemeData", "applyElevationOverlayColor");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class NoDefaultCupertinoThemeData> /*var-nullable*/ ThemeData::cupertinoOverrideTheme() {
		auto m = ManagedCall("ThemeData", "cupertinoOverrideTheme");
		m.put("this", this);
		shptr<class NoDefaultCupertinoThemeData> result;
		m.call(result);
		return result;
	}

	shptr<class InputDecorationTheme> /*var-non-null*/ ThemeData::inputDecorationTheme() {
		auto m = ManagedCall("ThemeData", "inputDecorationTheme");
		m.put("this", this);
		shptr<class InputDecorationTheme> result;
		m.check(m.call(result));
		return result;
	}

	MaterialTapTargetSize /*var-non-null*/ ThemeData::materialTapTargetSize() {
		auto m = ManagedCall("ThemeData", "materialTapTargetSize");
		m.put("this", this);
		MaterialTapTargetSize result;
		m.check(m.call(result));
		return result;
	}

	shptr<class PageTransitionsTheme> /*var-non-null*/ ThemeData::pageTransitionsTheme() {
		auto m = ManagedCall("ThemeData", "pageTransitionsTheme");
		m.put("this", this);
		shptr<class PageTransitionsTheme> result;
		m.check(m.call(result));
		return result;
	}

	TargetPlatform /*var-non-null*/ ThemeData::platform() {
		auto m = ManagedCall("ThemeData", "platform");
		m.put("this", this);
		TargetPlatform result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ScrollbarThemeData> /*var-non-null*/ ThemeData::scrollbarTheme() {
		auto m = ManagedCall("ThemeData", "scrollbarTheme");
		m.put("this", this);
		shptr<class ScrollbarThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class InteractiveInkFeatureFactory> /*var-non-null*/ ThemeData::splashFactory() {
		auto m = ManagedCall("ThemeData", "splashFactory");
		m.put("this", this);
		shptr<class InteractiveInkFeatureFactory> result;
		m.check(m.call(result));
		return result;
	}

	bool /*var-non-null*/ ThemeData::useMaterial3() {
		auto m = ManagedCall("ThemeData", "useMaterial3");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class VisualDensity> /*var-non-null*/ ThemeData::visualDensity() {
		auto m = ManagedCall("ThemeData", "visualDensity");
		m.put("this", this);
		shptr<class VisualDensity> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*var-non-null*/ ThemeData::canvasColor() {
		auto m = ManagedCall("ThemeData", "canvasColor");
		m.put("this", this);
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*var-non-null*/ ThemeData::cardColor() {
		auto m = ManagedCall("ThemeData", "cardColor");
		m.put("this", this);
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ColorScheme> /*var-non-null*/ ThemeData::colorScheme() {
		auto m = ManagedCall("ThemeData", "colorScheme");
		m.put("this", this);
		shptr<class ColorScheme> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*var-non-null*/ ThemeData::dialogBackgroundColor() {
		auto m = ManagedCall("ThemeData", "dialogBackgroundColor");
		m.put("this", this);
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*var-non-null*/ ThemeData::disabledColor() {
		auto m = ManagedCall("ThemeData", "disabledColor");
		m.put("this", this);
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*var-non-null*/ ThemeData::dividerColor() {
		auto m = ManagedCall("ThemeData", "dividerColor");
		m.put("this", this);
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*var-non-null*/ ThemeData::focusColor() {
		auto m = ManagedCall("ThemeData", "focusColor");
		m.put("this", this);
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*var-non-null*/ ThemeData::highlightColor() {
		auto m = ManagedCall("ThemeData", "highlightColor");
		m.put("this", this);
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*var-non-null*/ ThemeData::hintColor() {
		auto m = ManagedCall("ThemeData", "hintColor");
		m.put("this", this);
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*var-non-null*/ ThemeData::hoverColor() {
		auto m = ManagedCall("ThemeData", "hoverColor");
		m.put("this", this);
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*var-non-null*/ ThemeData::indicatorColor() {
		auto m = ManagedCall("ThemeData", "indicatorColor");
		m.put("this", this);
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*var-non-null*/ ThemeData::primaryColor() {
		auto m = ManagedCall("ThemeData", "primaryColor");
		m.put("this", this);
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*var-non-null*/ ThemeData::primaryColorDark() {
		auto m = ManagedCall("ThemeData", "primaryColorDark");
		m.put("this", this);
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*var-non-null*/ ThemeData::primaryColorLight() {
		auto m = ManagedCall("ThemeData", "primaryColorLight");
		m.put("this", this);
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*var-non-null*/ ThemeData::scaffoldBackgroundColor() {
		auto m = ManagedCall("ThemeData", "scaffoldBackgroundColor");
		m.put("this", this);
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*var-non-null*/ ThemeData::secondaryHeaderColor() {
		auto m = ManagedCall("ThemeData", "secondaryHeaderColor");
		m.put("this", this);
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*var-non-null*/ ThemeData::shadowColor() {
		auto m = ManagedCall("ThemeData", "shadowColor");
		m.put("this", this);
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*var-non-null*/ ThemeData::splashColor() {
		auto m = ManagedCall("ThemeData", "splashColor");
		m.put("this", this);
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*var-non-null*/ ThemeData::unselectedWidgetColor() {
		auto m = ManagedCall("ThemeData", "unselectedWidgetColor");
		m.put("this", this);
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class IconThemeData> /*var-non-null*/ ThemeData::iconTheme() {
		auto m = ManagedCall("ThemeData", "iconTheme");
		m.put("this", this);
		shptr<class IconThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class IconThemeData> /*var-non-null*/ ThemeData::primaryIconTheme() {
		auto m = ManagedCall("ThemeData", "primaryIconTheme");
		m.put("this", this);
		shptr<class IconThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class TextTheme> /*var-non-null*/ ThemeData::primaryTextTheme() {
		auto m = ManagedCall("ThemeData", "primaryTextTheme");
		m.put("this", this);
		shptr<class TextTheme> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class TextTheme> /*var-non-null*/ ThemeData::textTheme() {
		auto m = ManagedCall("ThemeData", "textTheme");
		m.put("this", this);
		shptr<class TextTheme> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Typography> /*var-non-null*/ ThemeData::typography() {
		auto m = ManagedCall("ThemeData", "typography");
		m.put("this", this);
		shptr<class Typography> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ActionIconThemeData> /*var-nullable*/ ThemeData::actionIconTheme() {
		auto m = ManagedCall("ThemeData", "actionIconTheme");
		m.put("this", this);
		shptr<class ActionIconThemeData> result;
		m.call(result);
		return result;
	}

	shptr<class AppBarTheme> /*var-non-null*/ ThemeData::appBarTheme() {
		auto m = ManagedCall("ThemeData", "appBarTheme");
		m.put("this", this);
		shptr<class AppBarTheme> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class BadgeThemeData> /*var-non-null*/ ThemeData::badgeTheme() {
		auto m = ManagedCall("ThemeData", "badgeTheme");
		m.put("this", this);
		shptr<class BadgeThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class MaterialBannerThemeData> /*var-non-null*/ ThemeData::bannerTheme() {
		auto m = ManagedCall("ThemeData", "bannerTheme");
		m.put("this", this);
		shptr<class MaterialBannerThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class BottomAppBarTheme> /*var-non-null*/ ThemeData::bottomAppBarTheme() {
		auto m = ManagedCall("ThemeData", "bottomAppBarTheme");
		m.put("this", this);
		shptr<class BottomAppBarTheme> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class BottomNavigationBarThemeData> /*var-non-null*/ ThemeData::bottomNavigationBarTheme() {
		auto m = ManagedCall("ThemeData", "bottomNavigationBarTheme");
		m.put("this", this);
		shptr<class BottomNavigationBarThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class BottomSheetThemeData> /*var-non-null*/ ThemeData::bottomSheetTheme() {
		auto m = ManagedCall("ThemeData", "bottomSheetTheme");
		m.put("this", this);
		shptr<class BottomSheetThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ButtonBarThemeData> /*var-non-null*/ ThemeData::buttonBarTheme() {
		auto m = ManagedCall("ThemeData", "buttonBarTheme");
		m.put("this", this);
		shptr<class ButtonBarThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ButtonThemeData> /*var-non-null*/ ThemeData::buttonTheme() {
		auto m = ManagedCall("ThemeData", "buttonTheme");
		m.put("this", this);
		shptr<class ButtonThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class CardTheme> /*var-non-null*/ ThemeData::cardTheme() {
		auto m = ManagedCall("ThemeData", "cardTheme");
		m.put("this", this);
		shptr<class CardTheme> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class CheckboxThemeData> /*var-non-null*/ ThemeData::checkboxTheme() {
		auto m = ManagedCall("ThemeData", "checkboxTheme");
		m.put("this", this);
		shptr<class CheckboxThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ChipThemeData> /*var-non-null*/ ThemeData::chipTheme() {
		auto m = ManagedCall("ThemeData", "chipTheme");
		m.put("this", this);
		shptr<class ChipThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class DataTableThemeData> /*var-non-null*/ ThemeData::dataTableTheme() {
		auto m = ManagedCall("ThemeData", "dataTableTheme");
		m.put("this", this);
		shptr<class DataTableThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class DatePickerThemeData> /*var-non-null*/ ThemeData::datePickerTheme() {
		auto m = ManagedCall("ThemeData", "datePickerTheme");
		m.put("this", this);
		shptr<class DatePickerThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class DialogTheme> /*var-non-null*/ ThemeData::dialogTheme() {
		auto m = ManagedCall("ThemeData", "dialogTheme");
		m.put("this", this);
		shptr<class DialogTheme> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class DividerThemeData> /*var-non-null*/ ThemeData::dividerTheme() {
		auto m = ManagedCall("ThemeData", "dividerTheme");
		m.put("this", this);
		shptr<class DividerThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class DrawerThemeData> /*var-non-null*/ ThemeData::drawerTheme() {
		auto m = ManagedCall("ThemeData", "drawerTheme");
		m.put("this", this);
		shptr<class DrawerThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class DropdownMenuThemeData> /*var-non-null*/ ThemeData::dropdownMenuTheme() {
		auto m = ManagedCall("ThemeData", "dropdownMenuTheme");
		m.put("this", this);
		shptr<class DropdownMenuThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ElevatedButtonThemeData> /*var-non-null*/ ThemeData::elevatedButtonTheme() {
		auto m = ManagedCall("ThemeData", "elevatedButtonTheme");
		m.put("this", this);
		shptr<class ElevatedButtonThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ExpansionTileThemeData> /*var-non-null*/ ThemeData::expansionTileTheme() {
		auto m = ManagedCall("ThemeData", "expansionTileTheme");
		m.put("this", this);
		shptr<class ExpansionTileThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class FilledButtonThemeData> /*var-non-null*/ ThemeData::filledButtonTheme() {
		auto m = ManagedCall("ThemeData", "filledButtonTheme");
		m.put("this", this);
		shptr<class FilledButtonThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class FloatingActionButtonThemeData> /*var-non-null*/ ThemeData::floatingActionButtonTheme() {
		auto m = ManagedCall("ThemeData", "floatingActionButtonTheme");
		m.put("this", this);
		shptr<class FloatingActionButtonThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class IconButtonThemeData> /*var-non-null*/ ThemeData::iconButtonTheme() {
		auto m = ManagedCall("ThemeData", "iconButtonTheme");
		m.put("this", this);
		shptr<class IconButtonThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ListTileThemeData> /*var-non-null*/ ThemeData::listTileTheme() {
		auto m = ManagedCall("ThemeData", "listTileTheme");
		m.put("this", this);
		shptr<class ListTileThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class MenuBarThemeData> /*var-non-null*/ ThemeData::menuBarTheme() {
		auto m = ManagedCall("ThemeData", "menuBarTheme");
		m.put("this", this);
		shptr<class MenuBarThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class MenuButtonThemeData> /*var-non-null*/ ThemeData::menuButtonTheme() {
		auto m = ManagedCall("ThemeData", "menuButtonTheme");
		m.put("this", this);
		shptr<class MenuButtonThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class MenuThemeData> /*var-non-null*/ ThemeData::menuTheme() {
		auto m = ManagedCall("ThemeData", "menuTheme");
		m.put("this", this);
		shptr<class MenuThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class NavigationBarThemeData> /*var-non-null*/ ThemeData::navigationBarTheme() {
		auto m = ManagedCall("ThemeData", "navigationBarTheme");
		m.put("this", this);
		shptr<class NavigationBarThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class NavigationDrawerThemeData> /*var-non-null*/ ThemeData::navigationDrawerTheme() {
		auto m = ManagedCall("ThemeData", "navigationDrawerTheme");
		m.put("this", this);
		shptr<class NavigationDrawerThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class NavigationRailThemeData> /*var-non-null*/ ThemeData::navigationRailTheme() {
		auto m = ManagedCall("ThemeData", "navigationRailTheme");
		m.put("this", this);
		shptr<class NavigationRailThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class OutlinedButtonThemeData> /*var-non-null*/ ThemeData::outlinedButtonTheme() {
		auto m = ManagedCall("ThemeData", "outlinedButtonTheme");
		m.put("this", this);
		shptr<class OutlinedButtonThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class PopupMenuThemeData> /*var-non-null*/ ThemeData::popupMenuTheme() {
		auto m = ManagedCall("ThemeData", "popupMenuTheme");
		m.put("this", this);
		shptr<class PopupMenuThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ProgressIndicatorThemeData> /*var-non-null*/ ThemeData::progressIndicatorTheme() {
		auto m = ManagedCall("ThemeData", "progressIndicatorTheme");
		m.put("this", this);
		shptr<class ProgressIndicatorThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class RadioThemeData> /*var-non-null*/ ThemeData::radioTheme() {
		auto m = ManagedCall("ThemeData", "radioTheme");
		m.put("this", this);
		shptr<class RadioThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class SearchBarThemeData> /*var-non-null*/ ThemeData::searchBarTheme() {
		auto m = ManagedCall("ThemeData", "searchBarTheme");
		m.put("this", this);
		shptr<class SearchBarThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class SearchViewThemeData> /*var-non-null*/ ThemeData::searchViewTheme() {
		auto m = ManagedCall("ThemeData", "searchViewTheme");
		m.put("this", this);
		shptr<class SearchViewThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class SegmentedButtonThemeData> /*var-non-null*/ ThemeData::segmentedButtonTheme() {
		auto m = ManagedCall("ThemeData", "segmentedButtonTheme");
		m.put("this", this);
		shptr<class SegmentedButtonThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class SliderThemeData> /*var-non-null*/ ThemeData::sliderTheme() {
		auto m = ManagedCall("ThemeData", "sliderTheme");
		m.put("this", this);
		shptr<class SliderThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class SnackBarThemeData> /*var-non-null*/ ThemeData::snackBarTheme() {
		auto m = ManagedCall("ThemeData", "snackBarTheme");
		m.put("this", this);
		shptr<class SnackBarThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class SwitchThemeData> /*var-non-null*/ ThemeData::switchTheme() {
		auto m = ManagedCall("ThemeData", "switchTheme");
		m.put("this", this);
		shptr<class SwitchThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class TabBarTheme> /*var-non-null*/ ThemeData::tabBarTheme() {
		auto m = ManagedCall("ThemeData", "tabBarTheme");
		m.put("this", this);
		shptr<class TabBarTheme> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class TextButtonThemeData> /*var-non-null*/ ThemeData::textButtonTheme() {
		auto m = ManagedCall("ThemeData", "textButtonTheme");
		m.put("this", this);
		shptr<class TextButtonThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class TextSelectionThemeData> /*var-non-null*/ ThemeData::textSelectionTheme() {
		auto m = ManagedCall("ThemeData", "textSelectionTheme");
		m.put("this", this);
		shptr<class TextSelectionThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class TimePickerThemeData> /*var-non-null*/ ThemeData::timePickerTheme() {
		auto m = ManagedCall("ThemeData", "timePickerTheme");
		m.put("this", this);
		shptr<class TimePickerThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ToggleButtonsThemeData> /*var-non-null*/ ThemeData::toggleButtonsTheme() {
		auto m = ManagedCall("ThemeData", "toggleButtonsTheme");
		m.put("this", this);
		shptr<class ToggleButtonsThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class TooltipThemeData> /*var-non-null*/ ThemeData::tooltipTheme() {
		auto m = ManagedCall("ThemeData", "tooltipTheme");
		m.put("this", this);
		shptr<class TooltipThemeData> result;
		m.check(m.call(result));
		return result;
	}

	stdop<AndroidOverscrollIndicator> /*var-nullable*/ ThemeData::androidOverscrollIndicator() {
		auto m = ManagedCall("ThemeData", "androidOverscrollIndicator");
		m.put("this", this);
		stdop<AndroidOverscrollIndicator> result;
		m.call(result);
		return result;
	}

	Brightness /*get-non-null*/ ThemeData::brightness() {
		auto m = ManagedCall("ThemeData", "brightness");
		m.put("this", this);
		Brightness result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*get-non-null*/ ThemeData::bottomAppBarColor() {
		auto m = ManagedCall("ThemeData", "bottomAppBarColor");
		m.put("this", this);
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*get-non-null*/ ThemeData::selectedRowColor() {
		auto m = ManagedCall("ThemeData", "selectedRowColor");
		m.put("this", this);
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*get-non-null*/ ThemeData::errorColor() {
		auto m = ManagedCall("ThemeData", "errorColor");
		m.put("this", this);
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*get-non-null*/ ThemeData::backgroundColor() {
		auto m = ManagedCall("ThemeData", "backgroundColor");
		m.put("this", this);
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*get-non-null*/ ThemeData::toggleableActiveColor() {
		auto m = ManagedCall("ThemeData", "toggleableActiveColor");
		m.put("this", this);
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ThemeData> /*non-null*/ ThemeData::copyWith(_copyWith p) {
		auto m = ManagedCall("ThemeData", "copyWith");
		m.put("this", this);
		m.put("applyElevationOverlayColor", p.applyElevationOverlayColor);
		m.put("cupertinoOverrideTheme", p.cupertinoOverrideTheme);
//		m.put("extensions", p.extensions);
		m.put("inputDecorationTheme", p.inputDecorationTheme);
		m.put("materialTapTargetSize", p.materialTapTargetSize);
		m.put("pageTransitionsTheme", p.pageTransitionsTheme);
		m.put("platform", p.platform);
		m.put("scrollbarTheme", p.scrollbarTheme);
		m.put("splashFactory", p.splashFactory);
		m.put("useMaterial3", p.useMaterial3);
		m.put("visualDensity", p.visualDensity);
		m.put("brightness", p.brightness);
		m.put("canvasColor", p.canvasColor);
		m.put("cardColor", p.cardColor);
		m.put("colorScheme", p.colorScheme);
		m.put("dialogBackgroundColor", p.dialogBackgroundColor);
		m.put("disabledColor", p.disabledColor);
		m.put("dividerColor", p.dividerColor);
		m.put("focusColor", p.focusColor);
		m.put("highlightColor", p.highlightColor);
		m.put("hintColor", p.hintColor);
		m.put("hoverColor", p.hoverColor);
		m.put("indicatorColor", p.indicatorColor);
		m.put("primaryColor", p.primaryColor);
		m.put("primaryColorDark", p.primaryColorDark);
		m.put("primaryColorLight", p.primaryColorLight);
		m.put("scaffoldBackgroundColor", p.scaffoldBackgroundColor);
		m.put("secondaryHeaderColor", p.secondaryHeaderColor);
		m.put("shadowColor", p.shadowColor);
		m.put("splashColor", p.splashColor);
		m.put("unselectedWidgetColor", p.unselectedWidgetColor);
		m.put("iconTheme", p.iconTheme);
		m.put("primaryIconTheme", p.primaryIconTheme);
		m.put("primaryTextTheme", p.primaryTextTheme);
		m.put("textTheme", p.textTheme);
		m.put("typography", p.typography);
		m.put("actionIconTheme", p.actionIconTheme);
		m.put("appBarTheme", p.appBarTheme);
		m.put("badgeTheme", p.badgeTheme);
		m.put("bannerTheme", p.bannerTheme);
		m.put("bottomAppBarTheme", p.bottomAppBarTheme);
		m.put("bottomNavigationBarTheme", p.bottomNavigationBarTheme);
		m.put("bottomSheetTheme", p.bottomSheetTheme);
		m.put("buttonBarTheme", p.buttonBarTheme);
		m.put("buttonTheme", p.buttonTheme);
		m.put("cardTheme", p.cardTheme);
		m.put("checkboxTheme", p.checkboxTheme);
		m.put("chipTheme", p.chipTheme);
		m.put("dataTableTheme", p.dataTableTheme);
		m.put("datePickerTheme", p.datePickerTheme);
		m.put("dialogTheme", p.dialogTheme);
		m.put("dividerTheme", p.dividerTheme);
		m.put("drawerTheme", p.drawerTheme);
		m.put("dropdownMenuTheme", p.dropdownMenuTheme);
		m.put("elevatedButtonTheme", p.elevatedButtonTheme);
		m.put("expansionTileTheme", p.expansionTileTheme);
		m.put("filledButtonTheme", p.filledButtonTheme);
		m.put("floatingActionButtonTheme", p.floatingActionButtonTheme);
		m.put("iconButtonTheme", p.iconButtonTheme);
		m.put("listTileTheme", p.listTileTheme);
		m.put("menuBarTheme", p.menuBarTheme);
		m.put("menuButtonTheme", p.menuButtonTheme);
		m.put("menuTheme", p.menuTheme);
		m.put("navigationBarTheme", p.navigationBarTheme);
		m.put("navigationDrawerTheme", p.navigationDrawerTheme);
		m.put("navigationRailTheme", p.navigationRailTheme);
		m.put("outlinedButtonTheme", p.outlinedButtonTheme);
		m.put("popupMenuTheme", p.popupMenuTheme);
		m.put("progressIndicatorTheme", p.progressIndicatorTheme);
		m.put("radioTheme", p.radioTheme);
		m.put("searchBarTheme", p.searchBarTheme);
		m.put("searchViewTheme", p.searchViewTheme);
		m.put("segmentedButtonTheme", p.segmentedButtonTheme);
		m.put("sliderTheme", p.sliderTheme);
		m.put("snackBarTheme", p.snackBarTheme);
		m.put("switchTheme", p.switchTheme);
		m.put("tabBarTheme", p.tabBarTheme);
		m.put("textButtonTheme", p.textButtonTheme);
		m.put("textSelectionTheme", p.textSelectionTheme);
		m.put("timePickerTheme", p.timePickerTheme);
		m.put("toggleButtonsTheme", p.toggleButtonsTheme);
		m.put("tooltipTheme", p.tooltipTheme);
		m.put("androidOverscrollIndicator", p.androidOverscrollIndicator);
		m.put("toggleableActiveColor", p.toggleableActiveColor);
		m.put("selectedRowColor", p.selectedRowColor);
		m.put("errorColor", p.errorColor);
		m.put("backgroundColor", p.backgroundColor);
		m.put("bottomAppBarColor", p.bottomAppBarColor);
		shptr<class ThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ThemeData> /*non-null*/ ThemeData::localize(/*non-null*/ shptr<class ThemeData> baseTheme, /*non-null*/ shptr<class TextTheme> localTextGeometry) {
		auto m = ManagedCall("ThemeData", "localize");
		m.put("baseTheme", baseTheme, true);
		m.put("localTextGeometry", localTextGeometry, true);
		shptr<class ThemeData> result;
		m.check(m.call(result));
		return result;
	}

	Brightness /*non-null*/ ThemeData::estimateBrightnessForColor(/*non-null*/ shptr<class Color> color) {
		auto m = ManagedCall("ThemeData", "estimateBrightnessForColor");
		m.put("color", color, true);
		Brightness result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ThemeData> /*non-null*/ ThemeData::lerp(/*non-null*/ shptr<class ThemeData> a, /*non-null*/ shptr<class ThemeData> b, /*non-null*/ double t) {
		auto m = ManagedCall("ThemeData", "lerp");
		m.put("a", a, true);
		m.put("b", b, true);
		m.put("t", t);
		shptr<class ThemeData> result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ ThemeData::equals(/*non-null*/ shptr<class ObjBase> other) {
		auto m = ManagedCall("ThemeData", "==");
		m.put("this", this);
		m.put("other", other, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ThemeData> /*non-null*/ ThemeData::raw(_raw p) {
		auto m = ManagedCall("ThemeData", "raw");
		m.put("applyElevationOverlayColor", p.applyElevationOverlayColor);
		m.put("cupertinoOverrideTheme", p.cupertinoOverrideTheme);
//		m.put("extensions", p.extensions, true);
		m.put("inputDecorationTheme", p.inputDecorationTheme, true);
		m.put("materialTapTargetSize", p.materialTapTargetSize);
		m.put("pageTransitionsTheme", p.pageTransitionsTheme, true);
		m.put("platform", p.platform);
		m.put("scrollbarTheme", p.scrollbarTheme, true);
		m.put("splashFactory", p.splashFactory, true);
		m.put("useMaterial3", p.useMaterial3);
		m.put("visualDensity", p.visualDensity, true);
		m.put("canvasColor", p.canvasColor, true);
		m.put("cardColor", p.cardColor, true);
		m.put("colorScheme", p.colorScheme, true);
		m.put("dialogBackgroundColor", p.dialogBackgroundColor, true);
		m.put("disabledColor", p.disabledColor, true);
		m.put("dividerColor", p.dividerColor, true);
		m.put("focusColor", p.focusColor, true);
		m.put("highlightColor", p.highlightColor, true);
		m.put("hintColor", p.hintColor, true);
		m.put("hoverColor", p.hoverColor, true);
		m.put("indicatorColor", p.indicatorColor, true);
		m.put("primaryColor", p.primaryColor, true);
		m.put("primaryColorDark", p.primaryColorDark, true);
		m.put("primaryColorLight", p.primaryColorLight, true);
		m.put("scaffoldBackgroundColor", p.scaffoldBackgroundColor, true);
		m.put("secondaryHeaderColor", p.secondaryHeaderColor, true);
		m.put("shadowColor", p.shadowColor, true);
		m.put("splashColor", p.splashColor, true);
		m.put("unselectedWidgetColor", p.unselectedWidgetColor, true);
		m.put("iconTheme", p.iconTheme, true);
		m.put("primaryIconTheme", p.primaryIconTheme, true);
		m.put("primaryTextTheme", p.primaryTextTheme, true);
		m.put("textTheme", p.textTheme, true);
		m.put("typography", p.typography, true);
		m.put("actionIconTheme", p.actionIconTheme);
		m.put("appBarTheme", p.appBarTheme, true);
		m.put("badgeTheme", p.badgeTheme, true);
		m.put("bannerTheme", p.bannerTheme, true);
		m.put("bottomAppBarTheme", p.bottomAppBarTheme, true);
		m.put("bottomNavigationBarTheme", p.bottomNavigationBarTheme, true);
		m.put("bottomSheetTheme", p.bottomSheetTheme, true);
		m.put("buttonBarTheme", p.buttonBarTheme, true);
		m.put("buttonTheme", p.buttonTheme, true);
		m.put("cardTheme", p.cardTheme, true);
		m.put("checkboxTheme", p.checkboxTheme, true);
		m.put("chipTheme", p.chipTheme, true);
		m.put("dataTableTheme", p.dataTableTheme, true);
		m.put("datePickerTheme", p.datePickerTheme, true);
		m.put("dialogTheme", p.dialogTheme, true);
		m.put("dividerTheme", p.dividerTheme, true);
		m.put("drawerTheme", p.drawerTheme, true);
		m.put("dropdownMenuTheme", p.dropdownMenuTheme, true);
		m.put("elevatedButtonTheme", p.elevatedButtonTheme, true);
		m.put("expansionTileTheme", p.expansionTileTheme, true);
		m.put("filledButtonTheme", p.filledButtonTheme, true);
		m.put("floatingActionButtonTheme", p.floatingActionButtonTheme, true);
		m.put("iconButtonTheme", p.iconButtonTheme, true);
		m.put("listTileTheme", p.listTileTheme, true);
		m.put("menuBarTheme", p.menuBarTheme, true);
		m.put("menuButtonTheme", p.menuButtonTheme, true);
		m.put("menuTheme", p.menuTheme, true);
		m.put("navigationBarTheme", p.navigationBarTheme, true);
		m.put("navigationDrawerTheme", p.navigationDrawerTheme, true);
		m.put("navigationRailTheme", p.navigationRailTheme, true);
		m.put("outlinedButtonTheme", p.outlinedButtonTheme, true);
		m.put("popupMenuTheme", p.popupMenuTheme, true);
		m.put("progressIndicatorTheme", p.progressIndicatorTheme, true);
		m.put("radioTheme", p.radioTheme, true);
		m.put("searchBarTheme", p.searchBarTheme, true);
		m.put("searchViewTheme", p.searchViewTheme, true);
		m.put("segmentedButtonTheme", p.segmentedButtonTheme, true);
		m.put("sliderTheme", p.sliderTheme, true);
		m.put("snackBarTheme", p.snackBarTheme, true);
		m.put("switchTheme", p.switchTheme, true);
		m.put("tabBarTheme", p.tabBarTheme, true);
		m.put("textButtonTheme", p.textButtonTheme, true);
		m.put("textSelectionTheme", p.textSelectionTheme, true);
		m.put("timePickerTheme", p.timePickerTheme, true);
		m.put("toggleButtonsTheme", p.toggleButtonsTheme, true);
		m.put("tooltipTheme", p.tooltipTheme, true);
		m.put("androidOverscrollIndicator", p.androidOverscrollIndicator);
		m.put("toggleableActiveColor", p.toggleableActiveColor);
		m.put("selectedRowColor", p.selectedRowColor);
		m.put("errorColor", p.errorColor);
		m.put("backgroundColor", p.backgroundColor);
		m.put("bottomAppBarColor", p.bottomAppBarColor);
		shptr<class ThemeData> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class ThemeData> /*non-null*/ ThemeData::ctorMain(_ctorMain p) {
		auto m = ManagedCall("ThemeData", "ThemeData");
		m.put("applyElevationOverlayColor", p.applyElevationOverlayColor);
		m.put("cupertinoOverrideTheme", p.cupertinoOverrideTheme);
//		m.put("extensions", p.extensions);
		m.put("inputDecorationTheme", p.inputDecorationTheme);
		m.put("materialTapTargetSize", p.materialTapTargetSize);
		m.put("pageTransitionsTheme", p.pageTransitionsTheme);
		m.put("platform", p.platform);
		m.put("scrollbarTheme", p.scrollbarTheme);
		m.put("splashFactory", p.splashFactory);
		m.put("useMaterial3", p.useMaterial3);
		m.put("visualDensity", p.visualDensity);
		m.put("brightness", p.brightness);
		m.put("canvasColor", p.canvasColor);
		m.put("cardColor", p.cardColor);
		m.put("colorScheme", p.colorScheme);
		m.put("colorSchemeSeed", p.colorSchemeSeed);
		m.put("dialogBackgroundColor", p.dialogBackgroundColor);
		m.put("disabledColor", p.disabledColor);
		m.put("dividerColor", p.dividerColor);
		m.put("focusColor", p.focusColor);
		m.put("highlightColor", p.highlightColor);
		m.put("hintColor", p.hintColor);
		m.put("hoverColor", p.hoverColor);
		m.put("indicatorColor", p.indicatorColor);
		m.put("primaryColor", p.primaryColor);
		m.put("primaryColorDark", p.primaryColorDark);
		m.put("primaryColorLight", p.primaryColorLight);
		m.put("primarySwatch", p.primarySwatch);
		m.put("scaffoldBackgroundColor", p.scaffoldBackgroundColor);
		m.put("secondaryHeaderColor", p.secondaryHeaderColor);
		m.put("shadowColor", p.shadowColor);
		m.put("splashColor", p.splashColor);
		m.put("unselectedWidgetColor", p.unselectedWidgetColor);
		m.put("fontFamily", p.fontFamily);
		m.put("fontFamilyFallback", p.fontFamilyFallback);
		m.put("package", p.package);
		m.put("iconTheme", p.iconTheme);
		m.put("primaryIconTheme", p.primaryIconTheme);
		m.put("primaryTextTheme", p.primaryTextTheme);
		m.put("textTheme", p.textTheme);
		m.put("typography", p.typography);
		m.put("actionIconTheme", p.actionIconTheme);
		m.put("appBarTheme", p.appBarTheme);
		m.put("badgeTheme", p.badgeTheme);
		m.put("bannerTheme", p.bannerTheme);
		m.put("bottomAppBarTheme", p.bottomAppBarTheme);
		m.put("bottomNavigationBarTheme", p.bottomNavigationBarTheme);
		m.put("bottomSheetTheme", p.bottomSheetTheme);
		m.put("buttonBarTheme", p.buttonBarTheme);
		m.put("buttonTheme", p.buttonTheme);
		m.put("cardTheme", p.cardTheme);
		m.put("checkboxTheme", p.checkboxTheme);
		m.put("chipTheme", p.chipTheme);
		m.put("dataTableTheme", p.dataTableTheme);
		m.put("datePickerTheme", p.datePickerTheme);
		m.put("dialogTheme", p.dialogTheme);
		m.put("dividerTheme", p.dividerTheme);
		m.put("drawerTheme", p.drawerTheme);
		m.put("dropdownMenuTheme", p.dropdownMenuTheme);
		m.put("elevatedButtonTheme", p.elevatedButtonTheme);
		m.put("expansionTileTheme", p.expansionTileTheme);
		m.put("filledButtonTheme", p.filledButtonTheme);
		m.put("floatingActionButtonTheme", p.floatingActionButtonTheme);
		m.put("iconButtonTheme", p.iconButtonTheme);
		m.put("listTileTheme", p.listTileTheme);
		m.put("menuBarTheme", p.menuBarTheme);
		m.put("menuButtonTheme", p.menuButtonTheme);
		m.put("menuTheme", p.menuTheme);
		m.put("navigationBarTheme", p.navigationBarTheme);
		m.put("navigationDrawerTheme", p.navigationDrawerTheme);
		m.put("navigationRailTheme", p.navigationRailTheme);
		m.put("outlinedButtonTheme", p.outlinedButtonTheme);
		m.put("popupMenuTheme", p.popupMenuTheme);
		m.put("progressIndicatorTheme", p.progressIndicatorTheme);
		m.put("radioTheme", p.radioTheme);
		m.put("searchBarTheme", p.searchBarTheme);
		m.put("searchViewTheme", p.searchViewTheme);
		m.put("segmentedButtonTheme", p.segmentedButtonTheme);
		m.put("sliderTheme", p.sliderTheme);
		m.put("snackBarTheme", p.snackBarTheme);
		m.put("switchTheme", p.switchTheme);
		m.put("tabBarTheme", p.tabBarTheme);
		m.put("textButtonTheme", p.textButtonTheme);
		m.put("textSelectionTheme", p.textSelectionTheme);
		m.put("timePickerTheme", p.timePickerTheme);
		m.put("toggleButtonsTheme", p.toggleButtonsTheme);
		m.put("tooltipTheme", p.tooltipTheme);
		m.put("androidOverscrollIndicator", p.androidOverscrollIndicator);
		m.put("toggleableActiveColor", p.toggleableActiveColor);
		m.put("selectedRowColor", p.selectedRowColor);
		m.put("errorColor", p.errorColor);
		m.put("backgroundColor", p.backgroundColor);
		m.put("bottomAppBarColor", p.bottomAppBarColor);
		shptr<class ThemeData> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class ThemeData> /*non-null*/ ThemeData::from(_from p) {
		auto m = ManagedCall("ThemeData", "from");
		m.put("colorScheme", p.colorScheme, true);
		m.put("textTheme", p.textTheme);
		m.put("useMaterial3", p.useMaterial3);
		shptr<class ThemeData> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class ThemeData> /*non-null*/ ThemeData::light(_light p) {
		auto m = ManagedCall("ThemeData", "light");
		m.put("useMaterial3", p.useMaterial3);
		shptr<class ThemeData> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class ThemeData> /*non-null*/ ThemeData::dark(_dark p) {
		auto m = ManagedCall("ThemeData", "dark");
		m.put("useMaterial3", p.useMaterial3);
		shptr<class ThemeData> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class ThemeData> /*non-null*/ ThemeData::fallback(_fallback p) {
		auto m = ManagedCall("ThemeData", "fallback");
		m.put("useMaterial3", p.useMaterial3);
		shptr<class ThemeData> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class ActionIconThemeData> /*var-non-null*/ ActionIconTheme::data() {
		auto m = ManagedCall("ActionIconTheme", "data");
		m.put("this", this);
		shptr<class ActionIconThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ActionIconThemeData> /*nullable*/ ActionIconTheme::of(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("ActionIconTheme", "of");
		m.put("context", context, true);
		shptr<class ActionIconThemeData> result;
		m.call(result);
		return result;
	}

	shptr<class Widget> /*non-null*/ ActionIconTheme::wrap(/*non-null*/ shptr<class BuildContext> context, /*non-null*/ shptr<class Widget> child) {
		auto m = ManagedCall("ActionIconTheme", "wrap");
		m.put("this", this);
		m.put("context", context, true);
		m.put("child", child, true);
		shptr<class Widget> result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ ActionIconTheme::updateShouldNotify(/*non-null*/ shptr<class ActionIconTheme> oldWidget) {
		auto m = ManagedCall("ActionIconTheme", "updateShouldNotify");
		m.put("this", this);
		m.put("oldWidget", oldWidget, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ActionIconTheme> /*non-null*/ ActionIconTheme::ctorMain(_ctorMain p) {
		auto m = ManagedCall("ActionIconTheme", "ActionIconTheme");
		m.put("key", p.key);
		m.put("data", p.data, true);
		m.put("child", p.child, true);
		shptr<class ActionIconTheme> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class ActionIconThemeData> /*non-null*/ ActionIconThemeData::copyWith(_copyWith p) {
		auto m = ManagedCall("ActionIconThemeData", "copyWith");
		m.put("this", this);
		m.put("backButtonIconBuilder", p.backButtonIconBuilder);
		m.put("closeButtonIconBuilder", p.closeButtonIconBuilder);
		m.put("drawerButtonIconBuilder", p.drawerButtonIconBuilder);
		m.put("endDrawerButtonIconBuilder", p.endDrawerButtonIconBuilder);
		shptr<class ActionIconThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ActionIconThemeData> /*nullable*/ ActionIconThemeData::lerp(/*nullable*/ shptr<class ActionIconThemeData> a, /*nullable*/ shptr<class ActionIconThemeData> b, /*non-null*/ double t) {
		auto m = ManagedCall("ActionIconThemeData", "lerp");
		m.put("a", a);
		m.put("b", b);
		m.put("t", t);
		shptr<class ActionIconThemeData> result;
		m.call(result);
		return result;
	}

	bool /*non-null*/ ActionIconThemeData::equals(/*non-null*/ shptr<class ObjBase> other) {
		auto m = ManagedCall("ActionIconThemeData", "==");
		m.put("this", this);
		m.put("other", other, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ActionIconThemeData> /*non-null*/ ActionIconThemeData::ctorMain(_ctorMain p) {
		auto m = ManagedCall("ActionIconThemeData", "ActionIconThemeData");
		m.put("backButtonIconBuilder", p.backButtonIconBuilder);
		m.put("closeButtonIconBuilder", p.closeButtonIconBuilder);
		m.put("drawerButtonIconBuilder", p.drawerButtonIconBuilder);
		m.put("endDrawerButtonIconBuilder", p.endDrawerButtonIconBuilder);
		shptr<class ActionIconThemeData> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class BadgeThemeData> /*var-non-null*/ BadgeTheme::data() {
		auto m = ManagedCall("BadgeTheme", "data");
		m.put("this", this);
		shptr<class BadgeThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class BadgeThemeData> /*non-null*/ BadgeTheme::of(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("BadgeTheme", "of");
		m.put("context", context, true);
		shptr<class BadgeThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Widget> /*non-null*/ BadgeTheme::wrap(/*non-null*/ shptr<class BuildContext> context, /*non-null*/ shptr<class Widget> child) {
		auto m = ManagedCall("BadgeTheme", "wrap");
		m.put("this", this);
		m.put("context", context, true);
		m.put("child", child, true);
		shptr<class Widget> result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ BadgeTheme::updateShouldNotify(/*non-null*/ shptr<class BadgeTheme> oldWidget) {
		auto m = ManagedCall("BadgeTheme", "updateShouldNotify");
		m.put("this", this);
		m.put("oldWidget", oldWidget, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class BadgeTheme> /*non-null*/ BadgeTheme::ctorMain(_ctorMain p) {
		auto m = ManagedCall("BadgeTheme", "BadgeTheme");
		m.put("key", p.key);
		m.put("data", p.data, true);
		m.put("child", p.child, true);
		shptr<class BadgeTheme> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Color> /*var-nullable*/ BadgeThemeData::backgroundColor() {
		auto m = ManagedCall("BadgeThemeData", "backgroundColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ BadgeThemeData::textColor() {
		auto m = ManagedCall("BadgeThemeData", "textColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ BadgeThemeData::smallSize() {
		auto m = ManagedCall("BadgeThemeData", "smallSize");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ BadgeThemeData::largeSize() {
		auto m = ManagedCall("BadgeThemeData", "largeSize");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	shptr<class TextStyle> /*var-nullable*/ BadgeThemeData::textStyle() {
		auto m = ManagedCall("BadgeThemeData", "textStyle");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.call(result);
		return result;
	}

	shptr<class EdgeInsetsGeometry> /*var-nullable*/ BadgeThemeData::padding() {
		auto m = ManagedCall("BadgeThemeData", "padding");
		m.put("this", this);
		shptr<class EdgeInsetsGeometry> result;
		m.call(result);
		return result;
	}

	shptr<class AlignmentGeometry> /*var-nullable*/ BadgeThemeData::alignment() {
		auto m = ManagedCall("BadgeThemeData", "alignment");
		m.put("this", this);
		shptr<class AlignmentGeometry> result;
		m.call(result);
		return result;
	}

	shptr<class Offset> /*var-nullable*/ BadgeThemeData::offset() {
		auto m = ManagedCall("BadgeThemeData", "offset");
		m.put("this", this);
		shptr<class Offset> result;
		m.call(result);
		return result;
	}

	shptr<class BadgeThemeData> /*non-null*/ BadgeThemeData::copyWith(_copyWith p) {
		auto m = ManagedCall("BadgeThemeData", "copyWith");
		m.put("this", this);
		m.put("backgroundColor", p.backgroundColor);
		m.put("textColor", p.textColor);
		m.put("smallSize", p.smallSize);
		m.put("largeSize", p.largeSize);
		m.put("textStyle", p.textStyle);
		m.put("padding", p.padding);
		m.put("alignment", p.alignment);
		m.put("offset", p.offset);
		shptr<class BadgeThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class BadgeThemeData> /*non-null*/ BadgeThemeData::lerp(/*nullable*/ shptr<class BadgeThemeData> a, /*nullable*/ shptr<class BadgeThemeData> b, /*non-null*/ double t) {
		auto m = ManagedCall("BadgeThemeData", "lerp");
		m.put("a", a);
		m.put("b", b);
		m.put("t", t);
		shptr<class BadgeThemeData> result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ BadgeThemeData::equals(/*non-null*/ shptr<class ObjBase> other) {
		auto m = ManagedCall("BadgeThemeData", "==");
		m.put("this", this);
		m.put("other", other, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class BadgeThemeData> /*non-null*/ BadgeThemeData::ctorMain(_ctorMain p) {
		auto m = ManagedCall("BadgeThemeData", "BadgeThemeData");
		m.put("backgroundColor", p.backgroundColor);
		m.put("textColor", p.textColor);
		m.put("smallSize", p.smallSize);
		m.put("largeSize", p.largeSize);
		m.put("textStyle", p.textStyle);
		m.put("padding", p.padding);
		m.put("alignment", p.alignment);
		m.put("offset", p.offset);
		shptr<class BadgeThemeData> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Color> /*var-nullable*/ MaterialBannerThemeData::backgroundColor() {
		auto m = ManagedCall("MaterialBannerThemeData", "backgroundColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ MaterialBannerThemeData::surfaceTintColor() {
		auto m = ManagedCall("MaterialBannerThemeData", "surfaceTintColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ MaterialBannerThemeData::shadowColor() {
		auto m = ManagedCall("MaterialBannerThemeData", "shadowColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ MaterialBannerThemeData::dividerColor() {
		auto m = ManagedCall("MaterialBannerThemeData", "dividerColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class TextStyle> /*var-nullable*/ MaterialBannerThemeData::contentTextStyle() {
		auto m = ManagedCall("MaterialBannerThemeData", "contentTextStyle");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ MaterialBannerThemeData::elevation() {
		auto m = ManagedCall("MaterialBannerThemeData", "elevation");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	shptr<class EdgeInsetsGeometry> /*var-nullable*/ MaterialBannerThemeData::padding() {
		auto m = ManagedCall("MaterialBannerThemeData", "padding");
		m.put("this", this);
		shptr<class EdgeInsetsGeometry> result;
		m.call(result);
		return result;
	}

	shptr<class EdgeInsetsGeometry> /*var-nullable*/ MaterialBannerThemeData::leadingPadding() {
		auto m = ManagedCall("MaterialBannerThemeData", "leadingPadding");
		m.put("this", this);
		shptr<class EdgeInsetsGeometry> result;
		m.call(result);
		return result;
	}

	shptr<class MaterialBannerThemeData> /*non-null*/ MaterialBannerThemeData::copyWith(_copyWith p) {
		auto m = ManagedCall("MaterialBannerThemeData", "copyWith");
		m.put("this", this);
		m.put("backgroundColor", p.backgroundColor);
		m.put("surfaceTintColor", p.surfaceTintColor);
		m.put("shadowColor", p.shadowColor);
		m.put("dividerColor", p.dividerColor);
		m.put("contentTextStyle", p.contentTextStyle);
		m.put("elevation", p.elevation);
		m.put("padding", p.padding);
		m.put("leadingPadding", p.leadingPadding);
		shptr<class MaterialBannerThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class MaterialBannerThemeData> /*non-null*/ MaterialBannerThemeData::lerp(/*nullable*/ shptr<class MaterialBannerThemeData> a, /*nullable*/ shptr<class MaterialBannerThemeData> b, /*non-null*/ double t) {
		auto m = ManagedCall("MaterialBannerThemeData", "lerp");
		m.put("a", a);
		m.put("b", b);
		m.put("t", t);
		shptr<class MaterialBannerThemeData> result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ MaterialBannerThemeData::equals(/*non-null*/ shptr<class ObjBase> other) {
		auto m = ManagedCall("MaterialBannerThemeData", "==");
		m.put("this", this);
		m.put("other", other, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class MaterialBannerThemeData> /*non-null*/ MaterialBannerThemeData::ctorMain(_ctorMain p) {
		auto m = ManagedCall("MaterialBannerThemeData", "MaterialBannerThemeData");
		m.put("backgroundColor", p.backgroundColor);
		m.put("surfaceTintColor", p.surfaceTintColor);
		m.put("shadowColor", p.shadowColor);
		m.put("dividerColor", p.dividerColor);
		m.put("contentTextStyle", p.contentTextStyle);
		m.put("elevation", p.elevation);
		m.put("padding", p.padding);
		m.put("leadingPadding", p.leadingPadding);
		shptr<class MaterialBannerThemeData> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class MaterialBannerThemeData> /*var-nullable*/ MaterialBannerTheme::data() {
		auto m = ManagedCall("MaterialBannerTheme", "data");
		m.put("this", this);
		shptr<class MaterialBannerThemeData> result;
		m.call(result);
		return result;
	}

	shptr<class MaterialBannerThemeData> /*non-null*/ MaterialBannerTheme::of(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("MaterialBannerTheme", "of");
		m.put("context", context, true);
		shptr<class MaterialBannerThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Widget> /*non-null*/ MaterialBannerTheme::wrap(/*non-null*/ shptr<class BuildContext> context, /*non-null*/ shptr<class Widget> child) {
		auto m = ManagedCall("MaterialBannerTheme", "wrap");
		m.put("this", this);
		m.put("context", context, true);
		m.put("child", child, true);
		shptr<class Widget> result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ MaterialBannerTheme::updateShouldNotify(/*non-null*/ shptr<class MaterialBannerTheme> oldWidget) {
		auto m = ManagedCall("MaterialBannerTheme", "updateShouldNotify");
		m.put("this", this);
		m.put("oldWidget", oldWidget, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class MaterialBannerTheme> /*non-null*/ MaterialBannerTheme::ctorMain(_ctorMain p) {
		auto m = ManagedCall("MaterialBannerTheme", "MaterialBannerTheme");
		m.put("key", p.key);
		m.put("data", p.data);
		m.put("child", p.child, true);
		shptr<class MaterialBannerTheme> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class BottomNavigationBarThemeData> /*var-non-null*/ BottomNavigationBarTheme::data() {
		auto m = ManagedCall("BottomNavigationBarTheme", "data");
		m.put("this", this);
		shptr<class BottomNavigationBarThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class BottomNavigationBarThemeData> /*non-null*/ BottomNavigationBarTheme::of(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("BottomNavigationBarTheme", "of");
		m.put("context", context, true);
		shptr<class BottomNavigationBarThemeData> result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ BottomNavigationBarTheme::updateShouldNotify(/*non-null*/ shptr<class BottomNavigationBarTheme> oldWidget) {
		auto m = ManagedCall("BottomNavigationBarTheme", "updateShouldNotify");
		m.put("this", this);
		m.put("oldWidget", oldWidget, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class BottomNavigationBarTheme> /*non-null*/ BottomNavigationBarTheme::ctorMain(_ctorMain p) {
		auto m = ManagedCall("BottomNavigationBarTheme", "BottomNavigationBarTheme");
		m.put("key", p.key);
		m.put("data", p.data, true);
		m.put("child", p.child, true);
		shptr<class BottomNavigationBarTheme> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Color> /*var-nullable*/ BottomNavigationBarThemeData::backgroundColor() {
		auto m = ManagedCall("BottomNavigationBarThemeData", "backgroundColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ BottomNavigationBarThemeData::elevation() {
		auto m = ManagedCall("BottomNavigationBarThemeData", "elevation");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	shptr<class IconThemeData> /*var-nullable*/ BottomNavigationBarThemeData::selectedIconTheme() {
		auto m = ManagedCall("BottomNavigationBarThemeData", "selectedIconTheme");
		m.put("this", this);
		shptr<class IconThemeData> result;
		m.call(result);
		return result;
	}

	shptr<class IconThemeData> /*var-nullable*/ BottomNavigationBarThemeData::unselectedIconTheme() {
		auto m = ManagedCall("BottomNavigationBarThemeData", "unselectedIconTheme");
		m.put("this", this);
		shptr<class IconThemeData> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ BottomNavigationBarThemeData::selectedItemColor() {
		auto m = ManagedCall("BottomNavigationBarThemeData", "selectedItemColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ BottomNavigationBarThemeData::unselectedItemColor() {
		auto m = ManagedCall("BottomNavigationBarThemeData", "unselectedItemColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class TextStyle> /*var-nullable*/ BottomNavigationBarThemeData::selectedLabelStyle() {
		auto m = ManagedCall("BottomNavigationBarThemeData", "selectedLabelStyle");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.call(result);
		return result;
	}

	shptr<class TextStyle> /*var-nullable*/ BottomNavigationBarThemeData::unselectedLabelStyle() {
		auto m = ManagedCall("BottomNavigationBarThemeData", "unselectedLabelStyle");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.call(result);
		return result;
	}

	stdop<bool> /*var-nullable*/ BottomNavigationBarThemeData::showSelectedLabels() {
		auto m = ManagedCall("BottomNavigationBarThemeData", "showSelectedLabels");
		m.put("this", this);
		stdop<bool> result;
		m.call(result);
		return result;
	}

	stdop<bool> /*var-nullable*/ BottomNavigationBarThemeData::showUnselectedLabels() {
		auto m = ManagedCall("BottomNavigationBarThemeData", "showUnselectedLabels");
		m.put("this", this);
		stdop<bool> result;
		m.call(result);
		return result;
	}

	stdop<BottomNavigationBarType> /*var-nullable*/ BottomNavigationBarThemeData::type() {
		auto m = ManagedCall("BottomNavigationBarThemeData", "type");
		m.put("this", this);
		stdop<BottomNavigationBarType> result;
		m.call(result);
		return result;
	}

	stdop<bool> /*var-nullable*/ BottomNavigationBarThemeData::enableFeedback() {
		auto m = ManagedCall("BottomNavigationBarThemeData", "enableFeedback");
		m.put("this", this);
		stdop<bool> result;
		m.call(result);
		return result;
	}

	stdop<BottomNavigationBarLandscapeLayout> /*var-nullable*/ BottomNavigationBarThemeData::landscapeLayout() {
		auto m = ManagedCall("BottomNavigationBarThemeData", "landscapeLayout");
		m.put("this", this);
		stdop<BottomNavigationBarLandscapeLayout> result;
		m.call(result);
		return result;
	}

	shptr<class BottomNavigationBarThemeData> /*non-null*/ BottomNavigationBarThemeData::copyWith(_copyWith p) {
		auto m = ManagedCall("BottomNavigationBarThemeData", "copyWith");
		m.put("this", this);
		m.put("backgroundColor", p.backgroundColor);
		m.put("elevation", p.elevation);
		m.put("selectedIconTheme", p.selectedIconTheme);
		m.put("unselectedIconTheme", p.unselectedIconTheme);
		m.put("selectedItemColor", p.selectedItemColor);
		m.put("unselectedItemColor", p.unselectedItemColor);
		m.put("selectedLabelStyle", p.selectedLabelStyle);
		m.put("unselectedLabelStyle", p.unselectedLabelStyle);
		m.put("showSelectedLabels", p.showSelectedLabels);
		m.put("showUnselectedLabels", p.showUnselectedLabels);
		m.put("type", p.type);
		m.put("enableFeedback", p.enableFeedback);
		m.put("landscapeLayout", p.landscapeLayout);
		m.put("mouseCursor", p.mouseCursor);
		shptr<class BottomNavigationBarThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class BottomNavigationBarThemeData> /*non-null*/ BottomNavigationBarThemeData::lerp(/*nullable*/ shptr<class BottomNavigationBarThemeData> a, /*nullable*/ shptr<class BottomNavigationBarThemeData> b, /*non-null*/ double t) {
		auto m = ManagedCall("BottomNavigationBarThemeData", "lerp");
		m.put("a", a);
		m.put("b", b);
		m.put("t", t);
		shptr<class BottomNavigationBarThemeData> result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ BottomNavigationBarThemeData::equals(/*non-null*/ shptr<class ObjBase> other) {
		auto m = ManagedCall("BottomNavigationBarThemeData", "==");
		m.put("this", this);
		m.put("other", other, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class BottomNavigationBarThemeData> /*non-null*/ BottomNavigationBarThemeData::ctorMain(_ctorMain p) {
		auto m = ManagedCall("BottomNavigationBarThemeData", "BottomNavigationBarThemeData");
		m.put("backgroundColor", p.backgroundColor);
		m.put("elevation", p.elevation);
		m.put("selectedIconTheme", p.selectedIconTheme);
		m.put("unselectedIconTheme", p.unselectedIconTheme);
		m.put("selectedItemColor", p.selectedItemColor);
		m.put("unselectedItemColor", p.unselectedItemColor);
		m.put("selectedLabelStyle", p.selectedLabelStyle);
		m.put("unselectedLabelStyle", p.unselectedLabelStyle);
		m.put("showSelectedLabels", p.showSelectedLabels);
		m.put("showUnselectedLabels", p.showUnselectedLabels);
		m.put("type", p.type);
		m.put("enableFeedback", p.enableFeedback);
		m.put("landscapeLayout", p.landscapeLayout);
		m.put("mouseCursor", p.mouseCursor);
		shptr<class BottomNavigationBarThemeData> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Color> /*var-nullable*/ BottomSheetThemeData::backgroundColor() {
		auto m = ManagedCall("BottomSheetThemeData", "backgroundColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ BottomSheetThemeData::surfaceTintColor() {
		auto m = ManagedCall("BottomSheetThemeData", "surfaceTintColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ BottomSheetThemeData::elevation() {
		auto m = ManagedCall("BottomSheetThemeData", "elevation");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ BottomSheetThemeData::modalBackgroundColor() {
		auto m = ManagedCall("BottomSheetThemeData", "modalBackgroundColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ BottomSheetThemeData::modalBarrierColor() {
		auto m = ManagedCall("BottomSheetThemeData", "modalBarrierColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ BottomSheetThemeData::shadowColor() {
		auto m = ManagedCall("BottomSheetThemeData", "shadowColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ BottomSheetThemeData::modalElevation() {
		auto m = ManagedCall("BottomSheetThemeData", "modalElevation");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	shptr<class ShapeBorder> /*var-nullable*/ BottomSheetThemeData::shape() {
		auto m = ManagedCall("BottomSheetThemeData", "shape");
		m.put("this", this);
		shptr<class ShapeBorder> result;
		m.call(result);
		return result;
	}

	stdop<bool> /*var-nullable*/ BottomSheetThemeData::showDragHandle() {
		auto m = ManagedCall("BottomSheetThemeData", "showDragHandle");
		m.put("this", this);
		stdop<bool> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ BottomSheetThemeData::dragHandleColor() {
		auto m = ManagedCall("BottomSheetThemeData", "dragHandleColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Size> /*var-nullable*/ BottomSheetThemeData::dragHandleSize() {
		auto m = ManagedCall("BottomSheetThemeData", "dragHandleSize");
		m.put("this", this);
		shptr<class Size> result;
		m.call(result);
		return result;
	}

	stdop<Clip> /*var-nullable*/ BottomSheetThemeData::clipBehavior() {
		auto m = ManagedCall("BottomSheetThemeData", "clipBehavior");
		m.put("this", this);
		stdop<Clip> result;
		m.call(result);
		return result;
	}

	shptr<class BoxConstraints> /*var-nullable*/ BottomSheetThemeData::constraints() {
		auto m = ManagedCall("BottomSheetThemeData", "constraints");
		m.put("this", this);
		shptr<class BoxConstraints> result;
		m.call(result);
		return result;
	}

	shptr<class BottomSheetThemeData> /*non-null*/ BottomSheetThemeData::copyWith(_copyWith p) {
		auto m = ManagedCall("BottomSheetThemeData", "copyWith");
		m.put("this", this);
		m.put("backgroundColor", p.backgroundColor);
		m.put("surfaceTintColor", p.surfaceTintColor);
		m.put("elevation", p.elevation);
		m.put("modalBackgroundColor", p.modalBackgroundColor);
		m.put("modalBarrierColor", p.modalBarrierColor);
		m.put("shadowColor", p.shadowColor);
		m.put("modalElevation", p.modalElevation);
		m.put("shape", p.shape);
		m.put("showDragHandle", p.showDragHandle);
		m.put("dragHandleColor", p.dragHandleColor);
		m.put("dragHandleSize", p.dragHandleSize);
		m.put("clipBehavior", p.clipBehavior);
		m.put("constraints", p.constraints);
		shptr<class BottomSheetThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class BottomSheetThemeData> /*nullable*/ BottomSheetThemeData::lerp(/*nullable*/ shptr<class BottomSheetThemeData> a, /*nullable*/ shptr<class BottomSheetThemeData> b, /*non-null*/ double t) {
		auto m = ManagedCall("BottomSheetThemeData", "lerp");
		m.put("a", a);
		m.put("b", b);
		m.put("t", t);
		shptr<class BottomSheetThemeData> result;
		m.call(result);
		return result;
	}

	bool /*non-null*/ BottomSheetThemeData::equals(/*non-null*/ shptr<class ObjBase> other) {
		auto m = ManagedCall("BottomSheetThemeData", "==");
		m.put("this", this);
		m.put("other", other, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class BottomSheetThemeData> /*non-null*/ BottomSheetThemeData::ctorMain(_ctorMain p) {
		auto m = ManagedCall("BottomSheetThemeData", "BottomSheetThemeData");
		m.put("backgroundColor", p.backgroundColor);
		m.put("surfaceTintColor", p.surfaceTintColor);
		m.put("elevation", p.elevation);
		m.put("modalBackgroundColor", p.modalBackgroundColor);
		m.put("modalBarrierColor", p.modalBarrierColor);
		m.put("shadowColor", p.shadowColor);
		m.put("modalElevation", p.modalElevation);
		m.put("shape", p.shape);
		m.put("showDragHandle", p.showDragHandle);
		m.put("dragHandleColor", p.dragHandleColor);
		m.put("dragHandleSize", p.dragHandleSize);
		m.put("clipBehavior", p.clipBehavior);
		m.put("constraints", p.constraints);
		shptr<class BottomSheetThemeData> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class ButtonBarThemeData> /*var-non-null*/ ButtonBarTheme::data() {
		auto m = ManagedCall("ButtonBarTheme", "data");
		m.put("this", this);
		shptr<class ButtonBarThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ButtonBarThemeData> /*non-null*/ ButtonBarTheme::of(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("ButtonBarTheme", "of");
		m.put("context", context, true);
		shptr<class ButtonBarThemeData> result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ ButtonBarTheme::updateShouldNotify(/*non-null*/ shptr<class ButtonBarTheme> oldWidget) {
		auto m = ManagedCall("ButtonBarTheme", "updateShouldNotify");
		m.put("this", this);
		m.put("oldWidget", oldWidget, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ButtonBarTheme> /*non-null*/ ButtonBarTheme::ctorMain(_ctorMain p) {
		auto m = ManagedCall("ButtonBarTheme", "ButtonBarTheme");
		m.put("key", p.key);
		m.put("data", p.data, true);
		m.put("child", p.child, true);
		shptr<class ButtonBarTheme> result;
		m.check(m.call(result, true));
		return result;
	}

	stdop<MainAxisAlignment> /*var-nullable*/ ButtonBarThemeData::alignment() {
		auto m = ManagedCall("ButtonBarThemeData", "alignment");
		m.put("this", this);
		stdop<MainAxisAlignment> result;
		m.call(result);
		return result;
	}

	stdop<MainAxisSize> /*var-nullable*/ ButtonBarThemeData::mainAxisSize() {
		auto m = ManagedCall("ButtonBarThemeData", "mainAxisSize");
		m.put("this", this);
		stdop<MainAxisSize> result;
		m.call(result);
		return result;
	}

	stdop<ButtonTextTheme> /*var-nullable*/ ButtonBarThemeData::buttonTextTheme() {
		auto m = ManagedCall("ButtonBarThemeData", "buttonTextTheme");
		m.put("this", this);
		stdop<ButtonTextTheme> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ ButtonBarThemeData::buttonMinWidth() {
		auto m = ManagedCall("ButtonBarThemeData", "buttonMinWidth");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ ButtonBarThemeData::buttonHeight() {
		auto m = ManagedCall("ButtonBarThemeData", "buttonHeight");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	shptr<class EdgeInsetsGeometry> /*var-nullable*/ ButtonBarThemeData::buttonPadding() {
		auto m = ManagedCall("ButtonBarThemeData", "buttonPadding");
		m.put("this", this);
		shptr<class EdgeInsetsGeometry> result;
		m.call(result);
		return result;
	}

	stdop<bool> /*var-nullable*/ ButtonBarThemeData::buttonAlignedDropdown() {
		auto m = ManagedCall("ButtonBarThemeData", "buttonAlignedDropdown");
		m.put("this", this);
		stdop<bool> result;
		m.call(result);
		return result;
	}

	stdop<ButtonBarLayoutBehavior> /*var-nullable*/ ButtonBarThemeData::layoutBehavior() {
		auto m = ManagedCall("ButtonBarThemeData", "layoutBehavior");
		m.put("this", this);
		stdop<ButtonBarLayoutBehavior> result;
		m.call(result);
		return result;
	}

	stdop<VerticalDirection> /*var-nullable*/ ButtonBarThemeData::overflowDirection() {
		auto m = ManagedCall("ButtonBarThemeData", "overflowDirection");
		m.put("this", this);
		stdop<VerticalDirection> result;
		m.call(result);
		return result;
	}

	shptr<class ButtonBarThemeData> /*non-null*/ ButtonBarThemeData::copyWith(_copyWith p) {
		auto m = ManagedCall("ButtonBarThemeData", "copyWith");
		m.put("this", this);
		m.put("alignment", p.alignment);
		m.put("mainAxisSize", p.mainAxisSize);
		m.put("buttonTextTheme", p.buttonTextTheme);
		m.put("buttonMinWidth", p.buttonMinWidth);
		m.put("buttonHeight", p.buttonHeight);
		m.put("buttonPadding", p.buttonPadding);
		m.put("buttonAlignedDropdown", p.buttonAlignedDropdown);
		m.put("layoutBehavior", p.layoutBehavior);
		m.put("overflowDirection", p.overflowDirection);
		shptr<class ButtonBarThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ButtonBarThemeData> /*nullable*/ ButtonBarThemeData::lerp(/*nullable*/ shptr<class ButtonBarThemeData> a, /*nullable*/ shptr<class ButtonBarThemeData> b, /*non-null*/ double t) {
		auto m = ManagedCall("ButtonBarThemeData", "lerp");
		m.put("a", a);
		m.put("b", b);
		m.put("t", t);
		shptr<class ButtonBarThemeData> result;
		m.call(result);
		return result;
	}

	bool /*non-null*/ ButtonBarThemeData::equals(/*non-null*/ shptr<class ObjBase> other) {
		auto m = ManagedCall("ButtonBarThemeData", "==");
		m.put("this", this);
		m.put("other", other, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ButtonBarThemeData> /*non-null*/ ButtonBarThemeData::ctorMain(_ctorMain p) {
		auto m = ManagedCall("ButtonBarThemeData", "ButtonBarThemeData");
		m.put("alignment", p.alignment);
		m.put("mainAxisSize", p.mainAxisSize);
		m.put("buttonTextTheme", p.buttonTextTheme);
		m.put("buttonMinWidth", p.buttonMinWidth);
		m.put("buttonHeight", p.buttonHeight);
		m.put("buttonPadding", p.buttonPadding);
		m.put("buttonAlignedDropdown", p.buttonAlignedDropdown);
		m.put("layoutBehavior", p.layoutBehavior);
		m.put("overflowDirection", p.overflowDirection);
		shptr<class ButtonBarThemeData> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class ButtonThemeData> /*var-non-null*/ ButtonTheme::data() {
		auto m = ManagedCall("ButtonTheme", "data");
		m.put("this", this);
		shptr<class ButtonThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ButtonThemeData> /*non-null*/ ButtonTheme::of(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("ButtonTheme", "of");
		m.put("context", context, true);
		shptr<class ButtonThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Widget> /*non-null*/ ButtonTheme::wrap(/*non-null*/ shptr<class BuildContext> context, /*non-null*/ shptr<class Widget> child) {
		auto m = ManagedCall("ButtonTheme", "wrap");
		m.put("this", this);
		m.put("context", context, true);
		m.put("child", child, true);
		shptr<class Widget> result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ ButtonTheme::updateShouldNotify(/*non-null*/ shptr<class ButtonTheme> oldWidget) {
		auto m = ManagedCall("ButtonTheme", "updateShouldNotify");
		m.put("this", this);
		m.put("oldWidget", oldWidget, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ButtonTheme> /*non-null*/ ButtonTheme::ctorMain(_ctorMain p) {
		auto m = ManagedCall("ButtonTheme", "ButtonTheme");
		m.put("key", p.key);
		m.put("textTheme", p.textTheme);
		m.put("layoutBehavior", p.layoutBehavior);
		m.put("minWidth", p.minWidth);
		m.put("height", p.height);
		m.put("padding", p.padding);
		m.put("shape", p.shape);
		m.put("alignedDropdown", p.alignedDropdown);
		m.put("buttonColor", p.buttonColor);
		m.put("disabledColor", p.disabledColor);
		m.put("focusColor", p.focusColor);
		m.put("hoverColor", p.hoverColor);
		m.put("highlightColor", p.highlightColor);
		m.put("splashColor", p.splashColor);
		m.put("colorScheme", p.colorScheme);
		m.put("materialTapTargetSize", p.materialTapTargetSize);
		m.put("child", p.child, true);
		shptr<class ButtonTheme> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class ButtonTheme> /*non-null*/ ButtonTheme::fromButtonThemeData(_fromButtonThemeData p) {
		auto m = ManagedCall("ButtonTheme", "fromButtonThemeData");
		m.put("key", p.key);
		m.put("data", p.data, true);
		m.put("child", p.child, true);
		shptr<class ButtonTheme> result;
		m.check(m.call(result, true));
		return result;
	}

	double /*var-non-null*/ ButtonThemeData::minWidth() {
		auto m = ManagedCall("ButtonThemeData", "minWidth");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	double /*var-non-null*/ ButtonThemeData::height() {
		auto m = ManagedCall("ButtonThemeData", "height");
		m.put("this", this);
		double result;
		m.check(m.call(result));
		return result;
	}

	ButtonTextTheme /*var-non-null*/ ButtonThemeData::textTheme() {
		auto m = ManagedCall("ButtonThemeData", "textTheme");
		m.put("this", this);
		ButtonTextTheme result;
		m.check(m.call(result));
		return result;
	}

	ButtonBarLayoutBehavior /*var-non-null*/ ButtonThemeData::layoutBehavior() {
		auto m = ManagedCall("ButtonThemeData", "layoutBehavior");
		m.put("this", this);
		ButtonBarLayoutBehavior result;
		m.check(m.call(result));
		return result;
	}

	bool /*var-non-null*/ ButtonThemeData::alignedDropdown() {
		auto m = ManagedCall("ButtonThemeData", "alignedDropdown");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ColorScheme> /*var-nullable*/ ButtonThemeData::colorScheme() {
		auto m = ManagedCall("ButtonThemeData", "colorScheme");
		m.put("this", this);
		shptr<class ColorScheme> result;
		m.call(result);
		return result;
	}

	shptr<class BoxConstraints> /*get-non-null*/ ButtonThemeData::constraints() {
		auto m = ManagedCall("ButtonThemeData", "constraints");
		m.put("this", this);
		shptr<class BoxConstraints> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class EdgeInsetsGeometry> /*get-non-null*/ ButtonThemeData::padding() {
		auto m = ManagedCall("ButtonThemeData", "padding");
		m.put("this", this);
		shptr<class EdgeInsetsGeometry> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ShapeBorder> /*get-non-null*/ ButtonThemeData::shape() {
		auto m = ManagedCall("ButtonThemeData", "shape");
		m.put("this", this);
		shptr<class ShapeBorder> result;
		m.check(m.call(result));
		return result;
	}

	Brightness /*non-null*/ ButtonThemeData::getBrightness(/*non-null*/ shptr<class MaterialButton> button) {
		auto m = ManagedCall("ButtonThemeData", "getBrightness");
		m.put("this", this);
		m.put("button", button, true);
		Brightness result;
		m.check(m.call(result));
		return result;
	}

	ButtonTextTheme /*non-null*/ ButtonThemeData::getTextTheme(/*non-null*/ shptr<class MaterialButton> button) {
		auto m = ManagedCall("ButtonThemeData", "getTextTheme");
		m.put("this", this);
		m.put("button", button, true);
		ButtonTextTheme result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*non-null*/ ButtonThemeData::getDisabledTextColor(/*non-null*/ shptr<class MaterialButton> button) {
		auto m = ManagedCall("ButtonThemeData", "getDisabledTextColor");
		m.put("this", this);
		m.put("button", button, true);
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*non-null*/ ButtonThemeData::getDisabledFillColor(/*non-null*/ shptr<class MaterialButton> button) {
		auto m = ManagedCall("ButtonThemeData", "getDisabledFillColor");
		m.put("this", this);
		m.put("button", button, true);
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*nullable*/ ButtonThemeData::getFillColor(/*non-null*/ shptr<class MaterialButton> button) {
		auto m = ManagedCall("ButtonThemeData", "getFillColor");
		m.put("this", this);
		m.put("button", button, true);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*non-null*/ ButtonThemeData::getTextColor(/*non-null*/ shptr<class MaterialButton> button) {
		auto m = ManagedCall("ButtonThemeData", "getTextColor");
		m.put("this", this);
		m.put("button", button, true);
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*non-null*/ ButtonThemeData::getSplashColor(/*non-null*/ shptr<class MaterialButton> button) {
		auto m = ManagedCall("ButtonThemeData", "getSplashColor");
		m.put("this", this);
		m.put("button", button, true);
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*non-null*/ ButtonThemeData::getFocusColor(/*non-null*/ shptr<class MaterialButton> button) {
		auto m = ManagedCall("ButtonThemeData", "getFocusColor");
		m.put("this", this);
		m.put("button", button, true);
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*non-null*/ ButtonThemeData::getHoverColor(/*non-null*/ shptr<class MaterialButton> button) {
		auto m = ManagedCall("ButtonThemeData", "getHoverColor");
		m.put("this", this);
		m.put("button", button, true);
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*non-null*/ ButtonThemeData::getHighlightColor(/*non-null*/ shptr<class MaterialButton> button) {
		auto m = ManagedCall("ButtonThemeData", "getHighlightColor");
		m.put("this", this);
		m.put("button", button, true);
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	double /*non-null*/ ButtonThemeData::getElevation(/*non-null*/ shptr<class MaterialButton> button) {
		auto m = ManagedCall("ButtonThemeData", "getElevation");
		m.put("this", this);
		m.put("button", button, true);
		double result;
		m.check(m.call(result));
		return result;
	}

	double /*non-null*/ ButtonThemeData::getFocusElevation(/*non-null*/ shptr<class MaterialButton> button) {
		auto m = ManagedCall("ButtonThemeData", "getFocusElevation");
		m.put("this", this);
		m.put("button", button, true);
		double result;
		m.check(m.call(result));
		return result;
	}

	double /*non-null*/ ButtonThemeData::getHoverElevation(/*non-null*/ shptr<class MaterialButton> button) {
		auto m = ManagedCall("ButtonThemeData", "getHoverElevation");
		m.put("this", this);
		m.put("button", button, true);
		double result;
		m.check(m.call(result));
		return result;
	}

	double /*non-null*/ ButtonThemeData::getHighlightElevation(/*non-null*/ shptr<class MaterialButton> button) {
		auto m = ManagedCall("ButtonThemeData", "getHighlightElevation");
		m.put("this", this);
		m.put("button", button, true);
		double result;
		m.check(m.call(result));
		return result;
	}

	double /*non-null*/ ButtonThemeData::getDisabledElevation(/*non-null*/ shptr<class MaterialButton> button) {
		auto m = ManagedCall("ButtonThemeData", "getDisabledElevation");
		m.put("this", this);
		m.put("button", button, true);
		double result;
		m.check(m.call(result));
		return result;
	}

	shptr<class EdgeInsetsGeometry> /*non-null*/ ButtonThemeData::getPadding(/*non-null*/ shptr<class MaterialButton> button) {
		auto m = ManagedCall("ButtonThemeData", "getPadding");
		m.put("this", this);
		m.put("button", button, true);
		shptr<class EdgeInsetsGeometry> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ShapeBorder> /*non-null*/ ButtonThemeData::getShape(/*non-null*/ shptr<class MaterialButton> button) {
		auto m = ManagedCall("ButtonThemeData", "getShape");
		m.put("this", this);
		m.put("button", button, true);
		shptr<class ShapeBorder> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Duration> /*non-null*/ ButtonThemeData::getAnimationDuration(/*non-null*/ shptr<class MaterialButton> button) {
		auto m = ManagedCall("ButtonThemeData", "getAnimationDuration");
		m.put("this", this);
		m.put("button", button, true);
		shptr<class Duration> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class BoxConstraints> /*non-null*/ ButtonThemeData::getConstraints(/*non-null*/ shptr<class MaterialButton> button) {
		auto m = ManagedCall("ButtonThemeData", "getConstraints");
		m.put("this", this);
		m.put("button", button, true);
		shptr<class BoxConstraints> result;
		m.check(m.call(result));
		return result;
	}

	MaterialTapTargetSize /*non-null*/ ButtonThemeData::getMaterialTapTargetSize(/*non-null*/ shptr<class MaterialButton> button) {
		auto m = ManagedCall("ButtonThemeData", "getMaterialTapTargetSize");
		m.put("this", this);
		m.put("button", button, true);
		MaterialTapTargetSize result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ButtonThemeData> /*non-null*/ ButtonThemeData::copyWith(_copyWith p) {
		auto m = ManagedCall("ButtonThemeData", "copyWith");
		m.put("this", this);
		m.put("textTheme", p.textTheme);
		m.put("layoutBehavior", p.layoutBehavior);
		m.put("minWidth", p.minWidth);
		m.put("height", p.height);
		m.put("padding", p.padding);
		m.put("shape", p.shape);
		m.put("alignedDropdown", p.alignedDropdown);
		m.put("buttonColor", p.buttonColor);
		m.put("disabledColor", p.disabledColor);
		m.put("focusColor", p.focusColor);
		m.put("hoverColor", p.hoverColor);
		m.put("highlightColor", p.highlightColor);
		m.put("splashColor", p.splashColor);
		m.put("colorScheme", p.colorScheme);
		m.put("materialTapTargetSize", p.materialTapTargetSize);
		shptr<class ButtonThemeData> result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ ButtonThemeData::equals(/*non-null*/ shptr<class ObjBase> other) {
		auto m = ManagedCall("ButtonThemeData", "==");
		m.put("this", this);
		m.put("other", other, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ButtonThemeData> /*non-null*/ ButtonThemeData::ctorMain(_ctorMain p) {
		auto m = ManagedCall("ButtonThemeData", "ButtonThemeData");
		m.put("textTheme", p.textTheme);
		m.put("minWidth", p.minWidth);
		m.put("height", p.height);
		m.put("padding", p.padding);
		m.put("shape", p.shape);
		m.put("layoutBehavior", p.layoutBehavior);
		m.put("alignedDropdown", p.alignedDropdown);
		m.put("buttonColor", p.buttonColor);
		m.put("disabledColor", p.disabledColor);
		m.put("focusColor", p.focusColor);
		m.put("hoverColor", p.hoverColor);
		m.put("highlightColor", p.highlightColor);
		m.put("splashColor", p.splashColor);
		m.put("colorScheme", p.colorScheme);
		m.put("materialTapTargetSize", p.materialTapTargetSize);
		shptr<class ButtonThemeData> result;
		m.check(m.call(result, true));
		return result;
	}

	stdop<double> /*var-nullable*/ CheckboxThemeData::splashRadius() {
		auto m = ManagedCall("CheckboxThemeData", "splashRadius");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	stdop<MaterialTapTargetSize> /*var-nullable*/ CheckboxThemeData::materialTapTargetSize() {
		auto m = ManagedCall("CheckboxThemeData", "materialTapTargetSize");
		m.put("this", this);
		stdop<MaterialTapTargetSize> result;
		m.call(result);
		return result;
	}

	shptr<class VisualDensity> /*var-nullable*/ CheckboxThemeData::visualDensity() {
		auto m = ManagedCall("CheckboxThemeData", "visualDensity");
		m.put("this", this);
		shptr<class VisualDensity> result;
		m.call(result);
		return result;
	}

	shptr<class OutlinedBorder> /*var-nullable*/ CheckboxThemeData::shape() {
		auto m = ManagedCall("CheckboxThemeData", "shape");
		m.put("this", this);
		shptr<class OutlinedBorder> result;
		m.call(result);
		return result;
	}

	shptr<class BorderSide> /*var-nullable*/ CheckboxThemeData::side() {
		auto m = ManagedCall("CheckboxThemeData", "side");
		m.put("this", this);
		shptr<class BorderSide> result;
		m.call(result);
		return result;
	}

	shptr<class CheckboxThemeData> /*non-null*/ CheckboxThemeData::copyWith(_copyWith p) {
		auto m = ManagedCall("CheckboxThemeData", "copyWith");
		m.put("this", this);
		m.put("mouseCursor", p.mouseCursor);
		m.put("fillColor", p.fillColor);
		m.put("checkColor", p.checkColor);
		m.put("overlayColor", p.overlayColor);
		m.put("splashRadius", p.splashRadius);
		m.put("materialTapTargetSize", p.materialTapTargetSize);
		m.put("visualDensity", p.visualDensity);
		m.put("shape", p.shape);
		m.put("side", p.side);
		shptr<class CheckboxThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class CheckboxThemeData> /*non-null*/ CheckboxThemeData::lerp(/*nullable*/ shptr<class CheckboxThemeData> a, /*nullable*/ shptr<class CheckboxThemeData> b, /*non-null*/ double t) {
		auto m = ManagedCall("CheckboxThemeData", "lerp");
		m.put("a", a);
		m.put("b", b);
		m.put("t", t);
		shptr<class CheckboxThemeData> result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ CheckboxThemeData::equals(/*non-null*/ shptr<class ObjBase> other) {
		auto m = ManagedCall("CheckboxThemeData", "==");
		m.put("this", this);
		m.put("other", other, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class CheckboxThemeData> /*non-null*/ CheckboxThemeData::ctorMain(_ctorMain p) {
		auto m = ManagedCall("CheckboxThemeData", "CheckboxThemeData");
		m.put("mouseCursor", p.mouseCursor);
		m.put("fillColor", p.fillColor);
		m.put("checkColor", p.checkColor);
		m.put("overlayColor", p.overlayColor);
		m.put("splashRadius", p.splashRadius);
		m.put("materialTapTargetSize", p.materialTapTargetSize);
		m.put("visualDensity", p.visualDensity);
		m.put("shape", p.shape);
		m.put("side", p.side);
		shptr<class CheckboxThemeData> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class CheckboxThemeData> /*var-non-null*/ CheckboxTheme::data() {
		auto m = ManagedCall("CheckboxTheme", "data");
		m.put("this", this);
		shptr<class CheckboxThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class CheckboxThemeData> /*non-null*/ CheckboxTheme::of(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("CheckboxTheme", "of");
		m.put("context", context, true);
		shptr<class CheckboxThemeData> result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ CheckboxTheme::updateShouldNotify(/*non-null*/ shptr<class CheckboxTheme> oldWidget) {
		auto m = ManagedCall("CheckboxTheme", "updateShouldNotify");
		m.put("this", this);
		m.put("oldWidget", oldWidget, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class CheckboxTheme> /*non-null*/ CheckboxTheme::ctorMain(_ctorMain p) {
		auto m = ManagedCall("CheckboxTheme", "CheckboxTheme");
		m.put("key", p.key);
		m.put("data", p.data, true);
		m.put("child", p.child, true);
		shptr<class CheckboxTheme> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class ChipThemeData> /*var-non-null*/ ChipTheme::data() {
		auto m = ManagedCall("ChipTheme", "data");
		m.put("this", this);
		shptr<class ChipThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ChipThemeData> /*non-null*/ ChipTheme::of(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("ChipTheme", "of");
		m.put("context", context, true);
		shptr<class ChipThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Widget> /*non-null*/ ChipTheme::wrap(/*non-null*/ shptr<class BuildContext> context, /*non-null*/ shptr<class Widget> child) {
		auto m = ManagedCall("ChipTheme", "wrap");
		m.put("this", this);
		m.put("context", context, true);
		m.put("child", child, true);
		shptr<class Widget> result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ ChipTheme::updateShouldNotify(/*non-null*/ shptr<class ChipTheme> oldWidget) {
		auto m = ManagedCall("ChipTheme", "updateShouldNotify");
		m.put("this", this);
		m.put("oldWidget", oldWidget, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ChipTheme> /*non-null*/ ChipTheme::ctorMain(_ctorMain p) {
		auto m = ManagedCall("ChipTheme", "ChipTheme");
		m.put("key", p.key);
		m.put("data", p.data, true);
		m.put("child", p.child, true);
		shptr<class ChipTheme> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Color> /*var-nullable*/ ChipThemeData::backgroundColor() {
		auto m = ManagedCall("ChipThemeData", "backgroundColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ ChipThemeData::deleteIconColor() {
		auto m = ManagedCall("ChipThemeData", "deleteIconColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ ChipThemeData::disabledColor() {
		auto m = ManagedCall("ChipThemeData", "disabledColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ ChipThemeData::selectedColor() {
		auto m = ManagedCall("ChipThemeData", "selectedColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ ChipThemeData::secondarySelectedColor() {
		auto m = ManagedCall("ChipThemeData", "secondarySelectedColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ ChipThemeData::shadowColor() {
		auto m = ManagedCall("ChipThemeData", "shadowColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ ChipThemeData::surfaceTintColor() {
		auto m = ManagedCall("ChipThemeData", "surfaceTintColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ ChipThemeData::selectedShadowColor() {
		auto m = ManagedCall("ChipThemeData", "selectedShadowColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	stdop<bool> /*var-nullable*/ ChipThemeData::showCheckmark() {
		auto m = ManagedCall("ChipThemeData", "showCheckmark");
		m.put("this", this);
		stdop<bool> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ ChipThemeData::checkmarkColor() {
		auto m = ManagedCall("ChipThemeData", "checkmarkColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class EdgeInsetsGeometry> /*var-nullable*/ ChipThemeData::labelPadding() {
		auto m = ManagedCall("ChipThemeData", "labelPadding");
		m.put("this", this);
		shptr<class EdgeInsetsGeometry> result;
		m.call(result);
		return result;
	}

	shptr<class EdgeInsetsGeometry> /*var-nullable*/ ChipThemeData::padding() {
		auto m = ManagedCall("ChipThemeData", "padding");
		m.put("this", this);
		shptr<class EdgeInsetsGeometry> result;
		m.call(result);
		return result;
	}

	shptr<class BorderSide> /*var-nullable*/ ChipThemeData::side() {
		auto m = ManagedCall("ChipThemeData", "side");
		m.put("this", this);
		shptr<class BorderSide> result;
		m.call(result);
		return result;
	}

	shptr<class OutlinedBorder> /*var-nullable*/ ChipThemeData::shape() {
		auto m = ManagedCall("ChipThemeData", "shape");
		m.put("this", this);
		shptr<class OutlinedBorder> result;
		m.call(result);
		return result;
	}

	shptr<class TextStyle> /*var-nullable*/ ChipThemeData::labelStyle() {
		auto m = ManagedCall("ChipThemeData", "labelStyle");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.call(result);
		return result;
	}

	shptr<class TextStyle> /*var-nullable*/ ChipThemeData::secondaryLabelStyle() {
		auto m = ManagedCall("ChipThemeData", "secondaryLabelStyle");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.call(result);
		return result;
	}

	stdop<Brightness> /*var-nullable*/ ChipThemeData::brightness() {
		auto m = ManagedCall("ChipThemeData", "brightness");
		m.put("this", this);
		stdop<Brightness> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ ChipThemeData::elevation() {
		auto m = ManagedCall("ChipThemeData", "elevation");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ ChipThemeData::pressElevation() {
		auto m = ManagedCall("ChipThemeData", "pressElevation");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	shptr<class IconThemeData> /*var-nullable*/ ChipThemeData::iconTheme() {
		auto m = ManagedCall("ChipThemeData", "iconTheme");
		m.put("this", this);
		shptr<class IconThemeData> result;
		m.call(result);
		return result;
	}

	shptr<class ChipThemeData> /*non-null*/ ChipThemeData::copyWith(_copyWith p) {
		auto m = ManagedCall("ChipThemeData", "copyWith");
		m.put("this", this);
		m.put("color", p.color);
		m.put("backgroundColor", p.backgroundColor);
		m.put("deleteIconColor", p.deleteIconColor);
		m.put("disabledColor", p.disabledColor);
		m.put("selectedColor", p.selectedColor);
		m.put("secondarySelectedColor", p.secondarySelectedColor);
		m.put("shadowColor", p.shadowColor);
		m.put("surfaceTintColor", p.surfaceTintColor);
		m.put("selectedShadowColor", p.selectedShadowColor);
		m.put("showCheckmark", p.showCheckmark);
		m.put("checkmarkColor", p.checkmarkColor);
		m.put("labelPadding", p.labelPadding);
		m.put("padding", p.padding);
		m.put("side", p.side);
		m.put("shape", p.shape);
		m.put("labelStyle", p.labelStyle);
		m.put("secondaryLabelStyle", p.secondaryLabelStyle);
		m.put("brightness", p.brightness);
		m.put("elevation", p.elevation);
		m.put("pressElevation", p.pressElevation);
		m.put("iconTheme", p.iconTheme);
		shptr<class ChipThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ChipThemeData> /*nullable*/ ChipThemeData::lerp(/*nullable*/ shptr<class ChipThemeData> a, /*nullable*/ shptr<class ChipThemeData> b, /*non-null*/ double t) {
		auto m = ManagedCall("ChipThemeData", "lerp");
		m.put("a", a);
		m.put("b", b);
		m.put("t", t);
		shptr<class ChipThemeData> result;
		m.call(result);
		return result;
	}

	bool /*non-null*/ ChipThemeData::equals(/*non-null*/ shptr<class ObjBase> other) {
		auto m = ManagedCall("ChipThemeData", "==");
		m.put("this", this);
		m.put("other", other, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ChipThemeData> /*non-null*/ ChipThemeData::ctorMain(_ctorMain p) {
		auto m = ManagedCall("ChipThemeData", "ChipThemeData");
		m.put("color", p.color);
		m.put("backgroundColor", p.backgroundColor);
		m.put("deleteIconColor", p.deleteIconColor);
		m.put("disabledColor", p.disabledColor);
		m.put("selectedColor", p.selectedColor);
		m.put("secondarySelectedColor", p.secondarySelectedColor);
		m.put("shadowColor", p.shadowColor);
		m.put("surfaceTintColor", p.surfaceTintColor);
		m.put("selectedShadowColor", p.selectedShadowColor);
		m.put("showCheckmark", p.showCheckmark);
		m.put("checkmarkColor", p.checkmarkColor);
		m.put("labelPadding", p.labelPadding);
		m.put("padding", p.padding);
		m.put("side", p.side);
		m.put("shape", p.shape);
		m.put("labelStyle", p.labelStyle);
		m.put("secondaryLabelStyle", p.secondaryLabelStyle);
		m.put("brightness", p.brightness);
		m.put("elevation", p.elevation);
		m.put("pressElevation", p.pressElevation);
		m.put("iconTheme", p.iconTheme);
		shptr<class ChipThemeData> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class ChipThemeData> /*non-null*/ ChipThemeData::fromDefaults(_fromDefaults p) {
		auto m = ManagedCall("ChipThemeData", "fromDefaults");
		m.put("brightness", p.brightness);
		m.put("primaryColor", p.primaryColor);
		m.put("secondaryColor", p.secondaryColor, true);
		m.put("labelStyle", p.labelStyle, true);
		shptr<class ChipThemeData> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Decoration> /*var-nullable*/ DataTableThemeData::decoration() {
		auto m = ManagedCall("DataTableThemeData", "decoration");
		m.put("this", this);
		shptr<class Decoration> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ DataTableThemeData::dataRowMinHeight() {
		auto m = ManagedCall("DataTableThemeData", "dataRowMinHeight");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ DataTableThemeData::dataRowMaxHeight() {
		auto m = ManagedCall("DataTableThemeData", "dataRowMaxHeight");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	shptr<class TextStyle> /*var-nullable*/ DataTableThemeData::dataTextStyle() {
		auto m = ManagedCall("DataTableThemeData", "dataTextStyle");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ DataTableThemeData::headingRowHeight() {
		auto m = ManagedCall("DataTableThemeData", "headingRowHeight");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	shptr<class TextStyle> /*var-nullable*/ DataTableThemeData::headingTextStyle() {
		auto m = ManagedCall("DataTableThemeData", "headingTextStyle");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ DataTableThemeData::horizontalMargin() {
		auto m = ManagedCall("DataTableThemeData", "horizontalMargin");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ DataTableThemeData::columnSpacing() {
		auto m = ManagedCall("DataTableThemeData", "columnSpacing");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ DataTableThemeData::dividerThickness() {
		auto m = ManagedCall("DataTableThemeData", "dividerThickness");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ DataTableThemeData::checkboxHorizontalMargin() {
		auto m = ManagedCall("DataTableThemeData", "checkboxHorizontalMargin");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	stdop<double> /*get-nullable*/ DataTableThemeData::dataRowHeight() {
		auto m = ManagedCall("DataTableThemeData", "dataRowHeight");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	shptr<class DataTableThemeData> /*non-null*/ DataTableThemeData::copyWith(_copyWith p) {
		auto m = ManagedCall("DataTableThemeData", "copyWith");
		m.put("this", this);
		m.put("decoration", p.decoration);
		m.put("dataRowColor", p.dataRowColor);
		m.put("dataRowHeight", p.dataRowHeight);
		m.put("dataRowMinHeight", p.dataRowMinHeight);
		m.put("dataRowMaxHeight", p.dataRowMaxHeight);
		m.put("dataTextStyle", p.dataTextStyle);
		m.put("headingRowColor", p.headingRowColor);
		m.put("headingRowHeight", p.headingRowHeight);
		m.put("headingTextStyle", p.headingTextStyle);
		m.put("horizontalMargin", p.horizontalMargin);
		m.put("columnSpacing", p.columnSpacing);
		m.put("dividerThickness", p.dividerThickness);
		m.put("checkboxHorizontalMargin", p.checkboxHorizontalMargin);
		m.put("headingCellCursor", p.headingCellCursor);
		m.put("dataRowCursor", p.dataRowCursor);
		shptr<class DataTableThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class DataTableThemeData> /*non-null*/ DataTableThemeData::lerp(/*non-null*/ shptr<class DataTableThemeData> a, /*non-null*/ shptr<class DataTableThemeData> b, /*non-null*/ double t) {
		auto m = ManagedCall("DataTableThemeData", "lerp");
		m.put("a", a, true);
		m.put("b", b, true);
		m.put("t", t);
		shptr<class DataTableThemeData> result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ DataTableThemeData::equals(/*non-null*/ shptr<class ObjBase> other) {
		auto m = ManagedCall("DataTableThemeData", "==");
		m.put("this", this);
		m.put("other", other, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class DataTableThemeData> /*non-null*/ DataTableThemeData::ctorMain(_ctorMain p) {
		auto m = ManagedCall("DataTableThemeData", "DataTableThemeData");
		m.put("decoration", p.decoration);
		m.put("dataRowColor", p.dataRowColor);
		m.put("dataRowHeight", p.dataRowHeight);
		m.put("dataRowMinHeight", p.dataRowMinHeight);
		m.put("dataRowMaxHeight", p.dataRowMaxHeight);
		m.put("dataTextStyle", p.dataTextStyle);
		m.put("headingRowColor", p.headingRowColor);
		m.put("headingRowHeight", p.headingRowHeight);
		m.put("headingTextStyle", p.headingTextStyle);
		m.put("horizontalMargin", p.horizontalMargin);
		m.put("columnSpacing", p.columnSpacing);
		m.put("dividerThickness", p.dividerThickness);
		m.put("checkboxHorizontalMargin", p.checkboxHorizontalMargin);
		m.put("headingCellCursor", p.headingCellCursor);
		m.put("dataRowCursor", p.dataRowCursor);
		shptr<class DataTableThemeData> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class DataTableThemeData> /*var-non-null*/ DataTableTheme::data() {
		auto m = ManagedCall("DataTableTheme", "data");
		m.put("this", this);
		shptr<class DataTableThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class DataTableThemeData> /*non-null*/ DataTableTheme::of(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("DataTableTheme", "of");
		m.put("context", context, true);
		shptr<class DataTableThemeData> result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ DataTableTheme::updateShouldNotify(/*non-null*/ shptr<class DataTableTheme> oldWidget) {
		auto m = ManagedCall("DataTableTheme", "updateShouldNotify");
		m.put("this", this);
		m.put("oldWidget", oldWidget, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class DataTableTheme> /*non-null*/ DataTableTheme::ctorMain(_ctorMain p) {
		auto m = ManagedCall("DataTableTheme", "DataTableTheme");
		m.put("key", p.key);
		m.put("data", p.data, true);
		m.put("child", p.child, true);
		shptr<class DataTableTheme> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class DatePickerThemeData> /*var-non-null*/ DatePickerTheme::data() {
		auto m = ManagedCall("DatePickerTheme", "data");
		m.put("this", this);
		shptr<class DatePickerThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class DatePickerThemeData> /*non-null*/ DatePickerTheme::of(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("DatePickerTheme", "of");
		m.put("context", context, true);
		shptr<class DatePickerThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class DatePickerThemeData> /*nullable*/ DatePickerTheme::maybeOf(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("DatePickerTheme", "maybeOf");
		m.put("context", context, true);
		shptr<class DatePickerThemeData> result;
		m.call(result);
		return result;
	}

	shptr<class DatePickerThemeData> /*non-null*/ DatePickerTheme::defaults(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("DatePickerTheme", "defaults");
		m.put("context", context, true);
		shptr<class DatePickerThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Widget> /*non-null*/ DatePickerTheme::wrap(/*non-null*/ shptr<class BuildContext> context, /*non-null*/ shptr<class Widget> child) {
		auto m = ManagedCall("DatePickerTheme", "wrap");
		m.put("this", this);
		m.put("context", context, true);
		m.put("child", child, true);
		shptr<class Widget> result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ DatePickerTheme::updateShouldNotify(/*non-null*/ shptr<class DatePickerTheme> oldWidget) {
		auto m = ManagedCall("DatePickerTheme", "updateShouldNotify");
		m.put("this", this);
		m.put("oldWidget", oldWidget, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class DatePickerTheme> /*non-null*/ DatePickerTheme::ctorMain(_ctorMain p) {
		auto m = ManagedCall("DatePickerTheme", "DatePickerTheme");
		m.put("key", p.key);
		m.put("data", p.data, true);
		m.put("child", p.child, true);
		shptr<class DatePickerTheme> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Color> /*var-nullable*/ DatePickerThemeData::backgroundColor() {
		auto m = ManagedCall("DatePickerThemeData", "backgroundColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ DatePickerThemeData::elevation() {
		auto m = ManagedCall("DatePickerThemeData", "elevation");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ DatePickerThemeData::shadowColor() {
		auto m = ManagedCall("DatePickerThemeData", "shadowColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ DatePickerThemeData::surfaceTintColor() {
		auto m = ManagedCall("DatePickerThemeData", "surfaceTintColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class ShapeBorder> /*var-nullable*/ DatePickerThemeData::shape() {
		auto m = ManagedCall("DatePickerThemeData", "shape");
		m.put("this", this);
		shptr<class ShapeBorder> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ DatePickerThemeData::headerBackgroundColor() {
		auto m = ManagedCall("DatePickerThemeData", "headerBackgroundColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ DatePickerThemeData::headerForegroundColor() {
		auto m = ManagedCall("DatePickerThemeData", "headerForegroundColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class TextStyle> /*var-nullable*/ DatePickerThemeData::headerHeadlineStyle() {
		auto m = ManagedCall("DatePickerThemeData", "headerHeadlineStyle");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.call(result);
		return result;
	}

	shptr<class TextStyle> /*var-nullable*/ DatePickerThemeData::headerHelpStyle() {
		auto m = ManagedCall("DatePickerThemeData", "headerHelpStyle");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.call(result);
		return result;
	}

	shptr<class TextStyle> /*var-nullable*/ DatePickerThemeData::weekdayStyle() {
		auto m = ManagedCall("DatePickerThemeData", "weekdayStyle");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.call(result);
		return result;
	}

	shptr<class TextStyle> /*var-nullable*/ DatePickerThemeData::dayStyle() {
		auto m = ManagedCall("DatePickerThemeData", "dayStyle");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.call(result);
		return result;
	}

	shptr<class BorderSide> /*var-nullable*/ DatePickerThemeData::todayBorder() {
		auto m = ManagedCall("DatePickerThemeData", "todayBorder");
		m.put("this", this);
		shptr<class BorderSide> result;
		m.call(result);
		return result;
	}

	shptr<class TextStyle> /*var-nullable*/ DatePickerThemeData::yearStyle() {
		auto m = ManagedCall("DatePickerThemeData", "yearStyle");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ DatePickerThemeData::rangePickerBackgroundColor() {
		auto m = ManagedCall("DatePickerThemeData", "rangePickerBackgroundColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ DatePickerThemeData::rangePickerElevation() {
		auto m = ManagedCall("DatePickerThemeData", "rangePickerElevation");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ DatePickerThemeData::rangePickerShadowColor() {
		auto m = ManagedCall("DatePickerThemeData", "rangePickerShadowColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ DatePickerThemeData::rangePickerSurfaceTintColor() {
		auto m = ManagedCall("DatePickerThemeData", "rangePickerSurfaceTintColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class ShapeBorder> /*var-nullable*/ DatePickerThemeData::rangePickerShape() {
		auto m = ManagedCall("DatePickerThemeData", "rangePickerShape");
		m.put("this", this);
		shptr<class ShapeBorder> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ DatePickerThemeData::rangePickerHeaderBackgroundColor() {
		auto m = ManagedCall("DatePickerThemeData", "rangePickerHeaderBackgroundColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ DatePickerThemeData::rangePickerHeaderForegroundColor() {
		auto m = ManagedCall("DatePickerThemeData", "rangePickerHeaderForegroundColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class TextStyle> /*var-nullable*/ DatePickerThemeData::rangePickerHeaderHeadlineStyle() {
		auto m = ManagedCall("DatePickerThemeData", "rangePickerHeaderHeadlineStyle");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.call(result);
		return result;
	}

	shptr<class TextStyle> /*var-nullable*/ DatePickerThemeData::rangePickerHeaderHelpStyle() {
		auto m = ManagedCall("DatePickerThemeData", "rangePickerHeaderHelpStyle");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ DatePickerThemeData::rangeSelectionBackgroundColor() {
		auto m = ManagedCall("DatePickerThemeData", "rangeSelectionBackgroundColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ DatePickerThemeData::dividerColor() {
		auto m = ManagedCall("DatePickerThemeData", "dividerColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class InputDecorationTheme> /*var-nullable*/ DatePickerThemeData::inputDecorationTheme() {
		auto m = ManagedCall("DatePickerThemeData", "inputDecorationTheme");
		m.put("this", this);
		shptr<class InputDecorationTheme> result;
		m.call(result);
		return result;
	}

	shptr<class DatePickerThemeData> /*non-null*/ DatePickerThemeData::copyWith(_copyWith p) {
		auto m = ManagedCall("DatePickerThemeData", "copyWith");
		m.put("this", this);
		m.put("backgroundColor", p.backgroundColor);
		m.put("elevation", p.elevation);
		m.put("shadowColor", p.shadowColor);
		m.put("surfaceTintColor", p.surfaceTintColor);
		m.put("shape", p.shape);
		m.put("headerBackgroundColor", p.headerBackgroundColor);
		m.put("headerForegroundColor", p.headerForegroundColor);
		m.put("headerHeadlineStyle", p.headerHeadlineStyle);
		m.put("headerHelpStyle", p.headerHelpStyle);
		m.put("weekdayStyle", p.weekdayStyle);
		m.put("dayStyle", p.dayStyle);
		m.put("dayForegroundColor", p.dayForegroundColor);
		m.put("dayBackgroundColor", p.dayBackgroundColor);
		m.put("dayOverlayColor", p.dayOverlayColor);
		m.put("todayForegroundColor", p.todayForegroundColor);
		m.put("todayBackgroundColor", p.todayBackgroundColor);
		m.put("todayBorder", p.todayBorder);
		m.put("yearStyle", p.yearStyle);
		m.put("yearForegroundColor", p.yearForegroundColor);
		m.put("yearBackgroundColor", p.yearBackgroundColor);
		m.put("yearOverlayColor", p.yearOverlayColor);
		m.put("rangePickerBackgroundColor", p.rangePickerBackgroundColor);
		m.put("rangePickerElevation", p.rangePickerElevation);
		m.put("rangePickerShadowColor", p.rangePickerShadowColor);
		m.put("rangePickerSurfaceTintColor", p.rangePickerSurfaceTintColor);
		m.put("rangePickerShape", p.rangePickerShape);
		m.put("rangePickerHeaderBackgroundColor", p.rangePickerHeaderBackgroundColor);
		m.put("rangePickerHeaderForegroundColor", p.rangePickerHeaderForegroundColor);
		m.put("rangePickerHeaderHeadlineStyle", p.rangePickerHeaderHeadlineStyle);
		m.put("rangePickerHeaderHelpStyle", p.rangePickerHeaderHelpStyle);
		m.put("rangeSelectionBackgroundColor", p.rangeSelectionBackgroundColor);
		m.put("rangeSelectionOverlayColor", p.rangeSelectionOverlayColor);
		m.put("dividerColor", p.dividerColor);
		m.put("inputDecorationTheme", p.inputDecorationTheme);
		shptr<class DatePickerThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class DatePickerThemeData> /*non-null*/ DatePickerThemeData::lerp(/*nullable*/ shptr<class DatePickerThemeData> a, /*nullable*/ shptr<class DatePickerThemeData> b, /*non-null*/ double t) {
		auto m = ManagedCall("DatePickerThemeData", "lerp");
		m.put("a", a);
		m.put("b", b);
		m.put("t", t);
		shptr<class DatePickerThemeData> result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ DatePickerThemeData::equals(/*non-null*/ shptr<class ObjBase> other) {
		auto m = ManagedCall("DatePickerThemeData", "==");
		m.put("this", this);
		m.put("other", other, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class DatePickerThemeData> /*non-null*/ DatePickerThemeData::ctorMain(_ctorMain p) {
		auto m = ManagedCall("DatePickerThemeData", "DatePickerThemeData");
		m.put("backgroundColor", p.backgroundColor);
		m.put("elevation", p.elevation);
		m.put("shadowColor", p.shadowColor);
		m.put("surfaceTintColor", p.surfaceTintColor);
		m.put("shape", p.shape);
		m.put("headerBackgroundColor", p.headerBackgroundColor);
		m.put("headerForegroundColor", p.headerForegroundColor);
		m.put("headerHeadlineStyle", p.headerHeadlineStyle);
		m.put("headerHelpStyle", p.headerHelpStyle);
		m.put("weekdayStyle", p.weekdayStyle);
		m.put("dayStyle", p.dayStyle);
		m.put("dayForegroundColor", p.dayForegroundColor);
		m.put("dayBackgroundColor", p.dayBackgroundColor);
		m.put("dayOverlayColor", p.dayOverlayColor);
		m.put("todayForegroundColor", p.todayForegroundColor);
		m.put("todayBackgroundColor", p.todayBackgroundColor);
		m.put("todayBorder", p.todayBorder);
		m.put("yearStyle", p.yearStyle);
		m.put("yearForegroundColor", p.yearForegroundColor);
		m.put("yearBackgroundColor", p.yearBackgroundColor);
		m.put("yearOverlayColor", p.yearOverlayColor);
		m.put("rangePickerBackgroundColor", p.rangePickerBackgroundColor);
		m.put("rangePickerElevation", p.rangePickerElevation);
		m.put("rangePickerShadowColor", p.rangePickerShadowColor);
		m.put("rangePickerSurfaceTintColor", p.rangePickerSurfaceTintColor);
		m.put("rangePickerShape", p.rangePickerShape);
		m.put("rangePickerHeaderBackgroundColor", p.rangePickerHeaderBackgroundColor);
		m.put("rangePickerHeaderForegroundColor", p.rangePickerHeaderForegroundColor);
		m.put("rangePickerHeaderHeadlineStyle", p.rangePickerHeaderHeadlineStyle);
		m.put("rangePickerHeaderHelpStyle", p.rangePickerHeaderHelpStyle);
		m.put("rangeSelectionBackgroundColor", p.rangeSelectionBackgroundColor);
		m.put("rangeSelectionOverlayColor", p.rangeSelectionOverlayColor);
		m.put("dividerColor", p.dividerColor);
		m.put("inputDecorationTheme", p.inputDecorationTheme);
		shptr<class DatePickerThemeData> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Color> /*var-nullable*/ DividerThemeData::color() {
		auto m = ManagedCall("DividerThemeData", "color");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ DividerThemeData::space() {
		auto m = ManagedCall("DividerThemeData", "space");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ DividerThemeData::thickness() {
		auto m = ManagedCall("DividerThemeData", "thickness");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ DividerThemeData::indent() {
		auto m = ManagedCall("DividerThemeData", "indent");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ DividerThemeData::endIndent() {
		auto m = ManagedCall("DividerThemeData", "endIndent");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	shptr<class DividerThemeData> /*non-null*/ DividerThemeData::copyWith(_copyWith p) {
		auto m = ManagedCall("DividerThemeData", "copyWith");
		m.put("this", this);
		m.put("color", p.color);
		m.put("space", p.space);
		m.put("thickness", p.thickness);
		m.put("indent", p.indent);
		m.put("endIndent", p.endIndent);
		shptr<class DividerThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class DividerThemeData> /*non-null*/ DividerThemeData::lerp(/*nullable*/ shptr<class DividerThemeData> a, /*nullable*/ shptr<class DividerThemeData> b, /*non-null*/ double t) {
		auto m = ManagedCall("DividerThemeData", "lerp");
		m.put("a", a);
		m.put("b", b);
		m.put("t", t);
		shptr<class DividerThemeData> result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ DividerThemeData::equals(/*non-null*/ shptr<class ObjBase> other) {
		auto m = ManagedCall("DividerThemeData", "==");
		m.put("this", this);
		m.put("other", other, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class DividerThemeData> /*non-null*/ DividerThemeData::ctorMain(_ctorMain p) {
		auto m = ManagedCall("DividerThemeData", "DividerThemeData");
		m.put("color", p.color);
		m.put("space", p.space);
		m.put("thickness", p.thickness);
		m.put("indent", p.indent);
		m.put("endIndent", p.endIndent);
		shptr<class DividerThemeData> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class DividerThemeData> /*var-non-null*/ DividerTheme::data() {
		auto m = ManagedCall("DividerTheme", "data");
		m.put("this", this);
		shptr<class DividerThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class DividerThemeData> /*non-null*/ DividerTheme::of(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("DividerTheme", "of");
		m.put("context", context, true);
		shptr<class DividerThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Widget> /*non-null*/ DividerTheme::wrap(/*non-null*/ shptr<class BuildContext> context, /*non-null*/ shptr<class Widget> child) {
		auto m = ManagedCall("DividerTheme", "wrap");
		m.put("this", this);
		m.put("context", context, true);
		m.put("child", child, true);
		shptr<class Widget> result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ DividerTheme::updateShouldNotify(/*non-null*/ shptr<class DividerTheme> oldWidget) {
		auto m = ManagedCall("DividerTheme", "updateShouldNotify");
		m.put("this", this);
		m.put("oldWidget", oldWidget, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class DividerTheme> /*non-null*/ DividerTheme::ctorMain(_ctorMain p) {
		auto m = ManagedCall("DividerTheme", "DividerTheme");
		m.put("key", p.key);
		m.put("data", p.data, true);
		m.put("child", p.child, true);
		shptr<class DividerTheme> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class DrawerThemeData> /*var-non-null*/ DrawerTheme::data() {
		auto m = ManagedCall("DrawerTheme", "data");
		m.put("this", this);
		shptr<class DrawerThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class DrawerThemeData> /*non-null*/ DrawerTheme::of(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("DrawerTheme", "of");
		m.put("context", context, true);
		shptr<class DrawerThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Widget> /*non-null*/ DrawerTheme::wrap(/*non-null*/ shptr<class BuildContext> context, /*non-null*/ shptr<class Widget> child) {
		auto m = ManagedCall("DrawerTheme", "wrap");
		m.put("this", this);
		m.put("context", context, true);
		m.put("child", child, true);
		shptr<class Widget> result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ DrawerTheme::updateShouldNotify(/*non-null*/ shptr<class DrawerTheme> oldWidget) {
		auto m = ManagedCall("DrawerTheme", "updateShouldNotify");
		m.put("this", this);
		m.put("oldWidget", oldWidget, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class DrawerTheme> /*non-null*/ DrawerTheme::ctorMain(_ctorMain p) {
		auto m = ManagedCall("DrawerTheme", "DrawerTheme");
		m.put("key", p.key);
		m.put("data", p.data, true);
		m.put("child", p.child, true);
		shptr<class DrawerTheme> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Color> /*var-nullable*/ DrawerThemeData::backgroundColor() {
		auto m = ManagedCall("DrawerThemeData", "backgroundColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ DrawerThemeData::scrimColor() {
		auto m = ManagedCall("DrawerThemeData", "scrimColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ DrawerThemeData::elevation() {
		auto m = ManagedCall("DrawerThemeData", "elevation");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ DrawerThemeData::shadowColor() {
		auto m = ManagedCall("DrawerThemeData", "shadowColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ DrawerThemeData::surfaceTintColor() {
		auto m = ManagedCall("DrawerThemeData", "surfaceTintColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class ShapeBorder> /*var-nullable*/ DrawerThemeData::shape() {
		auto m = ManagedCall("DrawerThemeData", "shape");
		m.put("this", this);
		shptr<class ShapeBorder> result;
		m.call(result);
		return result;
	}

	shptr<class ShapeBorder> /*var-nullable*/ DrawerThemeData::endShape() {
		auto m = ManagedCall("DrawerThemeData", "endShape");
		m.put("this", this);
		shptr<class ShapeBorder> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ DrawerThemeData::width() {
		auto m = ManagedCall("DrawerThemeData", "width");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	shptr<class DrawerThemeData> /*non-null*/ DrawerThemeData::copyWith(_copyWith p) {
		auto m = ManagedCall("DrawerThemeData", "copyWith");
		m.put("this", this);
		m.put("backgroundColor", p.backgroundColor);
		m.put("scrimColor", p.scrimColor);
		m.put("elevation", p.elevation);
		m.put("shadowColor", p.shadowColor);
		m.put("surfaceTintColor", p.surfaceTintColor);
		m.put("shape", p.shape);
		m.put("endShape", p.endShape);
		m.put("width", p.width);
		shptr<class DrawerThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class DrawerThemeData> /*nullable*/ DrawerThemeData::lerp(/*nullable*/ shptr<class DrawerThemeData> a, /*nullable*/ shptr<class DrawerThemeData> b, /*non-null*/ double t) {
		auto m = ManagedCall("DrawerThemeData", "lerp");
		m.put("a", a);
		m.put("b", b);
		m.put("t", t);
		shptr<class DrawerThemeData> result;
		m.call(result);
		return result;
	}

	bool /*non-null*/ DrawerThemeData::equals(/*non-null*/ shptr<class ObjBase> other) {
		auto m = ManagedCall("DrawerThemeData", "==");
		m.put("this", this);
		m.put("other", other, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class DrawerThemeData> /*non-null*/ DrawerThemeData::ctorMain(_ctorMain p) {
		auto m = ManagedCall("DrawerThemeData", "DrawerThemeData");
		m.put("backgroundColor", p.backgroundColor);
		m.put("scrimColor", p.scrimColor);
		m.put("elevation", p.elevation);
		m.put("shadowColor", p.shadowColor);
		m.put("surfaceTintColor", p.surfaceTintColor);
		m.put("shape", p.shape);
		m.put("endShape", p.endShape);
		m.put("width", p.width);
		shptr<class DrawerThemeData> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class TextStyle> /*var-nullable*/ DropdownMenuThemeData::textStyle() {
		auto m = ManagedCall("DropdownMenuThemeData", "textStyle");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.call(result);
		return result;
	}

	shptr<class InputDecorationTheme> /*var-nullable*/ DropdownMenuThemeData::inputDecorationTheme() {
		auto m = ManagedCall("DropdownMenuThemeData", "inputDecorationTheme");
		m.put("this", this);
		shptr<class InputDecorationTheme> result;
		m.call(result);
		return result;
	}

	shptr<class MenuStyle> /*var-nullable*/ DropdownMenuThemeData::menuStyle() {
		auto m = ManagedCall("DropdownMenuThemeData", "menuStyle");
		m.put("this", this);
		shptr<class MenuStyle> result;
		m.call(result);
		return result;
	}

	shptr<class DropdownMenuThemeData> /*non-null*/ DropdownMenuThemeData::copyWith(_copyWith p) {
		auto m = ManagedCall("DropdownMenuThemeData", "copyWith");
		m.put("this", this);
		m.put("textStyle", p.textStyle);
		m.put("inputDecorationTheme", p.inputDecorationTheme);
		m.put("menuStyle", p.menuStyle);
		shptr<class DropdownMenuThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class DropdownMenuThemeData> /*non-null*/ DropdownMenuThemeData::lerp(/*nullable*/ shptr<class DropdownMenuThemeData> a, /*nullable*/ shptr<class DropdownMenuThemeData> b, /*non-null*/ double t) {
		auto m = ManagedCall("DropdownMenuThemeData", "lerp");
		m.put("a", a);
		m.put("b", b);
		m.put("t", t);
		shptr<class DropdownMenuThemeData> result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ DropdownMenuThemeData::equals(/*non-null*/ shptr<class ObjBase> other) {
		auto m = ManagedCall("DropdownMenuThemeData", "==");
		m.put("this", this);
		m.put("other", other, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class DropdownMenuThemeData> /*non-null*/ DropdownMenuThemeData::ctorMain(_ctorMain p) {
		auto m = ManagedCall("DropdownMenuThemeData", "DropdownMenuThemeData");
		m.put("textStyle", p.textStyle);
		m.put("inputDecorationTheme", p.inputDecorationTheme);
		m.put("menuStyle", p.menuStyle);
		shptr<class DropdownMenuThemeData> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class DropdownMenuThemeData> /*var-non-null*/ DropdownMenuTheme::data() {
		auto m = ManagedCall("DropdownMenuTheme", "data");
		m.put("this", this);
		shptr<class DropdownMenuThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class DropdownMenuThemeData> /*non-null*/ DropdownMenuTheme::of(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("DropdownMenuTheme", "of");
		m.put("context", context, true);
		shptr<class DropdownMenuThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class DropdownMenuThemeData> /*nullable*/ DropdownMenuTheme::maybeOf(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("DropdownMenuTheme", "maybeOf");
		m.put("context", context, true);
		shptr<class DropdownMenuThemeData> result;
		m.call(result);
		return result;
	}

	shptr<class Widget> /*non-null*/ DropdownMenuTheme::wrap(/*non-null*/ shptr<class BuildContext> context, /*non-null*/ shptr<class Widget> child) {
		auto m = ManagedCall("DropdownMenuTheme", "wrap");
		m.put("this", this);
		m.put("context", context, true);
		m.put("child", child, true);
		shptr<class Widget> result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ DropdownMenuTheme::updateShouldNotify(/*non-null*/ shptr<class DropdownMenuTheme> oldWidget) {
		auto m = ManagedCall("DropdownMenuTheme", "updateShouldNotify");
		m.put("this", this);
		m.put("oldWidget", oldWidget, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class DropdownMenuTheme> /*non-null*/ DropdownMenuTheme::ctorMain(_ctorMain p) {
		auto m = ManagedCall("DropdownMenuTheme", "DropdownMenuTheme");
		m.put("key", p.key);
		m.put("data", p.data, true);
		m.put("child", p.child, true);
		shptr<class DropdownMenuTheme> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class ElevatedButtonThemeData> /*var-non-null*/ ElevatedButtonTheme::data() {
		auto m = ManagedCall("ElevatedButtonTheme", "data");
		m.put("this", this);
		shptr<class ElevatedButtonThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ElevatedButtonThemeData> /*non-null*/ ElevatedButtonTheme::of(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("ElevatedButtonTheme", "of");
		m.put("context", context, true);
		shptr<class ElevatedButtonThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Widget> /*non-null*/ ElevatedButtonTheme::wrap(/*non-null*/ shptr<class BuildContext> context, /*non-null*/ shptr<class Widget> child) {
		auto m = ManagedCall("ElevatedButtonTheme", "wrap");
		m.put("this", this);
		m.put("context", context, true);
		m.put("child", child, true);
		shptr<class Widget> result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ ElevatedButtonTheme::updateShouldNotify(/*non-null*/ shptr<class ElevatedButtonTheme> oldWidget) {
		auto m = ManagedCall("ElevatedButtonTheme", "updateShouldNotify");
		m.put("this", this);
		m.put("oldWidget", oldWidget, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ElevatedButtonTheme> /*non-null*/ ElevatedButtonTheme::ctorMain(_ctorMain p) {
		auto m = ManagedCall("ElevatedButtonTheme", "ElevatedButtonTheme");
		m.put("key", p.key);
		m.put("data", p.data, true);
		m.put("child", p.child, true);
		shptr<class ElevatedButtonTheme> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class ButtonStyle> /*var-nullable*/ ElevatedButtonThemeData::style() {
		auto m = ManagedCall("ElevatedButtonThemeData", "style");
		m.put("this", this);
		shptr<class ButtonStyle> result;
		m.call(result);
		return result;
	}

	shptr<class ElevatedButtonThemeData> /*nullable*/ ElevatedButtonThemeData::lerp(/*nullable*/ shptr<class ElevatedButtonThemeData> a, /*nullable*/ shptr<class ElevatedButtonThemeData> b, /*non-null*/ double t) {
		auto m = ManagedCall("ElevatedButtonThemeData", "lerp");
		m.put("a", a);
		m.put("b", b);
		m.put("t", t);
		shptr<class ElevatedButtonThemeData> result;
		m.call(result);
		return result;
	}

	bool /*non-null*/ ElevatedButtonThemeData::equals(/*non-null*/ shptr<class ObjBase> other) {
		auto m = ManagedCall("ElevatedButtonThemeData", "==");
		m.put("this", this);
		m.put("other", other, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ElevatedButtonThemeData> /*non-null*/ ElevatedButtonThemeData::ctorMain(_ctorMain p) {
		auto m = ManagedCall("ElevatedButtonThemeData", "ElevatedButtonThemeData");
		m.put("style", p.style);
		shptr<class ElevatedButtonThemeData> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class ExpansionTileThemeData> /*var-non-null*/ ExpansionTileTheme::data() {
		auto m = ManagedCall("ExpansionTileTheme", "data");
		m.put("this", this);
		shptr<class ExpansionTileThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ExpansionTileThemeData> /*non-null*/ ExpansionTileTheme::of(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("ExpansionTileTheme", "of");
		m.put("context", context, true);
		shptr<class ExpansionTileThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Widget> /*non-null*/ ExpansionTileTheme::wrap(/*non-null*/ shptr<class BuildContext> context, /*non-null*/ shptr<class Widget> child) {
		auto m = ManagedCall("ExpansionTileTheme", "wrap");
		m.put("this", this);
		m.put("context", context, true);
		m.put("child", child, true);
		shptr<class Widget> result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ ExpansionTileTheme::updateShouldNotify(/*non-null*/ shptr<class ExpansionTileTheme> oldWidget) {
		auto m = ManagedCall("ExpansionTileTheme", "updateShouldNotify");
		m.put("this", this);
		m.put("oldWidget", oldWidget, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ExpansionTileTheme> /*non-null*/ ExpansionTileTheme::ctorMain(_ctorMain p) {
		auto m = ManagedCall("ExpansionTileTheme", "ExpansionTileTheme");
		m.put("key", p.key);
		m.put("data", p.data, true);
		m.put("child", p.child, true);
		shptr<class ExpansionTileTheme> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Color> /*var-nullable*/ ExpansionTileThemeData::backgroundColor() {
		auto m = ManagedCall("ExpansionTileThemeData", "backgroundColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ ExpansionTileThemeData::collapsedBackgroundColor() {
		auto m = ManagedCall("ExpansionTileThemeData", "collapsedBackgroundColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class EdgeInsetsGeometry> /*var-nullable*/ ExpansionTileThemeData::tilePadding() {
		auto m = ManagedCall("ExpansionTileThemeData", "tilePadding");
		m.put("this", this);
		shptr<class EdgeInsetsGeometry> result;
		m.call(result);
		return result;
	}

	shptr<class AlignmentGeometry> /*var-nullable*/ ExpansionTileThemeData::expandedAlignment() {
		auto m = ManagedCall("ExpansionTileThemeData", "expandedAlignment");
		m.put("this", this);
		shptr<class AlignmentGeometry> result;
		m.call(result);
		return result;
	}

	shptr<class EdgeInsetsGeometry> /*var-nullable*/ ExpansionTileThemeData::childrenPadding() {
		auto m = ManagedCall("ExpansionTileThemeData", "childrenPadding");
		m.put("this", this);
		shptr<class EdgeInsetsGeometry> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ ExpansionTileThemeData::iconColor() {
		auto m = ManagedCall("ExpansionTileThemeData", "iconColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ ExpansionTileThemeData::collapsedIconColor() {
		auto m = ManagedCall("ExpansionTileThemeData", "collapsedIconColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ ExpansionTileThemeData::textColor() {
		auto m = ManagedCall("ExpansionTileThemeData", "textColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ ExpansionTileThemeData::collapsedTextColor() {
		auto m = ManagedCall("ExpansionTileThemeData", "collapsedTextColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class ShapeBorder> /*var-nullable*/ ExpansionTileThemeData::shape() {
		auto m = ManagedCall("ExpansionTileThemeData", "shape");
		m.put("this", this);
		shptr<class ShapeBorder> result;
		m.call(result);
		return result;
	}

	shptr<class ShapeBorder> /*var-nullable*/ ExpansionTileThemeData::collapsedShape() {
		auto m = ManagedCall("ExpansionTileThemeData", "collapsedShape");
		m.put("this", this);
		shptr<class ShapeBorder> result;
		m.call(result);
		return result;
	}

	stdop<Clip> /*var-nullable*/ ExpansionTileThemeData::clipBehavior() {
		auto m = ManagedCall("ExpansionTileThemeData", "clipBehavior");
		m.put("this", this);
		stdop<Clip> result;
		m.call(result);
		return result;
	}

	shptr<class ExpansionTileThemeData> /*non-null*/ ExpansionTileThemeData::copyWith(_copyWith p) {
		auto m = ManagedCall("ExpansionTileThemeData", "copyWith");
		m.put("this", this);
		m.put("backgroundColor", p.backgroundColor);
		m.put("collapsedBackgroundColor", p.collapsedBackgroundColor);
		m.put("tilePadding", p.tilePadding);
		m.put("expandedAlignment", p.expandedAlignment);
		m.put("childrenPadding", p.childrenPadding);
		m.put("iconColor", p.iconColor);
		m.put("collapsedIconColor", p.collapsedIconColor);
		m.put("textColor", p.textColor);
		m.put("collapsedTextColor", p.collapsedTextColor);
		m.put("shape", p.shape);
		m.put("collapsedShape", p.collapsedShape);
		m.put("clipBehavior", p.clipBehavior);
		shptr<class ExpansionTileThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ExpansionTileThemeData> /*nullable*/ ExpansionTileThemeData::lerp(/*nullable*/ shptr<class ExpansionTileThemeData> a, /*nullable*/ shptr<class ExpansionTileThemeData> b, /*non-null*/ double t) {
		auto m = ManagedCall("ExpansionTileThemeData", "lerp");
		m.put("a", a);
		m.put("b", b);
		m.put("t", t);
		shptr<class ExpansionTileThemeData> result;
		m.call(result);
		return result;
	}

	bool /*non-null*/ ExpansionTileThemeData::equals(/*non-null*/ shptr<class ObjBase> other) {
		auto m = ManagedCall("ExpansionTileThemeData", "==");
		m.put("this", this);
		m.put("other", other, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ExpansionTileThemeData> /*non-null*/ ExpansionTileThemeData::ctorMain(_ctorMain p) {
		auto m = ManagedCall("ExpansionTileThemeData", "ExpansionTileThemeData");
		m.put("backgroundColor", p.backgroundColor);
		m.put("collapsedBackgroundColor", p.collapsedBackgroundColor);
		m.put("tilePadding", p.tilePadding);
		m.put("expandedAlignment", p.expandedAlignment);
		m.put("childrenPadding", p.childrenPadding);
		m.put("iconColor", p.iconColor);
		m.put("collapsedIconColor", p.collapsedIconColor);
		m.put("textColor", p.textColor);
		m.put("collapsedTextColor", p.collapsedTextColor);
		m.put("shape", p.shape);
		m.put("collapsedShape", p.collapsedShape);
		m.put("clipBehavior", p.clipBehavior);
		shptr<class ExpansionTileThemeData> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class FilledButtonThemeData> /*var-non-null*/ FilledButtonTheme::data() {
		auto m = ManagedCall("FilledButtonTheme", "data");
		m.put("this", this);
		shptr<class FilledButtonThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class FilledButtonThemeData> /*non-null*/ FilledButtonTheme::of(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("FilledButtonTheme", "of");
		m.put("context", context, true);
		shptr<class FilledButtonThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Widget> /*non-null*/ FilledButtonTheme::wrap(/*non-null*/ shptr<class BuildContext> context, /*non-null*/ shptr<class Widget> child) {
		auto m = ManagedCall("FilledButtonTheme", "wrap");
		m.put("this", this);
		m.put("context", context, true);
		m.put("child", child, true);
		shptr<class Widget> result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ FilledButtonTheme::updateShouldNotify(/*non-null*/ shptr<class FilledButtonTheme> oldWidget) {
		auto m = ManagedCall("FilledButtonTheme", "updateShouldNotify");
		m.put("this", this);
		m.put("oldWidget", oldWidget, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class FilledButtonTheme> /*non-null*/ FilledButtonTheme::ctorMain(_ctorMain p) {
		auto m = ManagedCall("FilledButtonTheme", "FilledButtonTheme");
		m.put("key", p.key);
		m.put("data", p.data, true);
		m.put("child", p.child, true);
		shptr<class FilledButtonTheme> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class ButtonStyle> /*var-nullable*/ FilledButtonThemeData::style() {
		auto m = ManagedCall("FilledButtonThemeData", "style");
		m.put("this", this);
		shptr<class ButtonStyle> result;
		m.call(result);
		return result;
	}

	shptr<class FilledButtonThemeData> /*nullable*/ FilledButtonThemeData::lerp(/*nullable*/ shptr<class FilledButtonThemeData> a, /*nullable*/ shptr<class FilledButtonThemeData> b, /*non-null*/ double t) {
		auto m = ManagedCall("FilledButtonThemeData", "lerp");
		m.put("a", a);
		m.put("b", b);
		m.put("t", t);
		shptr<class FilledButtonThemeData> result;
		m.call(result);
		return result;
	}

	bool /*non-null*/ FilledButtonThemeData::equals(/*non-null*/ shptr<class ObjBase> other) {
		auto m = ManagedCall("FilledButtonThemeData", "==");
		m.put("this", this);
		m.put("other", other, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class FilledButtonThemeData> /*non-null*/ FilledButtonThemeData::ctorMain(_ctorMain p) {
		auto m = ManagedCall("FilledButtonThemeData", "FilledButtonThemeData");
		m.put("style", p.style);
		shptr<class FilledButtonThemeData> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Color> /*var-nullable*/ FloatingActionButtonThemeData::foregroundColor() {
		auto m = ManagedCall("FloatingActionButtonThemeData", "foregroundColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ FloatingActionButtonThemeData::backgroundColor() {
		auto m = ManagedCall("FloatingActionButtonThemeData", "backgroundColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ FloatingActionButtonThemeData::focusColor() {
		auto m = ManagedCall("FloatingActionButtonThemeData", "focusColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ FloatingActionButtonThemeData::hoverColor() {
		auto m = ManagedCall("FloatingActionButtonThemeData", "hoverColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ FloatingActionButtonThemeData::splashColor() {
		auto m = ManagedCall("FloatingActionButtonThemeData", "splashColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ FloatingActionButtonThemeData::elevation() {
		auto m = ManagedCall("FloatingActionButtonThemeData", "elevation");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ FloatingActionButtonThemeData::focusElevation() {
		auto m = ManagedCall("FloatingActionButtonThemeData", "focusElevation");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ FloatingActionButtonThemeData::hoverElevation() {
		auto m = ManagedCall("FloatingActionButtonThemeData", "hoverElevation");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ FloatingActionButtonThemeData::disabledElevation() {
		auto m = ManagedCall("FloatingActionButtonThemeData", "disabledElevation");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ FloatingActionButtonThemeData::highlightElevation() {
		auto m = ManagedCall("FloatingActionButtonThemeData", "highlightElevation");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	shptr<class ShapeBorder> /*var-nullable*/ FloatingActionButtonThemeData::shape() {
		auto m = ManagedCall("FloatingActionButtonThemeData", "shape");
		m.put("this", this);
		shptr<class ShapeBorder> result;
		m.call(result);
		return result;
	}

	stdop<bool> /*var-nullable*/ FloatingActionButtonThemeData::enableFeedback() {
		auto m = ManagedCall("FloatingActionButtonThemeData", "enableFeedback");
		m.put("this", this);
		stdop<bool> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ FloatingActionButtonThemeData::iconSize() {
		auto m = ManagedCall("FloatingActionButtonThemeData", "iconSize");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	shptr<class BoxConstraints> /*var-nullable*/ FloatingActionButtonThemeData::sizeConstraints() {
		auto m = ManagedCall("FloatingActionButtonThemeData", "sizeConstraints");
		m.put("this", this);
		shptr<class BoxConstraints> result;
		m.call(result);
		return result;
	}

	shptr<class BoxConstraints> /*var-nullable*/ FloatingActionButtonThemeData::smallSizeConstraints() {
		auto m = ManagedCall("FloatingActionButtonThemeData", "smallSizeConstraints");
		m.put("this", this);
		shptr<class BoxConstraints> result;
		m.call(result);
		return result;
	}

	shptr<class BoxConstraints> /*var-nullable*/ FloatingActionButtonThemeData::largeSizeConstraints() {
		auto m = ManagedCall("FloatingActionButtonThemeData", "largeSizeConstraints");
		m.put("this", this);
		shptr<class BoxConstraints> result;
		m.call(result);
		return result;
	}

	shptr<class BoxConstraints> /*var-nullable*/ FloatingActionButtonThemeData::extendedSizeConstraints() {
		auto m = ManagedCall("FloatingActionButtonThemeData", "extendedSizeConstraints");
		m.put("this", this);
		shptr<class BoxConstraints> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ FloatingActionButtonThemeData::extendedIconLabelSpacing() {
		auto m = ManagedCall("FloatingActionButtonThemeData", "extendedIconLabelSpacing");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	shptr<class EdgeInsetsGeometry> /*var-nullable*/ FloatingActionButtonThemeData::extendedPadding() {
		auto m = ManagedCall("FloatingActionButtonThemeData", "extendedPadding");
		m.put("this", this);
		shptr<class EdgeInsetsGeometry> result;
		m.call(result);
		return result;
	}

	shptr<class TextStyle> /*var-nullable*/ FloatingActionButtonThemeData::extendedTextStyle() {
		auto m = ManagedCall("FloatingActionButtonThemeData", "extendedTextStyle");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.call(result);
		return result;
	}

	shptr<class FloatingActionButtonThemeData> /*non-null*/ FloatingActionButtonThemeData::copyWith(_copyWith p) {
		auto m = ManagedCall("FloatingActionButtonThemeData", "copyWith");
		m.put("this", this);
		m.put("foregroundColor", p.foregroundColor);
		m.put("backgroundColor", p.backgroundColor);
		m.put("focusColor", p.focusColor);
		m.put("hoverColor", p.hoverColor);
		m.put("splashColor", p.splashColor);
		m.put("elevation", p.elevation);
		m.put("focusElevation", p.focusElevation);
		m.put("hoverElevation", p.hoverElevation);
		m.put("disabledElevation", p.disabledElevation);
		m.put("highlightElevation", p.highlightElevation);
		m.put("shape", p.shape);
		m.put("enableFeedback", p.enableFeedback);
		m.put("iconSize", p.iconSize);
		m.put("sizeConstraints", p.sizeConstraints);
		m.put("smallSizeConstraints", p.smallSizeConstraints);
		m.put("largeSizeConstraints", p.largeSizeConstraints);
		m.put("extendedSizeConstraints", p.extendedSizeConstraints);
		m.put("extendedIconLabelSpacing", p.extendedIconLabelSpacing);
		m.put("extendedPadding", p.extendedPadding);
		m.put("extendedTextStyle", p.extendedTextStyle);
		m.put("mouseCursor", p.mouseCursor);
		shptr<class FloatingActionButtonThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class FloatingActionButtonThemeData> /*nullable*/ FloatingActionButtonThemeData::lerp(/*nullable*/ shptr<class FloatingActionButtonThemeData> a, /*nullable*/ shptr<class FloatingActionButtonThemeData> b, /*non-null*/ double t) {
		auto m = ManagedCall("FloatingActionButtonThemeData", "lerp");
		m.put("a", a);
		m.put("b", b);
		m.put("t", t);
		shptr<class FloatingActionButtonThemeData> result;
		m.call(result);
		return result;
	}

	bool /*non-null*/ FloatingActionButtonThemeData::equals(/*non-null*/ shptr<class ObjBase> other) {
		auto m = ManagedCall("FloatingActionButtonThemeData", "==");
		m.put("this", this);
		m.put("other", other, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class FloatingActionButtonThemeData> /*non-null*/ FloatingActionButtonThemeData::ctorMain(_ctorMain p) {
		auto m = ManagedCall("FloatingActionButtonThemeData", "FloatingActionButtonThemeData");
		m.put("foregroundColor", p.foregroundColor);
		m.put("backgroundColor", p.backgroundColor);
		m.put("focusColor", p.focusColor);
		m.put("hoverColor", p.hoverColor);
		m.put("splashColor", p.splashColor);
		m.put("elevation", p.elevation);
		m.put("focusElevation", p.focusElevation);
		m.put("hoverElevation", p.hoverElevation);
		m.put("disabledElevation", p.disabledElevation);
		m.put("highlightElevation", p.highlightElevation);
		m.put("shape", p.shape);
		m.put("enableFeedback", p.enableFeedback);
		m.put("iconSize", p.iconSize);
		m.put("sizeConstraints", p.sizeConstraints);
		m.put("smallSizeConstraints", p.smallSizeConstraints);
		m.put("largeSizeConstraints", p.largeSizeConstraints);
		m.put("extendedSizeConstraints", p.extendedSizeConstraints);
		m.put("extendedIconLabelSpacing", p.extendedIconLabelSpacing);
		m.put("extendedPadding", p.extendedPadding);
		m.put("extendedTextStyle", p.extendedTextStyle);
		m.put("mouseCursor", p.mouseCursor);
		shptr<class FloatingActionButtonThemeData> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class IconButtonThemeData> /*var-non-null*/ IconButtonTheme::data() {
		auto m = ManagedCall("IconButtonTheme", "data");
		m.put("this", this);
		shptr<class IconButtonThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class IconButtonThemeData> /*non-null*/ IconButtonTheme::of(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("IconButtonTheme", "of");
		m.put("context", context, true);
		shptr<class IconButtonThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Widget> /*non-null*/ IconButtonTheme::wrap(/*non-null*/ shptr<class BuildContext> context, /*non-null*/ shptr<class Widget> child) {
		auto m = ManagedCall("IconButtonTheme", "wrap");
		m.put("this", this);
		m.put("context", context, true);
		m.put("child", child, true);
		shptr<class Widget> result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ IconButtonTheme::updateShouldNotify(/*non-null*/ shptr<class IconButtonTheme> oldWidget) {
		auto m = ManagedCall("IconButtonTheme", "updateShouldNotify");
		m.put("this", this);
		m.put("oldWidget", oldWidget, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class IconButtonTheme> /*non-null*/ IconButtonTheme::ctorMain(_ctorMain p) {
		auto m = ManagedCall("IconButtonTheme", "IconButtonTheme");
		m.put("key", p.key);
		m.put("data", p.data, true);
		m.put("child", p.child, true);
		shptr<class IconButtonTheme> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class ButtonStyle> /*var-nullable*/ IconButtonThemeData::style() {
		auto m = ManagedCall("IconButtonThemeData", "style");
		m.put("this", this);
		shptr<class ButtonStyle> result;
		m.call(result);
		return result;
	}

	shptr<class IconButtonThemeData> /*nullable*/ IconButtonThemeData::lerp(/*nullable*/ shptr<class IconButtonThemeData> a, /*nullable*/ shptr<class IconButtonThemeData> b, /*non-null*/ double t) {
		auto m = ManagedCall("IconButtonThemeData", "lerp");
		m.put("a", a);
		m.put("b", b);
		m.put("t", t);
		shptr<class IconButtonThemeData> result;
		m.call(result);
		return result;
	}

	bool /*non-null*/ IconButtonThemeData::equals(/*non-null*/ shptr<class ObjBase> other) {
		auto m = ManagedCall("IconButtonThemeData", "==");
		m.put("this", this);
		m.put("other", other, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class IconButtonThemeData> /*non-null*/ IconButtonThemeData::ctorMain(_ctorMain p) {
		auto m = ManagedCall("IconButtonThemeData", "IconButtonThemeData");
		m.put("style", p.style);
		shptr<class IconButtonThemeData> result;
		m.check(m.call(result, true));
		return result;
	}

	stdop<bool> /*var-nullable*/ ListTileThemeData::dense() {
		auto m = ManagedCall("ListTileThemeData", "dense");
		m.put("this", this);
		stdop<bool> result;
		m.call(result);
		return result;
	}

	shptr<class ShapeBorder> /*var-nullable*/ ListTileThemeData::shape() {
		auto m = ManagedCall("ListTileThemeData", "shape");
		m.put("this", this);
		shptr<class ShapeBorder> result;
		m.call(result);
		return result;
	}

	stdop<ListTileStyle> /*var-nullable*/ ListTileThemeData::style() {
		auto m = ManagedCall("ListTileThemeData", "style");
		m.put("this", this);
		stdop<ListTileStyle> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ ListTileThemeData::selectedColor() {
		auto m = ManagedCall("ListTileThemeData", "selectedColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ ListTileThemeData::iconColor() {
		auto m = ManagedCall("ListTileThemeData", "iconColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ ListTileThemeData::textColor() {
		auto m = ManagedCall("ListTileThemeData", "textColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class TextStyle> /*var-nullable*/ ListTileThemeData::titleTextStyle() {
		auto m = ManagedCall("ListTileThemeData", "titleTextStyle");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.call(result);
		return result;
	}

	shptr<class TextStyle> /*var-nullable*/ ListTileThemeData::subtitleTextStyle() {
		auto m = ManagedCall("ListTileThemeData", "subtitleTextStyle");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.call(result);
		return result;
	}

	shptr<class TextStyle> /*var-nullable*/ ListTileThemeData::leadingAndTrailingTextStyle() {
		auto m = ManagedCall("ListTileThemeData", "leadingAndTrailingTextStyle");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.call(result);
		return result;
	}

	shptr<class EdgeInsetsGeometry> /*var-nullable*/ ListTileThemeData::contentPadding() {
		auto m = ManagedCall("ListTileThemeData", "contentPadding");
		m.put("this", this);
		shptr<class EdgeInsetsGeometry> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ ListTileThemeData::tileColor() {
		auto m = ManagedCall("ListTileThemeData", "tileColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ ListTileThemeData::selectedTileColor() {
		auto m = ManagedCall("ListTileThemeData", "selectedTileColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ ListTileThemeData::horizontalTitleGap() {
		auto m = ManagedCall("ListTileThemeData", "horizontalTitleGap");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ ListTileThemeData::minVerticalPadding() {
		auto m = ManagedCall("ListTileThemeData", "minVerticalPadding");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ ListTileThemeData::minLeadingWidth() {
		auto m = ManagedCall("ListTileThemeData", "minLeadingWidth");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	stdop<bool> /*var-nullable*/ ListTileThemeData::enableFeedback() {
		auto m = ManagedCall("ListTileThemeData", "enableFeedback");
		m.put("this", this);
		stdop<bool> result;
		m.call(result);
		return result;
	}

	shptr<class VisualDensity> /*var-nullable*/ ListTileThemeData::visualDensity() {
		auto m = ManagedCall("ListTileThemeData", "visualDensity");
		m.put("this", this);
		shptr<class VisualDensity> result;
		m.call(result);
		return result;
	}

	stdop<ListTileTitleAlignment> /*var-nullable*/ ListTileThemeData::titleAlignment() {
		auto m = ManagedCall("ListTileThemeData", "titleAlignment");
		m.put("this", this);
		stdop<ListTileTitleAlignment> result;
		m.call(result);
		return result;
	}

	shptr<class ListTileThemeData> /*non-null*/ ListTileThemeData::copyWith(_copyWith p) {
		auto m = ManagedCall("ListTileThemeData", "copyWith");
		m.put("this", this);
		m.put("dense", p.dense);
		m.put("shape", p.shape);
		m.put("style", p.style);
		m.put("selectedColor", p.selectedColor);
		m.put("iconColor", p.iconColor);
		m.put("textColor", p.textColor);
		m.put("titleTextStyle", p.titleTextStyle);
		m.put("subtitleTextStyle", p.subtitleTextStyle);
		m.put("leadingAndTrailingTextStyle", p.leadingAndTrailingTextStyle);
		m.put("contentPadding", p.contentPadding);
		m.put("tileColor", p.tileColor);
		m.put("selectedTileColor", p.selectedTileColor);
		m.put("horizontalTitleGap", p.horizontalTitleGap);
		m.put("minVerticalPadding", p.minVerticalPadding);
		m.put("minLeadingWidth", p.minLeadingWidth);
		m.put("enableFeedback", p.enableFeedback);
		m.put("mouseCursor", p.mouseCursor);
		m.put("isThreeLine", p.isThreeLine);
		m.put("visualDensity", p.visualDensity);
		m.put("titleAlignment", p.titleAlignment);
		shptr<class ListTileThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ListTileThemeData> /*nullable*/ ListTileThemeData::lerp(/*nullable*/ shptr<class ListTileThemeData> a, /*nullable*/ shptr<class ListTileThemeData> b, /*non-null*/ double t) {
		auto m = ManagedCall("ListTileThemeData", "lerp");
		m.put("a", a);
		m.put("b", b);
		m.put("t", t);
		shptr<class ListTileThemeData> result;
		m.call(result);
		return result;
	}

	bool /*non-null*/ ListTileThemeData::equals(/*non-null*/ shptr<class ObjBase> other) {
		auto m = ManagedCall("ListTileThemeData", "==");
		m.put("this", this);
		m.put("other", other, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ListTileThemeData> /*non-null*/ ListTileThemeData::ctorMain(_ctorMain p) {
		auto m = ManagedCall("ListTileThemeData", "ListTileThemeData");
		m.put("dense", p.dense);
		m.put("shape", p.shape);
		m.put("style", p.style);
		m.put("selectedColor", p.selectedColor);
		m.put("iconColor", p.iconColor);
		m.put("textColor", p.textColor);
		m.put("titleTextStyle", p.titleTextStyle);
		m.put("subtitleTextStyle", p.subtitleTextStyle);
		m.put("leadingAndTrailingTextStyle", p.leadingAndTrailingTextStyle);
		m.put("contentPadding", p.contentPadding);
		m.put("tileColor", p.tileColor);
		m.put("selectedTileColor", p.selectedTileColor);
		m.put("horizontalTitleGap", p.horizontalTitleGap);
		m.put("minVerticalPadding", p.minVerticalPadding);
		m.put("minLeadingWidth", p.minLeadingWidth);
		m.put("enableFeedback", p.enableFeedback);
		m.put("mouseCursor", p.mouseCursor);
		m.put("visualDensity", p.visualDensity);
		m.put("titleAlignment", p.titleAlignment);
		shptr<class ListTileThemeData> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class ListTileThemeData> /*get-non-null*/ ListTileTheme::data() {
		auto m = ManagedCall("ListTileTheme", "data");
		m.put("this", this);
		shptr<class ListTileThemeData> result;
		m.check(m.call(result));
		return result;
	}

	stdop<bool> /*get-nullable*/ ListTileTheme::dense() {
		auto m = ManagedCall("ListTileTheme", "dense");
		m.put("this", this);
		stdop<bool> result;
		m.call(result);
		return result;
	}

	shptr<class ShapeBorder> /*get-nullable*/ ListTileTheme::shape() {
		auto m = ManagedCall("ListTileTheme", "shape");
		m.put("this", this);
		shptr<class ShapeBorder> result;
		m.call(result);
		return result;
	}

	stdop<ListTileStyle> /*get-nullable*/ ListTileTheme::style() {
		auto m = ManagedCall("ListTileTheme", "style");
		m.put("this", this);
		stdop<ListTileStyle> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*get-nullable*/ ListTileTheme::selectedColor() {
		auto m = ManagedCall("ListTileTheme", "selectedColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*get-nullable*/ ListTileTheme::iconColor() {
		auto m = ManagedCall("ListTileTheme", "iconColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*get-nullable*/ ListTileTheme::textColor() {
		auto m = ManagedCall("ListTileTheme", "textColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class EdgeInsetsGeometry> /*get-nullable*/ ListTileTheme::contentPadding() {
		auto m = ManagedCall("ListTileTheme", "contentPadding");
		m.put("this", this);
		shptr<class EdgeInsetsGeometry> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*get-nullable*/ ListTileTheme::tileColor() {
		auto m = ManagedCall("ListTileTheme", "tileColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*get-nullable*/ ListTileTheme::selectedTileColor() {
		auto m = ManagedCall("ListTileTheme", "selectedTileColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	stdop<double> /*get-nullable*/ ListTileTheme::horizontalTitleGap() {
		auto m = ManagedCall("ListTileTheme", "horizontalTitleGap");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	stdop<double> /*get-nullable*/ ListTileTheme::minVerticalPadding() {
		auto m = ManagedCall("ListTileTheme", "minVerticalPadding");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	stdop<double> /*get-nullable*/ ListTileTheme::minLeadingWidth() {
		auto m = ManagedCall("ListTileTheme", "minLeadingWidth");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	stdop<bool> /*get-nullable*/ ListTileTheme::enableFeedback() {
		auto m = ManagedCall("ListTileTheme", "enableFeedback");
		m.put("this", this);
		stdop<bool> result;
		m.call(result);
		return result;
	}

	shptr<class ListTileThemeData> /*non-null*/ ListTileTheme::of(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("ListTileTheme", "of");
		m.put("context", context, true);
		shptr<class ListTileThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Widget> /*non-null*/ ListTileTheme::merge(_merge p) {
		auto m = ManagedCall("ListTileTheme", "merge");
		m.put("key", p.key);
		m.put("dense", p.dense);
		m.put("shape", p.shape);
		m.put("style", p.style);
		m.put("selectedColor", p.selectedColor);
		m.put("iconColor", p.iconColor);
		m.put("textColor", p.textColor);
		m.put("titleTextStyle", p.titleTextStyle);
		m.put("subtitleTextStyle", p.subtitleTextStyle);
		m.put("leadingAndTrailingTextStyle", p.leadingAndTrailingTextStyle);
		m.put("contentPadding", p.contentPadding);
		m.put("tileColor", p.tileColor);
		m.put("selectedTileColor", p.selectedTileColor);
		m.put("enableFeedback", p.enableFeedback);
		m.put("horizontalTitleGap", p.horizontalTitleGap);
		m.put("minVerticalPadding", p.minVerticalPadding);
		m.put("minLeadingWidth", p.minLeadingWidth);
		m.put("titleAlignment", p.titleAlignment);
		m.put("mouseCursor", p.mouseCursor);
		m.put("visualDensity", p.visualDensity);
		m.put("child", p.child, true);
		shptr<class Widget> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Widget> /*non-null*/ ListTileTheme::wrap(/*non-null*/ shptr<class BuildContext> context, /*non-null*/ shptr<class Widget> child) {
		auto m = ManagedCall("ListTileTheme", "wrap");
		m.put("this", this);
		m.put("context", context, true);
		m.put("child", child, true);
		shptr<class Widget> result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ ListTileTheme::updateShouldNotify(/*non-null*/ shptr<class ListTileTheme> oldWidget) {
		auto m = ManagedCall("ListTileTheme", "updateShouldNotify");
		m.put("this", this);
		m.put("oldWidget", oldWidget, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ListTileTheme> /*non-null*/ ListTileTheme::ctorMain(_ctorMain p) {
		auto m = ManagedCall("ListTileTheme", "ListTileTheme");
		m.put("key", p.key);
		m.put("data", p.data);
		m.put("dense", p.dense);
		m.put("shape", p.shape);
		m.put("style", p.style);
		m.put("selectedColor", p.selectedColor);
		m.put("iconColor", p.iconColor);
		m.put("textColor", p.textColor);
		m.put("contentPadding", p.contentPadding);
		m.put("tileColor", p.tileColor);
		m.put("selectedTileColor", p.selectedTileColor);
		m.put("enableFeedback", p.enableFeedback);
		m.put("mouseCursor", p.mouseCursor);
		m.put("horizontalTitleGap", p.horizontalTitleGap);
		m.put("minVerticalPadding", p.minVerticalPadding);
		m.put("minLeadingWidth", p.minLeadingWidth);
		m.put("child", p.child, true);
		shptr<class ListTileTheme> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class VisualDensity> /*var-nullable*/ MenuStyle::visualDensity() {
		auto m = ManagedCall("MenuStyle", "visualDensity");
		m.put("this", this);
		shptr<class VisualDensity> result;
		m.call(result);
		return result;
	}

	shptr<class AlignmentGeometry> /*var-nullable*/ MenuStyle::alignment() {
		auto m = ManagedCall("MenuStyle", "alignment");
		m.put("this", this);
		shptr<class AlignmentGeometry> result;
		m.call(result);
		return result;
	}

	bool /*non-null*/ MenuStyle::equals(/*non-null*/ shptr<class ObjBase> other) {
		auto m = ManagedCall("MenuStyle", "==");
		m.put("this", this);
		m.put("other", other, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class MenuStyle> /*non-null*/ MenuStyle::copyWith(_copyWith p) {
		auto m = ManagedCall("MenuStyle", "copyWith");
		m.put("this", this);
		m.put("backgroundColor", p.backgroundColor);
		m.put("shadowColor", p.shadowColor);
		m.put("surfaceTintColor", p.surfaceTintColor);
		m.put("elevation", p.elevation);
		m.put("padding", p.padding);
		m.put("minimumSize", p.minimumSize);
		m.put("fixedSize", p.fixedSize);
		m.put("maximumSize", p.maximumSize);
		m.put("side", p.side);
		m.put("shape", p.shape);
		m.put("mouseCursor", p.mouseCursor);
		m.put("visualDensity", p.visualDensity);
		m.put("alignment", p.alignment);
		shptr<class MenuStyle> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class MenuStyle> /*non-null*/ MenuStyle::merge(/*nullable*/ shptr<class MenuStyle> style) {
		auto m = ManagedCall("MenuStyle", "merge");
		m.put("this", this);
		m.put("style", style);
		shptr<class MenuStyle> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class MenuStyle> /*nullable*/ MenuStyle::lerp(/*nullable*/ shptr<class MenuStyle> a, /*nullable*/ shptr<class MenuStyle> b, /*non-null*/ double t) {
		auto m = ManagedCall("MenuStyle", "lerp");
		m.put("a", a);
		m.put("b", b);
		m.put("t", t);
		shptr<class MenuStyle> result;
		m.call(result);
		return result;
	}

	shptr<class MenuStyle> /*non-null*/ MenuStyle::ctorMain(_ctorMain p) {
		auto m = ManagedCall("MenuStyle", "MenuStyle");
		m.put("backgroundColor", p.backgroundColor);
		m.put("shadowColor", p.shadowColor);
		m.put("surfaceTintColor", p.surfaceTintColor);
		m.put("elevation", p.elevation);
		m.put("padding", p.padding);
		m.put("minimumSize", p.minimumSize);
		m.put("fixedSize", p.fixedSize);
		m.put("maximumSize", p.maximumSize);
		m.put("side", p.side);
		m.put("shape", p.shape);
		m.put("mouseCursor", p.mouseCursor);
		m.put("visualDensity", p.visualDensity);
		m.put("alignment", p.alignment);
		shptr<class MenuStyle> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class MenuButtonThemeData> /*var-non-null*/ MenuButtonTheme::data() {
		auto m = ManagedCall("MenuButtonTheme", "data");
		m.put("this", this);
		shptr<class MenuButtonThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class MenuButtonThemeData> /*non-null*/ MenuButtonTheme::of(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("MenuButtonTheme", "of");
		m.put("context", context, true);
		shptr<class MenuButtonThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Widget> /*non-null*/ MenuButtonTheme::wrap(/*non-null*/ shptr<class BuildContext> context, /*non-null*/ shptr<class Widget> child) {
		auto m = ManagedCall("MenuButtonTheme", "wrap");
		m.put("this", this);
		m.put("context", context, true);
		m.put("child", child, true);
		shptr<class Widget> result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ MenuButtonTheme::updateShouldNotify(/*non-null*/ shptr<class MenuButtonTheme> oldWidget) {
		auto m = ManagedCall("MenuButtonTheme", "updateShouldNotify");
		m.put("this", this);
		m.put("oldWidget", oldWidget, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class MenuButtonTheme> /*non-null*/ MenuButtonTheme::ctorMain(_ctorMain p) {
		auto m = ManagedCall("MenuButtonTheme", "MenuButtonTheme");
		m.put("key", p.key);
		m.put("data", p.data, true);
		m.put("child", p.child, true);
		shptr<class MenuButtonTheme> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class ButtonStyle> /*var-nullable*/ MenuButtonThemeData::style() {
		auto m = ManagedCall("MenuButtonThemeData", "style");
		m.put("this", this);
		shptr<class ButtonStyle> result;
		m.call(result);
		return result;
	}

	shptr<class MenuButtonThemeData> /*nullable*/ MenuButtonThemeData::lerp(/*nullable*/ shptr<class MenuButtonThemeData> a, /*nullable*/ shptr<class MenuButtonThemeData> b, /*non-null*/ double t) {
		auto m = ManagedCall("MenuButtonThemeData", "lerp");
		m.put("a", a);
		m.put("b", b);
		m.put("t", t);
		shptr<class MenuButtonThemeData> result;
		m.call(result);
		return result;
	}

	bool /*non-null*/ MenuButtonThemeData::equals(/*non-null*/ shptr<class ObjBase> other) {
		auto m = ManagedCall("MenuButtonThemeData", "==");
		m.put("this", this);
		m.put("other", other, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class MenuButtonThemeData> /*non-null*/ MenuButtonThemeData::ctorMain(_ctorMain p) {
		auto m = ManagedCall("MenuButtonThemeData", "MenuButtonThemeData");
		m.put("style", p.style);
		shptr<class MenuButtonThemeData> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class MenuStyle> /*var-nullable*/ MenuThemeData::style() {
		auto m = ManagedCall("MenuThemeData", "style");
		m.put("this", this);
		shptr<class MenuStyle> result;
		m.call(result);
		return result;
	}

	shptr<class MenuThemeData> /*nullable*/ MenuThemeData::lerp(/*nullable*/ shptr<class MenuThemeData> a, /*nullable*/ shptr<class MenuThemeData> b, /*non-null*/ double t) {
		auto m = ManagedCall("MenuThemeData", "lerp");
		m.put("a", a);
		m.put("b", b);
		m.put("t", t);
		shptr<class MenuThemeData> result;
		m.call(result);
		return result;
	}

	bool /*non-null*/ MenuThemeData::equals(/*non-null*/ shptr<class ObjBase> other) {
		auto m = ManagedCall("MenuThemeData", "==");
		m.put("this", this);
		m.put("other", other, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class MenuThemeData> /*non-null*/ MenuThemeData::ctorMain(_ctorMain p) {
		auto m = ManagedCall("MenuThemeData", "MenuThemeData");
		m.put("style", p.style);
		shptr<class MenuThemeData> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class MenuThemeData> /*var-non-null*/ MenuTheme::data() {
		auto m = ManagedCall("MenuTheme", "data");
		m.put("this", this);
		shptr<class MenuThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class MenuThemeData> /*non-null*/ MenuTheme::of(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("MenuTheme", "of");
		m.put("context", context, true);
		shptr<class MenuThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Widget> /*non-null*/ MenuTheme::wrap(/*non-null*/ shptr<class BuildContext> context, /*non-null*/ shptr<class Widget> child) {
		auto m = ManagedCall("MenuTheme", "wrap");
		m.put("this", this);
		m.put("context", context, true);
		m.put("child", child, true);
		shptr<class Widget> result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ MenuTheme::updateShouldNotify(/*non-null*/ shptr<class MenuTheme> oldWidget) {
		auto m = ManagedCall("MenuTheme", "updateShouldNotify");
		m.put("this", this);
		m.put("oldWidget", oldWidget, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class MenuTheme> /*non-null*/ MenuTheme::ctorMain(_ctorMain p) {
		auto m = ManagedCall("MenuTheme", "MenuTheme");
		m.put("key", p.key);
		m.put("data", p.data, true);
		m.put("child", p.child, true);
		shptr<class MenuTheme> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class MenuBarThemeData> /*var-non-null*/ MenuBarTheme::data() {
		auto m = ManagedCall("MenuBarTheme", "data");
		m.put("this", this);
		shptr<class MenuBarThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class MenuBarThemeData> /*non-null*/ MenuBarTheme::of(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("MenuBarTheme", "of");
		m.put("context", context, true);
		shptr<class MenuBarThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Widget> /*non-null*/ MenuBarTheme::wrap(/*non-null*/ shptr<class BuildContext> context, /*non-null*/ shptr<class Widget> child) {
		auto m = ManagedCall("MenuBarTheme", "wrap");
		m.put("this", this);
		m.put("context", context, true);
		m.put("child", child, true);
		shptr<class Widget> result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ MenuBarTheme::updateShouldNotify(/*non-null*/ shptr<class MenuBarTheme> oldWidget) {
		auto m = ManagedCall("MenuBarTheme", "updateShouldNotify");
		m.put("this", this);
		m.put("oldWidget", oldWidget, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class MenuBarTheme> /*non-null*/ MenuBarTheme::ctorMain(_ctorMain p) {
		auto m = ManagedCall("MenuBarTheme", "MenuBarTheme");
		m.put("key", p.key);
		m.put("data", p.data, true);
		m.put("child", p.child, true);
		shptr<class MenuBarTheme> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class MenuBarThemeData> /*nullable*/ MenuBarThemeData::lerp(/*nullable*/ shptr<class MenuBarThemeData> a, /*nullable*/ shptr<class MenuBarThemeData> b, /*non-null*/ double t) {
		auto m = ManagedCall("MenuBarThemeData", "lerp");
		m.put("a", a);
		m.put("b", b);
		m.put("t", t);
		shptr<class MenuBarThemeData> result;
		m.call(result);
		return result;
	}

	shptr<class MenuBarThemeData> /*non-null*/ MenuBarThemeData::ctorMain(_ctorMain p) {
		auto m = ManagedCall("MenuBarThemeData", "MenuBarThemeData");
		m.put("style", p.style);
		shptr<class MenuBarThemeData> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class NavigationBarThemeData> /*var-non-null*/ NavigationBarTheme::data() {
		auto m = ManagedCall("NavigationBarTheme", "data");
		m.put("this", this);
		shptr<class NavigationBarThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class NavigationBarThemeData> /*non-null*/ NavigationBarTheme::of(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("NavigationBarTheme", "of");
		m.put("context", context, true);
		shptr<class NavigationBarThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Widget> /*non-null*/ NavigationBarTheme::wrap(/*non-null*/ shptr<class BuildContext> context, /*non-null*/ shptr<class Widget> child) {
		auto m = ManagedCall("NavigationBarTheme", "wrap");
		m.put("this", this);
		m.put("context", context, true);
		m.put("child", child, true);
		shptr<class Widget> result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ NavigationBarTheme::updateShouldNotify(/*non-null*/ shptr<class NavigationBarTheme> oldWidget) {
		auto m = ManagedCall("NavigationBarTheme", "updateShouldNotify");
		m.put("this", this);
		m.put("oldWidget", oldWidget, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class NavigationBarTheme> /*non-null*/ NavigationBarTheme::ctorMain(_ctorMain p) {
		auto m = ManagedCall("NavigationBarTheme", "NavigationBarTheme");
		m.put("key", p.key);
		m.put("data", p.data, true);
		m.put("child", p.child, true);
		shptr<class NavigationBarTheme> result;
		m.check(m.call(result, true));
		return result;
	}

	stdop<double> /*var-nullable*/ NavigationBarThemeData::height() {
		auto m = ManagedCall("NavigationBarThemeData", "height");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ NavigationBarThemeData::backgroundColor() {
		auto m = ManagedCall("NavigationBarThemeData", "backgroundColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ NavigationBarThemeData::elevation() {
		auto m = ManagedCall("NavigationBarThemeData", "elevation");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ NavigationBarThemeData::shadowColor() {
		auto m = ManagedCall("NavigationBarThemeData", "shadowColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ NavigationBarThemeData::surfaceTintColor() {
		auto m = ManagedCall("NavigationBarThemeData", "surfaceTintColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ NavigationBarThemeData::indicatorColor() {
		auto m = ManagedCall("NavigationBarThemeData", "indicatorColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class ShapeBorder> /*var-nullable*/ NavigationBarThemeData::indicatorShape() {
		auto m = ManagedCall("NavigationBarThemeData", "indicatorShape");
		m.put("this", this);
		shptr<class ShapeBorder> result;
		m.call(result);
		return result;
	}

	stdop<NavigationDestinationLabelBehavior> /*var-nullable*/ NavigationBarThemeData::labelBehavior() {
		auto m = ManagedCall("NavigationBarThemeData", "labelBehavior");
		m.put("this", this);
		stdop<NavigationDestinationLabelBehavior> result;
		m.call(result);
		return result;
	}

	shptr<class NavigationBarThemeData> /*non-null*/ NavigationBarThemeData::copyWith(_copyWith p) {
		auto m = ManagedCall("NavigationBarThemeData", "copyWith");
		m.put("this", this);
		m.put("height", p.height);
		m.put("backgroundColor", p.backgroundColor);
		m.put("elevation", p.elevation);
		m.put("shadowColor", p.shadowColor);
		m.put("surfaceTintColor", p.surfaceTintColor);
		m.put("indicatorColor", p.indicatorColor);
		m.put("indicatorShape", p.indicatorShape);
		m.put("labelTextStyle", p.labelTextStyle);
		m.put("iconTheme", p.iconTheme);
		m.put("labelBehavior", p.labelBehavior);
		shptr<class NavigationBarThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class NavigationBarThemeData> /*nullable*/ NavigationBarThemeData::lerp(/*nullable*/ shptr<class NavigationBarThemeData> a, /*nullable*/ shptr<class NavigationBarThemeData> b, /*non-null*/ double t) {
		auto m = ManagedCall("NavigationBarThemeData", "lerp");
		m.put("a", a);
		m.put("b", b);
		m.put("t", t);
		shptr<class NavigationBarThemeData> result;
		m.call(result);
		return result;
	}

	bool /*non-null*/ NavigationBarThemeData::equals(/*non-null*/ shptr<class ObjBase> other) {
		auto m = ManagedCall("NavigationBarThemeData", "==");
		m.put("this", this);
		m.put("other", other, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class NavigationBarThemeData> /*non-null*/ NavigationBarThemeData::ctorMain(_ctorMain p) {
		auto m = ManagedCall("NavigationBarThemeData", "NavigationBarThemeData");
		m.put("height", p.height);
		m.put("backgroundColor", p.backgroundColor);
		m.put("elevation", p.elevation);
		m.put("shadowColor", p.shadowColor);
		m.put("surfaceTintColor", p.surfaceTintColor);
		m.put("indicatorColor", p.indicatorColor);
		m.put("indicatorShape", p.indicatorShape);
		m.put("labelTextStyle", p.labelTextStyle);
		m.put("iconTheme", p.iconTheme);
		m.put("labelBehavior", p.labelBehavior);
		shptr<class NavigationBarThemeData> result;
		m.check(m.call(result, true));
		return result;
	}

	stdop<double> /*var-nullable*/ NavigationDrawerThemeData::tileHeight() {
		auto m = ManagedCall("NavigationDrawerThemeData", "tileHeight");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ NavigationDrawerThemeData::backgroundColor() {
		auto m = ManagedCall("NavigationDrawerThemeData", "backgroundColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ NavigationDrawerThemeData::elevation() {
		auto m = ManagedCall("NavigationDrawerThemeData", "elevation");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ NavigationDrawerThemeData::shadowColor() {
		auto m = ManagedCall("NavigationDrawerThemeData", "shadowColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ NavigationDrawerThemeData::surfaceTintColor() {
		auto m = ManagedCall("NavigationDrawerThemeData", "surfaceTintColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ NavigationDrawerThemeData::indicatorColor() {
		auto m = ManagedCall("NavigationDrawerThemeData", "indicatorColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class ShapeBorder> /*var-nullable*/ NavigationDrawerThemeData::indicatorShape() {
		auto m = ManagedCall("NavigationDrawerThemeData", "indicatorShape");
		m.put("this", this);
		shptr<class ShapeBorder> result;
		m.call(result);
		return result;
	}

	shptr<class Size> /*var-nullable*/ NavigationDrawerThemeData::indicatorSize() {
		auto m = ManagedCall("NavigationDrawerThemeData", "indicatorSize");
		m.put("this", this);
		shptr<class Size> result;
		m.call(result);
		return result;
	}

	shptr<class NavigationDrawerThemeData> /*non-null*/ NavigationDrawerThemeData::copyWith(_copyWith p) {
		auto m = ManagedCall("NavigationDrawerThemeData", "copyWith");
		m.put("this", this);
		m.put("tileHeight", p.tileHeight);
		m.put("backgroundColor", p.backgroundColor);
		m.put("elevation", p.elevation);
		m.put("shadowColor", p.shadowColor);
		m.put("surfaceTintColor", p.surfaceTintColor);
		m.put("indicatorColor", p.indicatorColor);
		m.put("indicatorShape", p.indicatorShape);
		m.put("indicatorSize", p.indicatorSize);
		m.put("labelTextStyle", p.labelTextStyle);
		m.put("iconTheme", p.iconTheme);
		shptr<class NavigationDrawerThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class NavigationDrawerThemeData> /*nullable*/ NavigationDrawerThemeData::lerp(/*nullable*/ shptr<class NavigationDrawerThemeData> a, /*nullable*/ shptr<class NavigationDrawerThemeData> b, /*non-null*/ double t) {
		auto m = ManagedCall("NavigationDrawerThemeData", "lerp");
		m.put("a", a);
		m.put("b", b);
		m.put("t", t);
		shptr<class NavigationDrawerThemeData> result;
		m.call(result);
		return result;
	}

	bool /*non-null*/ NavigationDrawerThemeData::equals(/*non-null*/ shptr<class ObjBase> other) {
		auto m = ManagedCall("NavigationDrawerThemeData", "==");
		m.put("this", this);
		m.put("other", other, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class NavigationDrawerThemeData> /*non-null*/ NavigationDrawerThemeData::ctorMain(_ctorMain p) {
		auto m = ManagedCall("NavigationDrawerThemeData", "NavigationDrawerThemeData");
		m.put("tileHeight", p.tileHeight);
		m.put("backgroundColor", p.backgroundColor);
		m.put("elevation", p.elevation);
		m.put("shadowColor", p.shadowColor);
		m.put("surfaceTintColor", p.surfaceTintColor);
		m.put("indicatorColor", p.indicatorColor);
		m.put("indicatorShape", p.indicatorShape);
		m.put("indicatorSize", p.indicatorSize);
		m.put("labelTextStyle", p.labelTextStyle);
		m.put("iconTheme", p.iconTheme);
		shptr<class NavigationDrawerThemeData> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class NavigationDrawerThemeData> /*var-non-null*/ NavigationDrawerTheme::data() {
		auto m = ManagedCall("NavigationDrawerTheme", "data");
		m.put("this", this);
		shptr<class NavigationDrawerThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class NavigationDrawerThemeData> /*non-null*/ NavigationDrawerTheme::of(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("NavigationDrawerTheme", "of");
		m.put("context", context, true);
		shptr<class NavigationDrawerThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Widget> /*non-null*/ NavigationDrawerTheme::wrap(/*non-null*/ shptr<class BuildContext> context, /*non-null*/ shptr<class Widget> child) {
		auto m = ManagedCall("NavigationDrawerTheme", "wrap");
		m.put("this", this);
		m.put("context", context, true);
		m.put("child", child, true);
		shptr<class Widget> result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ NavigationDrawerTheme::updateShouldNotify(/*non-null*/ shptr<class NavigationDrawerTheme> oldWidget) {
		auto m = ManagedCall("NavigationDrawerTheme", "updateShouldNotify");
		m.put("this", this);
		m.put("oldWidget", oldWidget, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class NavigationDrawerTheme> /*non-null*/ NavigationDrawerTheme::ctorMain(_ctorMain p) {
		auto m = ManagedCall("NavigationDrawerTheme", "NavigationDrawerTheme");
		m.put("key", p.key);
		m.put("data", p.data, true);
		m.put("child", p.child, true);
		shptr<class NavigationDrawerTheme> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class NavigationRailThemeData> /*var-non-null*/ NavigationRailTheme::data() {
		auto m = ManagedCall("NavigationRailTheme", "data");
		m.put("this", this);
		shptr<class NavigationRailThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class NavigationRailThemeData> /*non-null*/ NavigationRailTheme::of(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("NavigationRailTheme", "of");
		m.put("context", context, true);
		shptr<class NavigationRailThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Widget> /*non-null*/ NavigationRailTheme::wrap(/*non-null*/ shptr<class BuildContext> context, /*non-null*/ shptr<class Widget> child) {
		auto m = ManagedCall("NavigationRailTheme", "wrap");
		m.put("this", this);
		m.put("context", context, true);
		m.put("child", child, true);
		shptr<class Widget> result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ NavigationRailTheme::updateShouldNotify(/*non-null*/ shptr<class NavigationRailTheme> oldWidget) {
		auto m = ManagedCall("NavigationRailTheme", "updateShouldNotify");
		m.put("this", this);
		m.put("oldWidget", oldWidget, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class NavigationRailTheme> /*non-null*/ NavigationRailTheme::ctorMain(_ctorMain p) {
		auto m = ManagedCall("NavigationRailTheme", "NavigationRailTheme");
		m.put("key", p.key);
		m.put("data", p.data, true);
		m.put("child", p.child, true);
		shptr<class NavigationRailTheme> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Color> /*var-nullable*/ NavigationRailThemeData::backgroundColor() {
		auto m = ManagedCall("NavigationRailThemeData", "backgroundColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ NavigationRailThemeData::elevation() {
		auto m = ManagedCall("NavigationRailThemeData", "elevation");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	shptr<class TextStyle> /*var-nullable*/ NavigationRailThemeData::unselectedLabelTextStyle() {
		auto m = ManagedCall("NavigationRailThemeData", "unselectedLabelTextStyle");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.call(result);
		return result;
	}

	shptr<class TextStyle> /*var-nullable*/ NavigationRailThemeData::selectedLabelTextStyle() {
		auto m = ManagedCall("NavigationRailThemeData", "selectedLabelTextStyle");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.call(result);
		return result;
	}

	shptr<class IconThemeData> /*var-nullable*/ NavigationRailThemeData::unselectedIconTheme() {
		auto m = ManagedCall("NavigationRailThemeData", "unselectedIconTheme");
		m.put("this", this);
		shptr<class IconThemeData> result;
		m.call(result);
		return result;
	}

	shptr<class IconThemeData> /*var-nullable*/ NavigationRailThemeData::selectedIconTheme() {
		auto m = ManagedCall("NavigationRailThemeData", "selectedIconTheme");
		m.put("this", this);
		shptr<class IconThemeData> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ NavigationRailThemeData::groupAlignment() {
		auto m = ManagedCall("NavigationRailThemeData", "groupAlignment");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	stdop<NavigationRailLabelType> /*var-nullable*/ NavigationRailThemeData::labelType() {
		auto m = ManagedCall("NavigationRailThemeData", "labelType");
		m.put("this", this);
		stdop<NavigationRailLabelType> result;
		m.call(result);
		return result;
	}

	stdop<bool> /*var-nullable*/ NavigationRailThemeData::useIndicator() {
		auto m = ManagedCall("NavigationRailThemeData", "useIndicator");
		m.put("this", this);
		stdop<bool> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ NavigationRailThemeData::indicatorColor() {
		auto m = ManagedCall("NavigationRailThemeData", "indicatorColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class ShapeBorder> /*var-nullable*/ NavigationRailThemeData::indicatorShape() {
		auto m = ManagedCall("NavigationRailThemeData", "indicatorShape");
		m.put("this", this);
		shptr<class ShapeBorder> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ NavigationRailThemeData::minWidth() {
		auto m = ManagedCall("NavigationRailThemeData", "minWidth");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ NavigationRailThemeData::minExtendedWidth() {
		auto m = ManagedCall("NavigationRailThemeData", "minExtendedWidth");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	shptr<class NavigationRailThemeData> /*non-null*/ NavigationRailThemeData::copyWith(_copyWith p) {
		auto m = ManagedCall("NavigationRailThemeData", "copyWith");
		m.put("this", this);
		m.put("backgroundColor", p.backgroundColor);
		m.put("elevation", p.elevation);
		m.put("unselectedLabelTextStyle", p.unselectedLabelTextStyle);
		m.put("selectedLabelTextStyle", p.selectedLabelTextStyle);
		m.put("unselectedIconTheme", p.unselectedIconTheme);
		m.put("selectedIconTheme", p.selectedIconTheme);
		m.put("groupAlignment", p.groupAlignment);
		m.put("labelType", p.labelType);
		m.put("useIndicator", p.useIndicator);
		m.put("indicatorColor", p.indicatorColor);
		m.put("indicatorShape", p.indicatorShape);
		m.put("minWidth", p.minWidth);
		m.put("minExtendedWidth", p.minExtendedWidth);
		shptr<class NavigationRailThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class NavigationRailThemeData> /*nullable*/ NavigationRailThemeData::lerp(/*nullable*/ shptr<class NavigationRailThemeData> a, /*nullable*/ shptr<class NavigationRailThemeData> b, /*non-null*/ double t) {
		auto m = ManagedCall("NavigationRailThemeData", "lerp");
		m.put("a", a);
		m.put("b", b);
		m.put("t", t);
		shptr<class NavigationRailThemeData> result;
		m.call(result);
		return result;
	}

	bool /*non-null*/ NavigationRailThemeData::equals(/*non-null*/ shptr<class ObjBase> other) {
		auto m = ManagedCall("NavigationRailThemeData", "==");
		m.put("this", this);
		m.put("other", other, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class NavigationRailThemeData> /*non-null*/ NavigationRailThemeData::ctorMain(_ctorMain p) {
		auto m = ManagedCall("NavigationRailThemeData", "NavigationRailThemeData");
		m.put("backgroundColor", p.backgroundColor);
		m.put("elevation", p.elevation);
		m.put("unselectedLabelTextStyle", p.unselectedLabelTextStyle);
		m.put("selectedLabelTextStyle", p.selectedLabelTextStyle);
		m.put("unselectedIconTheme", p.unselectedIconTheme);
		m.put("selectedIconTheme", p.selectedIconTheme);
		m.put("groupAlignment", p.groupAlignment);
		m.put("labelType", p.labelType);
		m.put("useIndicator", p.useIndicator);
		m.put("indicatorColor", p.indicatorColor);
		m.put("indicatorShape", p.indicatorShape);
		m.put("minWidth", p.minWidth);
		m.put("minExtendedWidth", p.minExtendedWidth);
		shptr<class NavigationRailThemeData> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class OutlinedButtonThemeData> /*var-non-null*/ OutlinedButtonTheme::data() {
		auto m = ManagedCall("OutlinedButtonTheme", "data");
		m.put("this", this);
		shptr<class OutlinedButtonThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class OutlinedButtonThemeData> /*non-null*/ OutlinedButtonTheme::of(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("OutlinedButtonTheme", "of");
		m.put("context", context, true);
		shptr<class OutlinedButtonThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Widget> /*non-null*/ OutlinedButtonTheme::wrap(/*non-null*/ shptr<class BuildContext> context, /*non-null*/ shptr<class Widget> child) {
		auto m = ManagedCall("OutlinedButtonTheme", "wrap");
		m.put("this", this);
		m.put("context", context, true);
		m.put("child", child, true);
		shptr<class Widget> result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ OutlinedButtonTheme::updateShouldNotify(/*non-null*/ shptr<class OutlinedButtonTheme> oldWidget) {
		auto m = ManagedCall("OutlinedButtonTheme", "updateShouldNotify");
		m.put("this", this);
		m.put("oldWidget", oldWidget, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class OutlinedButtonTheme> /*non-null*/ OutlinedButtonTheme::ctorMain(_ctorMain p) {
		auto m = ManagedCall("OutlinedButtonTheme", "OutlinedButtonTheme");
		m.put("key", p.key);
		m.put("data", p.data, true);
		m.put("child", p.child, true);
		shptr<class OutlinedButtonTheme> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class ButtonStyle> /*var-nullable*/ OutlinedButtonThemeData::style() {
		auto m = ManagedCall("OutlinedButtonThemeData", "style");
		m.put("this", this);
		shptr<class ButtonStyle> result;
		m.call(result);
		return result;
	}

	shptr<class OutlinedButtonThemeData> /*nullable*/ OutlinedButtonThemeData::lerp(/*nullable*/ shptr<class OutlinedButtonThemeData> a, /*nullable*/ shptr<class OutlinedButtonThemeData> b, /*non-null*/ double t) {
		auto m = ManagedCall("OutlinedButtonThemeData", "lerp");
		m.put("a", a);
		m.put("b", b);
		m.put("t", t);
		shptr<class OutlinedButtonThemeData> result;
		m.call(result);
		return result;
	}

	bool /*non-null*/ OutlinedButtonThemeData::equals(/*non-null*/ shptr<class ObjBase> other) {
		auto m = ManagedCall("OutlinedButtonThemeData", "==");
		m.put("this", this);
		m.put("other", other, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class OutlinedButtonThemeData> /*non-null*/ OutlinedButtonThemeData::ctorMain(_ctorMain p) {
		auto m = ManagedCall("OutlinedButtonThemeData", "OutlinedButtonThemeData");
		m.put("style", p.style);
		shptr<class OutlinedButtonThemeData> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Color> /*var-nullable*/ PopupMenuThemeData::color() {
		auto m = ManagedCall("PopupMenuThemeData", "color");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class ShapeBorder> /*var-nullable*/ PopupMenuThemeData::shape() {
		auto m = ManagedCall("PopupMenuThemeData", "shape");
		m.put("this", this);
		shptr<class ShapeBorder> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ PopupMenuThemeData::elevation() {
		auto m = ManagedCall("PopupMenuThemeData", "elevation");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ PopupMenuThemeData::shadowColor() {
		auto m = ManagedCall("PopupMenuThemeData", "shadowColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ PopupMenuThemeData::surfaceTintColor() {
		auto m = ManagedCall("PopupMenuThemeData", "surfaceTintColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class TextStyle> /*var-nullable*/ PopupMenuThemeData::textStyle() {
		auto m = ManagedCall("PopupMenuThemeData", "textStyle");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.call(result);
		return result;
	}

	stdop<bool> /*var-nullable*/ PopupMenuThemeData::enableFeedback() {
		auto m = ManagedCall("PopupMenuThemeData", "enableFeedback");
		m.put("this", this);
		stdop<bool> result;
		m.call(result);
		return result;
	}

	stdop<PopupMenuPosition> /*var-nullable*/ PopupMenuThemeData::position() {
		auto m = ManagedCall("PopupMenuThemeData", "position");
		m.put("this", this);
		stdop<PopupMenuPosition> result;
		m.call(result);
		return result;
	}

	shptr<class PopupMenuThemeData> /*non-null*/ PopupMenuThemeData::copyWith(_copyWith p) {
		auto m = ManagedCall("PopupMenuThemeData", "copyWith");
		m.put("this", this);
		m.put("color", p.color);
		m.put("shape", p.shape);
		m.put("elevation", p.elevation);
		m.put("shadowColor", p.shadowColor);
		m.put("surfaceTintColor", p.surfaceTintColor);
		m.put("textStyle", p.textStyle);
		m.put("labelTextStyle", p.labelTextStyle);
		m.put("enableFeedback", p.enableFeedback);
		m.put("mouseCursor", p.mouseCursor);
		m.put("position", p.position);
		shptr<class PopupMenuThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class PopupMenuThemeData> /*nullable*/ PopupMenuThemeData::lerp(/*nullable*/ shptr<class PopupMenuThemeData> a, /*nullable*/ shptr<class PopupMenuThemeData> b, /*non-null*/ double t) {
		auto m = ManagedCall("PopupMenuThemeData", "lerp");
		m.put("a", a);
		m.put("b", b);
		m.put("t", t);
		shptr<class PopupMenuThemeData> result;
		m.call(result);
		return result;
	}

	bool /*non-null*/ PopupMenuThemeData::equals(/*non-null*/ shptr<class ObjBase> other) {
		auto m = ManagedCall("PopupMenuThemeData", "==");
		m.put("this", this);
		m.put("other", other, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class PopupMenuThemeData> /*non-null*/ PopupMenuThemeData::ctorMain(_ctorMain p) {
		auto m = ManagedCall("PopupMenuThemeData", "PopupMenuThemeData");
		m.put("color", p.color);
		m.put("shape", p.shape);
		m.put("elevation", p.elevation);
		m.put("shadowColor", p.shadowColor);
		m.put("surfaceTintColor", p.surfaceTintColor);
		m.put("textStyle", p.textStyle);
		m.put("labelTextStyle", p.labelTextStyle);
		m.put("enableFeedback", p.enableFeedback);
		m.put("mouseCursor", p.mouseCursor);
		m.put("position", p.position);
		shptr<class PopupMenuThemeData> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class PopupMenuThemeData> /*var-non-null*/ PopupMenuTheme::data() {
		auto m = ManagedCall("PopupMenuTheme", "data");
		m.put("this", this);
		shptr<class PopupMenuThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class PopupMenuThemeData> /*non-null*/ PopupMenuTheme::of(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("PopupMenuTheme", "of");
		m.put("context", context, true);
		shptr<class PopupMenuThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Widget> /*non-null*/ PopupMenuTheme::wrap(/*non-null*/ shptr<class BuildContext> context, /*non-null*/ shptr<class Widget> child) {
		auto m = ManagedCall("PopupMenuTheme", "wrap");
		m.put("this", this);
		m.put("context", context, true);
		m.put("child", child, true);
		shptr<class Widget> result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ PopupMenuTheme::updateShouldNotify(/*non-null*/ shptr<class PopupMenuTheme> oldWidget) {
		auto m = ManagedCall("PopupMenuTheme", "updateShouldNotify");
		m.put("this", this);
		m.put("oldWidget", oldWidget, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class PopupMenuTheme> /*non-null*/ PopupMenuTheme::ctorMain(_ctorMain p) {
		auto m = ManagedCall("PopupMenuTheme", "PopupMenuTheme");
		m.put("key", p.key);
		m.put("data", p.data, true);
		m.put("child", p.child, true);
		shptr<class PopupMenuTheme> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class ProgressIndicatorThemeData> /*var-non-null*/ ProgressIndicatorTheme::data() {
		auto m = ManagedCall("ProgressIndicatorTheme", "data");
		m.put("this", this);
		shptr<class ProgressIndicatorThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ProgressIndicatorThemeData> /*non-null*/ ProgressIndicatorTheme::of(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("ProgressIndicatorTheme", "of");
		m.put("context", context, true);
		shptr<class ProgressIndicatorThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Widget> /*non-null*/ ProgressIndicatorTheme::wrap(/*non-null*/ shptr<class BuildContext> context, /*non-null*/ shptr<class Widget> child) {
		auto m = ManagedCall("ProgressIndicatorTheme", "wrap");
		m.put("this", this);
		m.put("context", context, true);
		m.put("child", child, true);
		shptr<class Widget> result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ ProgressIndicatorTheme::updateShouldNotify(/*non-null*/ shptr<class ProgressIndicatorTheme> oldWidget) {
		auto m = ManagedCall("ProgressIndicatorTheme", "updateShouldNotify");
		m.put("this", this);
		m.put("oldWidget", oldWidget, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ProgressIndicatorTheme> /*non-null*/ ProgressIndicatorTheme::ctorMain(_ctorMain p) {
		auto m = ManagedCall("ProgressIndicatorTheme", "ProgressIndicatorTheme");
		m.put("key", p.key);
		m.put("data", p.data, true);
		m.put("child", p.child, true);
		shptr<class ProgressIndicatorTheme> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Color> /*var-nullable*/ ProgressIndicatorThemeData::color() {
		auto m = ManagedCall("ProgressIndicatorThemeData", "color");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ ProgressIndicatorThemeData::linearTrackColor() {
		auto m = ManagedCall("ProgressIndicatorThemeData", "linearTrackColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ ProgressIndicatorThemeData::linearMinHeight() {
		auto m = ManagedCall("ProgressIndicatorThemeData", "linearMinHeight");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ ProgressIndicatorThemeData::circularTrackColor() {
		auto m = ManagedCall("ProgressIndicatorThemeData", "circularTrackColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ ProgressIndicatorThemeData::refreshBackgroundColor() {
		auto m = ManagedCall("ProgressIndicatorThemeData", "refreshBackgroundColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class ProgressIndicatorThemeData> /*non-null*/ ProgressIndicatorThemeData::copyWith(_copyWith p) {
		auto m = ManagedCall("ProgressIndicatorThemeData", "copyWith");
		m.put("this", this);
		m.put("color", p.color);
		m.put("linearTrackColor", p.linearTrackColor);
		m.put("linearMinHeight", p.linearMinHeight);
		m.put("circularTrackColor", p.circularTrackColor);
		m.put("refreshBackgroundColor", p.refreshBackgroundColor);
		shptr<class ProgressIndicatorThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ProgressIndicatorThemeData> /*nullable*/ ProgressIndicatorThemeData::lerp(/*nullable*/ shptr<class ProgressIndicatorThemeData> a, /*nullable*/ shptr<class ProgressIndicatorThemeData> b, /*non-null*/ double t) {
		auto m = ManagedCall("ProgressIndicatorThemeData", "lerp");
		m.put("a", a);
		m.put("b", b);
		m.put("t", t);
		shptr<class ProgressIndicatorThemeData> result;
		m.call(result);
		return result;
	}

	bool /*non-null*/ ProgressIndicatorThemeData::equals(/*non-null*/ shptr<class ObjBase> other) {
		auto m = ManagedCall("ProgressIndicatorThemeData", "==");
		m.put("this", this);
		m.put("other", other, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ProgressIndicatorThemeData> /*non-null*/ ProgressIndicatorThemeData::ctorMain(_ctorMain p) {
		auto m = ManagedCall("ProgressIndicatorThemeData", "ProgressIndicatorThemeData");
		m.put("color", p.color);
		m.put("linearTrackColor", p.linearTrackColor);
		m.put("linearMinHeight", p.linearMinHeight);
		m.put("circularTrackColor", p.circularTrackColor);
		m.put("refreshBackgroundColor", p.refreshBackgroundColor);
		shptr<class ProgressIndicatorThemeData> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class RadioThemeData> /*var-non-null*/ RadioTheme::data() {
		auto m = ManagedCall("RadioTheme", "data");
		m.put("this", this);
		shptr<class RadioThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class RadioThemeData> /*non-null*/ RadioTheme::of(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("RadioTheme", "of");
		m.put("context", context, true);
		shptr<class RadioThemeData> result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ RadioTheme::updateShouldNotify(/*non-null*/ shptr<class RadioTheme> oldWidget) {
		auto m = ManagedCall("RadioTheme", "updateShouldNotify");
		m.put("this", this);
		m.put("oldWidget", oldWidget, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class RadioTheme> /*non-null*/ RadioTheme::ctorMain(_ctorMain p) {
		auto m = ManagedCall("RadioTheme", "RadioTheme");
		m.put("key", p.key);
		m.put("data", p.data, true);
		m.put("child", p.child, true);
		shptr<class RadioTheme> result;
		m.check(m.call(result, true));
		return result;
	}

	stdop<double> /*var-nullable*/ RadioThemeData::splashRadius() {
		auto m = ManagedCall("RadioThemeData", "splashRadius");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	stdop<MaterialTapTargetSize> /*var-nullable*/ RadioThemeData::materialTapTargetSize() {
		auto m = ManagedCall("RadioThemeData", "materialTapTargetSize");
		m.put("this", this);
		stdop<MaterialTapTargetSize> result;
		m.call(result);
		return result;
	}

	shptr<class VisualDensity> /*var-nullable*/ RadioThemeData::visualDensity() {
		auto m = ManagedCall("RadioThemeData", "visualDensity");
		m.put("this", this);
		shptr<class VisualDensity> result;
		m.call(result);
		return result;
	}

	shptr<class RadioThemeData> /*non-null*/ RadioThemeData::copyWith(_copyWith p) {
		auto m = ManagedCall("RadioThemeData", "copyWith");
		m.put("this", this);
		m.put("mouseCursor", p.mouseCursor);
		m.put("fillColor", p.fillColor);
		m.put("overlayColor", p.overlayColor);
		m.put("splashRadius", p.splashRadius);
		m.put("materialTapTargetSize", p.materialTapTargetSize);
		m.put("visualDensity", p.visualDensity);
		shptr<class RadioThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class RadioThemeData> /*non-null*/ RadioThemeData::lerp(/*nullable*/ shptr<class RadioThemeData> a, /*nullable*/ shptr<class RadioThemeData> b, /*non-null*/ double t) {
		auto m = ManagedCall("RadioThemeData", "lerp");
		m.put("a", a);
		m.put("b", b);
		m.put("t", t);
		shptr<class RadioThemeData> result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ RadioThemeData::equals(/*non-null*/ shptr<class ObjBase> other) {
		auto m = ManagedCall("RadioThemeData", "==");
		m.put("this", this);
		m.put("other", other, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class RadioThemeData> /*non-null*/ RadioThemeData::ctorMain(_ctorMain p) {
		auto m = ManagedCall("RadioThemeData", "RadioThemeData");
		m.put("mouseCursor", p.mouseCursor);
		m.put("fillColor", p.fillColor);
		m.put("overlayColor", p.overlayColor);
		m.put("splashRadius", p.splashRadius);
		m.put("materialTapTargetSize", p.materialTapTargetSize);
		m.put("visualDensity", p.visualDensity);
		shptr<class RadioThemeData> result;
		m.check(m.call(result, true));
		return result;
	}

	stdop<bool> /*var-nullable*/ ScrollbarThemeData::showTrackOnHover() {
		auto m = ManagedCall("ScrollbarThemeData", "showTrackOnHover");
		m.put("this", this);
		stdop<bool> result;
		m.call(result);
		return result;
	}

	stdop<bool> /*var-nullable*/ ScrollbarThemeData::interactive() {
		auto m = ManagedCall("ScrollbarThemeData", "interactive");
		m.put("this", this);
		stdop<bool> result;
		m.call(result);
		return result;
	}

	shptr<class Radius> /*var-nullable*/ ScrollbarThemeData::radius() {
		auto m = ManagedCall("ScrollbarThemeData", "radius");
		m.put("this", this);
		shptr<class Radius> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ ScrollbarThemeData::crossAxisMargin() {
		auto m = ManagedCall("ScrollbarThemeData", "crossAxisMargin");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ ScrollbarThemeData::mainAxisMargin() {
		auto m = ManagedCall("ScrollbarThemeData", "mainAxisMargin");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ ScrollbarThemeData::minThumbLength() {
		auto m = ManagedCall("ScrollbarThemeData", "minThumbLength");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	shptr<class ScrollbarThemeData> /*non-null*/ ScrollbarThemeData::copyWith(_copyWith p) {
		auto m = ManagedCall("ScrollbarThemeData", "copyWith");
		m.put("this", this);
		m.put("thumbVisibility", p.thumbVisibility);
		m.put("thickness", p.thickness);
		m.put("trackVisibility", p.trackVisibility);
		m.put("interactive", p.interactive);
		m.put("radius", p.radius);
		m.put("thumbColor", p.thumbColor);
		m.put("trackColor", p.trackColor);
		m.put("trackBorderColor", p.trackBorderColor);
		m.put("crossAxisMargin", p.crossAxisMargin);
		m.put("mainAxisMargin", p.mainAxisMargin);
		m.put("minThumbLength", p.minThumbLength);
		m.put("showTrackOnHover", p.showTrackOnHover);
		shptr<class ScrollbarThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ScrollbarThemeData> /*non-null*/ ScrollbarThemeData::lerp(/*nullable*/ shptr<class ScrollbarThemeData> a, /*nullable*/ shptr<class ScrollbarThemeData> b, /*non-null*/ double t) {
		auto m = ManagedCall("ScrollbarThemeData", "lerp");
		m.put("a", a);
		m.put("b", b);
		m.put("t", t);
		shptr<class ScrollbarThemeData> result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ ScrollbarThemeData::equals(/*non-null*/ shptr<class ObjBase> other) {
		auto m = ManagedCall("ScrollbarThemeData", "==");
		m.put("this", this);
		m.put("other", other, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ScrollbarThemeData> /*non-null*/ ScrollbarThemeData::ctorMain(_ctorMain p) {
		auto m = ManagedCall("ScrollbarThemeData", "ScrollbarThemeData");
		m.put("thumbVisibility", p.thumbVisibility);
		m.put("thickness", p.thickness);
		m.put("trackVisibility", p.trackVisibility);
		m.put("radius", p.radius);
		m.put("thumbColor", p.thumbColor);
		m.put("trackColor", p.trackColor);
		m.put("trackBorderColor", p.trackBorderColor);
		m.put("crossAxisMargin", p.crossAxisMargin);
		m.put("mainAxisMargin", p.mainAxisMargin);
		m.put("minThumbLength", p.minThumbLength);
		m.put("interactive", p.interactive);
		m.put("showTrackOnHover", p.showTrackOnHover);
		shptr<class ScrollbarThemeData> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class ScrollbarThemeData> /*var-non-null*/ ScrollbarTheme::data() {
		auto m = ManagedCall("ScrollbarTheme", "data");
		m.put("this", this);
		shptr<class ScrollbarThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ScrollbarThemeData> /*non-null*/ ScrollbarTheme::of(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("ScrollbarTheme", "of");
		m.put("context", context, true);
		shptr<class ScrollbarThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Widget> /*non-null*/ ScrollbarTheme::wrap(/*non-null*/ shptr<class BuildContext> context, /*non-null*/ shptr<class Widget> child) {
		auto m = ManagedCall("ScrollbarTheme", "wrap");
		m.put("this", this);
		m.put("context", context, true);
		m.put("child", child, true);
		shptr<class Widget> result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ ScrollbarTheme::updateShouldNotify(/*non-null*/ shptr<class ScrollbarTheme> oldWidget) {
		auto m = ManagedCall("ScrollbarTheme", "updateShouldNotify");
		m.put("this", this);
		m.put("oldWidget", oldWidget, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ScrollbarTheme> /*non-null*/ ScrollbarTheme::ctorMain(_ctorMain p) {
		auto m = ManagedCall("ScrollbarTheme", "ScrollbarTheme");
		m.put("key", p.key);
		m.put("data", p.data, true);
		m.put("child", p.child, true);
		shptr<class ScrollbarTheme> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class BoxConstraints> /*var-nullable*/ SearchBarThemeData::constraints() {
		auto m = ManagedCall("SearchBarThemeData", "constraints");
		m.put("this", this);
		shptr<class BoxConstraints> result;
		m.call(result);
		return result;
	}

	shptr<class SearchBarThemeData> /*non-null*/ SearchBarThemeData::copyWith(_copyWith p) {
		auto m = ManagedCall("SearchBarThemeData", "copyWith");
		m.put("this", this);
		m.put("elevation", p.elevation);
		m.put("backgroundColor", p.backgroundColor);
		m.put("shadowColor", p.shadowColor);
		m.put("surfaceTintColor", p.surfaceTintColor);
		m.put("overlayColor", p.overlayColor);
		m.put("side", p.side);
		m.put("shape", p.shape);
		m.put("padding", p.padding);
		m.put("textStyle", p.textStyle);
		m.put("hintStyle", p.hintStyle);
		m.put("constraints", p.constraints);
		shptr<class SearchBarThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class SearchBarThemeData> /*nullable*/ SearchBarThemeData::lerp(/*nullable*/ shptr<class SearchBarThemeData> a, /*nullable*/ shptr<class SearchBarThemeData> b, /*non-null*/ double t) {
		auto m = ManagedCall("SearchBarThemeData", "lerp");
		m.put("a", a);
		m.put("b", b);
		m.put("t", t);
		shptr<class SearchBarThemeData> result;
		m.call(result);
		return result;
	}

	bool /*non-null*/ SearchBarThemeData::equals(/*non-null*/ shptr<class ObjBase> other) {
		auto m = ManagedCall("SearchBarThemeData", "==");
		m.put("this", this);
		m.put("other", other, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class SearchBarThemeData> /*non-null*/ SearchBarThemeData::ctorMain(_ctorMain p) {
		auto m = ManagedCall("SearchBarThemeData", "SearchBarThemeData");
		m.put("elevation", p.elevation);
		m.put("backgroundColor", p.backgroundColor);
		m.put("shadowColor", p.shadowColor);
		m.put("surfaceTintColor", p.surfaceTintColor);
		m.put("overlayColor", p.overlayColor);
		m.put("side", p.side);
		m.put("shape", p.shape);
		m.put("padding", p.padding);
		m.put("textStyle", p.textStyle);
		m.put("hintStyle", p.hintStyle);
		m.put("constraints", p.constraints);
		shptr<class SearchBarThemeData> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class SearchBarThemeData> /*var-non-null*/ SearchBarTheme::data() {
		auto m = ManagedCall("SearchBarTheme", "data");
		m.put("this", this);
		shptr<class SearchBarThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class SearchBarThemeData> /*non-null*/ SearchBarTheme::of(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("SearchBarTheme", "of");
		m.put("context", context, true);
		shptr<class SearchBarThemeData> result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ SearchBarTheme::updateShouldNotify(/*non-null*/ shptr<class SearchBarTheme> oldWidget) {
		auto m = ManagedCall("SearchBarTheme", "updateShouldNotify");
		m.put("this", this);
		m.put("oldWidget", oldWidget, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class SearchBarTheme> /*non-null*/ SearchBarTheme::ctorMain(_ctorMain p) {
		auto m = ManagedCall("SearchBarTheme", "SearchBarTheme");
		m.put("key", p.key);
		m.put("data", p.data, true);
		m.put("child", p.child, true);
		shptr<class SearchBarTheme> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class SearchViewThemeData> /*var-non-null*/ SearchViewTheme::data() {
		auto m = ManagedCall("SearchViewTheme", "data");
		m.put("this", this);
		shptr<class SearchViewThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class SearchViewThemeData> /*non-null*/ SearchViewTheme::of(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("SearchViewTheme", "of");
		m.put("context", context, true);
		shptr<class SearchViewThemeData> result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ SearchViewTheme::updateShouldNotify(/*non-null*/ shptr<class SearchViewTheme> oldWidget) {
		auto m = ManagedCall("SearchViewTheme", "updateShouldNotify");
		m.put("this", this);
		m.put("oldWidget", oldWidget, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class SearchViewTheme> /*non-null*/ SearchViewTheme::ctorMain(_ctorMain p) {
		auto m = ManagedCall("SearchViewTheme", "SearchViewTheme");
		m.put("key", p.key);
		m.put("data", p.data, true);
		m.put("child", p.child, true);
		shptr<class SearchViewTheme> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Color> /*var-nullable*/ SearchViewThemeData::backgroundColor() {
		auto m = ManagedCall("SearchViewThemeData", "backgroundColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ SearchViewThemeData::elevation() {
		auto m = ManagedCall("SearchViewThemeData", "elevation");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ SearchViewThemeData::surfaceTintColor() {
		auto m = ManagedCall("SearchViewThemeData", "surfaceTintColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class BorderSide> /*var-nullable*/ SearchViewThemeData::side() {
		auto m = ManagedCall("SearchViewThemeData", "side");
		m.put("this", this);
		shptr<class BorderSide> result;
		m.call(result);
		return result;
	}

	shptr<class OutlinedBorder> /*var-nullable*/ SearchViewThemeData::shape() {
		auto m = ManagedCall("SearchViewThemeData", "shape");
		m.put("this", this);
		shptr<class OutlinedBorder> result;
		m.call(result);
		return result;
	}

	shptr<class TextStyle> /*var-nullable*/ SearchViewThemeData::headerTextStyle() {
		auto m = ManagedCall("SearchViewThemeData", "headerTextStyle");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.call(result);
		return result;
	}

	shptr<class TextStyle> /*var-nullable*/ SearchViewThemeData::headerHintStyle() {
		auto m = ManagedCall("SearchViewThemeData", "headerHintStyle");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.call(result);
		return result;
	}

	shptr<class BoxConstraints> /*var-nullable*/ SearchViewThemeData::constraints() {
		auto m = ManagedCall("SearchViewThemeData", "constraints");
		m.put("this", this);
		shptr<class BoxConstraints> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ SearchViewThemeData::dividerColor() {
		auto m = ManagedCall("SearchViewThemeData", "dividerColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class SearchViewThemeData> /*non-null*/ SearchViewThemeData::copyWith(_copyWith p) {
		auto m = ManagedCall("SearchViewThemeData", "copyWith");
		m.put("this", this);
		m.put("backgroundColor", p.backgroundColor);
		m.put("elevation", p.elevation);
		m.put("surfaceTintColor", p.surfaceTintColor);
		m.put("side", p.side);
		m.put("shape", p.shape);
		m.put("headerTextStyle", p.headerTextStyle);
		m.put("headerHintStyle", p.headerHintStyle);
		m.put("constraints", p.constraints);
		m.put("dividerColor", p.dividerColor);
		shptr<class SearchViewThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class SearchViewThemeData> /*nullable*/ SearchViewThemeData::lerp(/*nullable*/ shptr<class SearchViewThemeData> a, /*nullable*/ shptr<class SearchViewThemeData> b, /*non-null*/ double t) {
		auto m = ManagedCall("SearchViewThemeData", "lerp");
		m.put("a", a);
		m.put("b", b);
		m.put("t", t);
		shptr<class SearchViewThemeData> result;
		m.call(result);
		return result;
	}

	bool /*non-null*/ SearchViewThemeData::equals(/*non-null*/ shptr<class ObjBase> other) {
		auto m = ManagedCall("SearchViewThemeData", "==");
		m.put("this", this);
		m.put("other", other, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class SearchViewThemeData> /*non-null*/ SearchViewThemeData::ctorMain(_ctorMain p) {
		auto m = ManagedCall("SearchViewThemeData", "SearchViewThemeData");
		m.put("backgroundColor", p.backgroundColor);
		m.put("elevation", p.elevation);
		m.put("surfaceTintColor", p.surfaceTintColor);
		m.put("constraints", p.constraints);
		m.put("side", p.side);
		m.put("shape", p.shape);
		m.put("headerTextStyle", p.headerTextStyle);
		m.put("headerHintStyle", p.headerHintStyle);
		m.put("dividerColor", p.dividerColor);
		shptr<class SearchViewThemeData> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class SegmentedButtonThemeData> /*var-non-null*/ SegmentedButtonTheme::data() {
		auto m = ManagedCall("SegmentedButtonTheme", "data");
		m.put("this", this);
		shptr<class SegmentedButtonThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class SegmentedButtonThemeData> /*non-null*/ SegmentedButtonTheme::of(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("SegmentedButtonTheme", "of");
		m.put("context", context, true);
		shptr<class SegmentedButtonThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class SegmentedButtonThemeData> /*nullable*/ SegmentedButtonTheme::maybeOf(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("SegmentedButtonTheme", "maybeOf");
		m.put("context", context, true);
		shptr<class SegmentedButtonThemeData> result;
		m.call(result);
		return result;
	}

	shptr<class Widget> /*non-null*/ SegmentedButtonTheme::wrap(/*non-null*/ shptr<class BuildContext> context, /*non-null*/ shptr<class Widget> child) {
		auto m = ManagedCall("SegmentedButtonTheme", "wrap");
		m.put("this", this);
		m.put("context", context, true);
		m.put("child", child, true);
		shptr<class Widget> result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ SegmentedButtonTheme::updateShouldNotify(/*non-null*/ shptr<class SegmentedButtonTheme> oldWidget) {
		auto m = ManagedCall("SegmentedButtonTheme", "updateShouldNotify");
		m.put("this", this);
		m.put("oldWidget", oldWidget, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class SegmentedButtonTheme> /*non-null*/ SegmentedButtonTheme::ctorMain(_ctorMain p) {
		auto m = ManagedCall("SegmentedButtonTheme", "SegmentedButtonTheme");
		m.put("key", p.key);
		m.put("data", p.data, true);
		m.put("child", p.child, true);
		shptr<class SegmentedButtonTheme> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class ButtonStyle> /*var-nullable*/ SegmentedButtonThemeData::style() {
		auto m = ManagedCall("SegmentedButtonThemeData", "style");
		m.put("this", this);
		shptr<class ButtonStyle> result;
		m.call(result);
		return result;
	}

	shptr<class Widget> /*var-nullable*/ SegmentedButtonThemeData::selectedIcon() {
		auto m = ManagedCall("SegmentedButtonThemeData", "selectedIcon");
		m.put("this", this);
		shptr<class Widget> result;
		m.call(result);
		return result;
	}

	shptr<class SegmentedButtonThemeData> /*non-null*/ SegmentedButtonThemeData::copyWith(_copyWith p) {
		auto m = ManagedCall("SegmentedButtonThemeData", "copyWith");
		m.put("this", this);
		m.put("style", p.style);
		m.put("selectedIcon", p.selectedIcon);
		shptr<class SegmentedButtonThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class SegmentedButtonThemeData> /*non-null*/ SegmentedButtonThemeData::lerp(/*nullable*/ shptr<class SegmentedButtonThemeData> a, /*nullable*/ shptr<class SegmentedButtonThemeData> b, /*non-null*/ double t) {
		auto m = ManagedCall("SegmentedButtonThemeData", "lerp");
		m.put("a", a);
		m.put("b", b);
		m.put("t", t);
		shptr<class SegmentedButtonThemeData> result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ SegmentedButtonThemeData::equals(/*non-null*/ shptr<class ObjBase> other) {
		auto m = ManagedCall("SegmentedButtonThemeData", "==");
		m.put("this", this);
		m.put("other", other, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class SegmentedButtonThemeData> /*non-null*/ SegmentedButtonThemeData::ctorMain(_ctorMain p) {
		auto m = ManagedCall("SegmentedButtonThemeData", "SegmentedButtonThemeData");
		m.put("style", p.style);
		m.put("selectedIcon", p.selectedIcon);
		shptr<class SegmentedButtonThemeData> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class SliderThemeData> /*var-non-null*/ SliderTheme::data() {
		auto m = ManagedCall("SliderTheme", "data");
		m.put("this", this);
		shptr<class SliderThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class SliderThemeData> /*non-null*/ SliderTheme::of(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("SliderTheme", "of");
		m.put("context", context, true);
		shptr<class SliderThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Widget> /*non-null*/ SliderTheme::wrap(/*non-null*/ shptr<class BuildContext> context, /*non-null*/ shptr<class Widget> child) {
		auto m = ManagedCall("SliderTheme", "wrap");
		m.put("this", this);
		m.put("context", context, true);
		m.put("child", child, true);
		shptr<class Widget> result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ SliderTheme::updateShouldNotify(/*non-null*/ shptr<class SliderTheme> oldWidget) {
		auto m = ManagedCall("SliderTheme", "updateShouldNotify");
		m.put("this", this);
		m.put("oldWidget", oldWidget, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class SliderTheme> /*non-null*/ SliderTheme::ctorMain(_ctorMain p) {
		auto m = ManagedCall("SliderTheme", "SliderTheme");
		m.put("key", p.key);
		m.put("data", p.data, true);
		m.put("child", p.child, true);
		shptr<class SliderTheme> result;
		m.check(m.call(result, true));
		return result;
	}

	stdop<double> /*var-nullable*/ SliderThemeData::trackHeight() {
		auto m = ManagedCall("SliderThemeData", "trackHeight");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ SliderThemeData::activeTrackColor() {
		auto m = ManagedCall("SliderThemeData", "activeTrackColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ SliderThemeData::inactiveTrackColor() {
		auto m = ManagedCall("SliderThemeData", "inactiveTrackColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ SliderThemeData::secondaryActiveTrackColor() {
		auto m = ManagedCall("SliderThemeData", "secondaryActiveTrackColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ SliderThemeData::disabledActiveTrackColor() {
		auto m = ManagedCall("SliderThemeData", "disabledActiveTrackColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ SliderThemeData::disabledSecondaryActiveTrackColor() {
		auto m = ManagedCall("SliderThemeData", "disabledSecondaryActiveTrackColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ SliderThemeData::disabledInactiveTrackColor() {
		auto m = ManagedCall("SliderThemeData", "disabledInactiveTrackColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ SliderThemeData::activeTickMarkColor() {
		auto m = ManagedCall("SliderThemeData", "activeTickMarkColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ SliderThemeData::inactiveTickMarkColor() {
		auto m = ManagedCall("SliderThemeData", "inactiveTickMarkColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ SliderThemeData::disabledActiveTickMarkColor() {
		auto m = ManagedCall("SliderThemeData", "disabledActiveTickMarkColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ SliderThemeData::disabledInactiveTickMarkColor() {
		auto m = ManagedCall("SliderThemeData", "disabledInactiveTickMarkColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ SliderThemeData::thumbColor() {
		auto m = ManagedCall("SliderThemeData", "thumbColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ SliderThemeData::overlappingShapeStrokeColor() {
		auto m = ManagedCall("SliderThemeData", "overlappingShapeStrokeColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ SliderThemeData::disabledThumbColor() {
		auto m = ManagedCall("SliderThemeData", "disabledThumbColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ SliderThemeData::overlayColor() {
		auto m = ManagedCall("SliderThemeData", "overlayColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ SliderThemeData::valueIndicatorColor() {
		auto m = ManagedCall("SliderThemeData", "valueIndicatorColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class SliderComponentShape> /*var-nullable*/ SliderThemeData::overlayShape() {
		auto m = ManagedCall("SliderThemeData", "overlayShape");
		m.put("this", this);
		shptr<class SliderComponentShape> result;
		m.call(result);
		return result;
	}

	shptr<class SliderTickMarkShape> /*var-nullable*/ SliderThemeData::tickMarkShape() {
		auto m = ManagedCall("SliderThemeData", "tickMarkShape");
		m.put("this", this);
		shptr<class SliderTickMarkShape> result;
		m.call(result);
		return result;
	}

	shptr<class SliderComponentShape> /*var-nullable*/ SliderThemeData::thumbShape() {
		auto m = ManagedCall("SliderThemeData", "thumbShape");
		m.put("this", this);
		shptr<class SliderComponentShape> result;
		m.call(result);
		return result;
	}

	shptr<class SliderTrackShape> /*var-nullable*/ SliderThemeData::trackShape() {
		auto m = ManagedCall("SliderThemeData", "trackShape");
		m.put("this", this);
		shptr<class SliderTrackShape> result;
		m.call(result);
		return result;
	}

	shptr<class SliderComponentShape> /*var-nullable*/ SliderThemeData::valueIndicatorShape() {
		auto m = ManagedCall("SliderThemeData", "valueIndicatorShape");
		m.put("this", this);
		shptr<class SliderComponentShape> result;
		m.call(result);
		return result;
	}

	shptr<class RangeSliderTickMarkShape> /*var-nullable*/ SliderThemeData::rangeTickMarkShape() {
		auto m = ManagedCall("SliderThemeData", "rangeTickMarkShape");
		m.put("this", this);
		shptr<class RangeSliderTickMarkShape> result;
		m.call(result);
		return result;
	}

	shptr<class RangeSliderThumbShape> /*var-nullable*/ SliderThemeData::rangeThumbShape() {
		auto m = ManagedCall("SliderThemeData", "rangeThumbShape");
		m.put("this", this);
		shptr<class RangeSliderThumbShape> result;
		m.call(result);
		return result;
	}

	shptr<class RangeSliderTrackShape> /*var-nullable*/ SliderThemeData::rangeTrackShape() {
		auto m = ManagedCall("SliderThemeData", "rangeTrackShape");
		m.put("this", this);
		shptr<class RangeSliderTrackShape> result;
		m.call(result);
		return result;
	}

	shptr<class RangeSliderValueIndicatorShape> /*var-nullable*/ SliderThemeData::rangeValueIndicatorShape() {
		auto m = ManagedCall("SliderThemeData", "rangeValueIndicatorShape");
		m.put("this", this);
		shptr<class RangeSliderValueIndicatorShape> result;
		m.call(result);
		return result;
	}

	stdop<ShowValueIndicator> /*var-nullable*/ SliderThemeData::showValueIndicator() {
		auto m = ManagedCall("SliderThemeData", "showValueIndicator");
		m.put("this", this);
		stdop<ShowValueIndicator> result;
		m.call(result);
		return result;
	}

	shptr<class TextStyle> /*var-nullable*/ SliderThemeData::valueIndicatorTextStyle() {
		auto m = ManagedCall("SliderThemeData", "valueIndicatorTextStyle");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ SliderThemeData::minThumbSeparation() {
		auto m = ManagedCall("SliderThemeData", "minThumbSeparation");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	stdop<SliderInteraction> /*var-nullable*/ SliderThemeData::allowedInteraction() {
		auto m = ManagedCall("SliderThemeData", "allowedInteraction");
		m.put("this", this);
		stdop<SliderInteraction> result;
		m.call(result);
		return result;
	}

	shptr<class SliderThemeData> /*non-null*/ SliderThemeData::copyWith(_copyWith p) {
		auto m = ManagedCall("SliderThemeData", "copyWith");
		m.put("this", this);
		m.put("trackHeight", p.trackHeight);
		m.put("activeTrackColor", p.activeTrackColor);
		m.put("inactiveTrackColor", p.inactiveTrackColor);
		m.put("secondaryActiveTrackColor", p.secondaryActiveTrackColor);
		m.put("disabledActiveTrackColor", p.disabledActiveTrackColor);
		m.put("disabledInactiveTrackColor", p.disabledInactiveTrackColor);
		m.put("disabledSecondaryActiveTrackColor", p.disabledSecondaryActiveTrackColor);
		m.put("activeTickMarkColor", p.activeTickMarkColor);
		m.put("inactiveTickMarkColor", p.inactiveTickMarkColor);
		m.put("disabledActiveTickMarkColor", p.disabledActiveTickMarkColor);
		m.put("disabledInactiveTickMarkColor", p.disabledInactiveTickMarkColor);
		m.put("thumbColor", p.thumbColor);
		m.put("overlappingShapeStrokeColor", p.overlappingShapeStrokeColor);
		m.put("disabledThumbColor", p.disabledThumbColor);
		m.put("overlayColor", p.overlayColor);
		m.put("valueIndicatorColor", p.valueIndicatorColor);
		m.put("overlayShape", p.overlayShape);
		m.put("tickMarkShape", p.tickMarkShape);
		m.put("thumbShape", p.thumbShape);
		m.put("trackShape", p.trackShape);
		m.put("valueIndicatorShape", p.valueIndicatorShape);
		m.put("rangeTickMarkShape", p.rangeTickMarkShape);
		m.put("rangeThumbShape", p.rangeThumbShape);
		m.put("rangeTrackShape", p.rangeTrackShape);
		m.put("rangeValueIndicatorShape", p.rangeValueIndicatorShape);
		m.put("showValueIndicator", p.showValueIndicator);
		m.put("valueIndicatorTextStyle", p.valueIndicatorTextStyle);
		m.put("minThumbSeparation", p.minThumbSeparation);
//		m.put("thumbSelector", p.thumbSelector);
		m.put("mouseCursor", p.mouseCursor);
		m.put("allowedInteraction", p.allowedInteraction);
		shptr<class SliderThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class SliderThemeData> /*non-null*/ SliderThemeData::lerp(/*non-null*/ shptr<class SliderThemeData> a, /*non-null*/ shptr<class SliderThemeData> b, /*non-null*/ double t) {
		auto m = ManagedCall("SliderThemeData", "lerp");
		m.put("a", a, true);
		m.put("b", b, true);
		m.put("t", t);
		shptr<class SliderThemeData> result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ SliderThemeData::equals(/*non-null*/ shptr<class ObjBase> other) {
		auto m = ManagedCall("SliderThemeData", "==");
		m.put("this", this);
		m.put("other", other, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class SliderThemeData> /*non-null*/ SliderThemeData::ctorMain(_ctorMain p) {
		auto m = ManagedCall("SliderThemeData", "SliderThemeData");
		m.put("trackHeight", p.trackHeight);
		m.put("activeTrackColor", p.activeTrackColor);
		m.put("inactiveTrackColor", p.inactiveTrackColor);
		m.put("secondaryActiveTrackColor", p.secondaryActiveTrackColor);
		m.put("disabledActiveTrackColor", p.disabledActiveTrackColor);
		m.put("disabledInactiveTrackColor", p.disabledInactiveTrackColor);
		m.put("disabledSecondaryActiveTrackColor", p.disabledSecondaryActiveTrackColor);
		m.put("activeTickMarkColor", p.activeTickMarkColor);
		m.put("inactiveTickMarkColor", p.inactiveTickMarkColor);
		m.put("disabledActiveTickMarkColor", p.disabledActiveTickMarkColor);
		m.put("disabledInactiveTickMarkColor", p.disabledInactiveTickMarkColor);
		m.put("thumbColor", p.thumbColor);
		m.put("overlappingShapeStrokeColor", p.overlappingShapeStrokeColor);
		m.put("disabledThumbColor", p.disabledThumbColor);
		m.put("overlayColor", p.overlayColor);
		m.put("valueIndicatorColor", p.valueIndicatorColor);
		m.put("overlayShape", p.overlayShape);
		m.put("tickMarkShape", p.tickMarkShape);
		m.put("thumbShape", p.thumbShape);
		m.put("trackShape", p.trackShape);
		m.put("valueIndicatorShape", p.valueIndicatorShape);
		m.put("rangeTickMarkShape", p.rangeTickMarkShape);
		m.put("rangeThumbShape", p.rangeThumbShape);
		m.put("rangeTrackShape", p.rangeTrackShape);
		m.put("rangeValueIndicatorShape", p.rangeValueIndicatorShape);
		m.put("showValueIndicator", p.showValueIndicator);
		m.put("valueIndicatorTextStyle", p.valueIndicatorTextStyle);
		m.put("minThumbSeparation", p.minThumbSeparation);
//		m.put("thumbSelector", p.thumbSelector);
		m.put("mouseCursor", p.mouseCursor);
		m.put("allowedInteraction", p.allowedInteraction);
		shptr<class SliderThemeData> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class SliderThemeData> /*non-null*/ SliderThemeData::fromPrimaryColors(_fromPrimaryColors p) {
		auto m = ManagedCall("SliderThemeData", "fromPrimaryColors");
		m.put("primaryColor", p.primaryColor, true);
		m.put("primaryColorDark", p.primaryColorDark, true);
		m.put("primaryColorLight", p.primaryColorLight, true);
		m.put("valueIndicatorTextStyle", p.valueIndicatorTextStyle, true);
		shptr<class SliderThemeData> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Color> /*var-nullable*/ SnackBarThemeData::backgroundColor() {
		auto m = ManagedCall("SnackBarThemeData", "backgroundColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ SnackBarThemeData::actionTextColor() {
		auto m = ManagedCall("SnackBarThemeData", "actionTextColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ SnackBarThemeData::disabledActionTextColor() {
		auto m = ManagedCall("SnackBarThemeData", "disabledActionTextColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class TextStyle> /*var-nullable*/ SnackBarThemeData::contentTextStyle() {
		auto m = ManagedCall("SnackBarThemeData", "contentTextStyle");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ SnackBarThemeData::elevation() {
		auto m = ManagedCall("SnackBarThemeData", "elevation");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	shptr<class ShapeBorder> /*var-nullable*/ SnackBarThemeData::shape() {
		auto m = ManagedCall("SnackBarThemeData", "shape");
		m.put("this", this);
		shptr<class ShapeBorder> result;
		m.call(result);
		return result;
	}

	stdop<SnackBarBehavior> /*var-nullable*/ SnackBarThemeData::behavior() {
		auto m = ManagedCall("SnackBarThemeData", "behavior");
		m.put("this", this);
		stdop<SnackBarBehavior> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ SnackBarThemeData::width() {
		auto m = ManagedCall("SnackBarThemeData", "width");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	shptr<class EdgeInsets> /*var-nullable*/ SnackBarThemeData::insetPadding() {
		auto m = ManagedCall("SnackBarThemeData", "insetPadding");
		m.put("this", this);
		shptr<class EdgeInsets> result;
		m.call(result);
		return result;
	}

	stdop<bool> /*var-nullable*/ SnackBarThemeData::showCloseIcon() {
		auto m = ManagedCall("SnackBarThemeData", "showCloseIcon");
		m.put("this", this);
		stdop<bool> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ SnackBarThemeData::closeIconColor() {
		auto m = ManagedCall("SnackBarThemeData", "closeIconColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ SnackBarThemeData::actionOverflowThreshold() {
		auto m = ManagedCall("SnackBarThemeData", "actionOverflowThreshold");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ SnackBarThemeData::actionBackgroundColor() {
		auto m = ManagedCall("SnackBarThemeData", "actionBackgroundColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ SnackBarThemeData::disabledActionBackgroundColor() {
		auto m = ManagedCall("SnackBarThemeData", "disabledActionBackgroundColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class SnackBarThemeData> /*non-null*/ SnackBarThemeData::copyWith(_copyWith p) {
		auto m = ManagedCall("SnackBarThemeData", "copyWith");
		m.put("this", this);
		m.put("backgroundColor", p.backgroundColor);
		m.put("actionTextColor", p.actionTextColor);
		m.put("disabledActionTextColor", p.disabledActionTextColor);
		m.put("contentTextStyle", p.contentTextStyle);
		m.put("elevation", p.elevation);
		m.put("shape", p.shape);
		m.put("behavior", p.behavior);
		m.put("width", p.width);
		m.put("insetPadding", p.insetPadding);
		m.put("showCloseIcon", p.showCloseIcon);
		m.put("closeIconColor", p.closeIconColor);
		m.put("actionOverflowThreshold", p.actionOverflowThreshold);
		m.put("actionBackgroundColor", p.actionBackgroundColor);
		m.put("disabledActionBackgroundColor", p.disabledActionBackgroundColor);
		shptr<class SnackBarThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class SnackBarThemeData> /*non-null*/ SnackBarThemeData::lerp(/*nullable*/ shptr<class SnackBarThemeData> a, /*nullable*/ shptr<class SnackBarThemeData> b, /*non-null*/ double t) {
		auto m = ManagedCall("SnackBarThemeData", "lerp");
		m.put("a", a);
		m.put("b", b);
		m.put("t", t);
		shptr<class SnackBarThemeData> result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ SnackBarThemeData::equals(/*non-null*/ shptr<class ObjBase> other) {
		auto m = ManagedCall("SnackBarThemeData", "==");
		m.put("this", this);
		m.put("other", other, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class SnackBarThemeData> /*non-null*/ SnackBarThemeData::ctorMain(_ctorMain p) {
		auto m = ManagedCall("SnackBarThemeData", "SnackBarThemeData");
		m.put("backgroundColor", p.backgroundColor);
		m.put("actionTextColor", p.actionTextColor);
		m.put("disabledActionTextColor", p.disabledActionTextColor);
		m.put("contentTextStyle", p.contentTextStyle);
		m.put("elevation", p.elevation);
		m.put("shape", p.shape);
		m.put("behavior", p.behavior);
		m.put("width", p.width);
		m.put("insetPadding", p.insetPadding);
		m.put("showCloseIcon", p.showCloseIcon);
		m.put("closeIconColor", p.closeIconColor);
		m.put("actionOverflowThreshold", p.actionOverflowThreshold);
		m.put("actionBackgroundColor", p.actionBackgroundColor);
		m.put("disabledActionBackgroundColor", p.disabledActionBackgroundColor);
		shptr<class SnackBarThemeData> result;
		m.check(m.call(result, true));
		return result;
	}

	stdop<MaterialTapTargetSize> /*var-nullable*/ SwitchThemeData::materialTapTargetSize() {
		auto m = ManagedCall("SwitchThemeData", "materialTapTargetSize");
		m.put("this", this);
		stdop<MaterialTapTargetSize> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ SwitchThemeData::splashRadius() {
		auto m = ManagedCall("SwitchThemeData", "splashRadius");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	shptr<class SwitchThemeData> /*non-null*/ SwitchThemeData::copyWith(_copyWith p) {
		auto m = ManagedCall("SwitchThemeData", "copyWith");
		m.put("this", this);
		m.put("thumbColor", p.thumbColor);
		m.put("trackColor", p.trackColor);
		m.put("trackOutlineColor", p.trackOutlineColor);
		m.put("trackOutlineWidth", p.trackOutlineWidth);
		m.put("materialTapTargetSize", p.materialTapTargetSize);
		m.put("mouseCursor", p.mouseCursor);
		m.put("overlayColor", p.overlayColor);
		m.put("splashRadius", p.splashRadius);
		m.put("thumbIcon", p.thumbIcon);
		shptr<class SwitchThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class SwitchThemeData> /*non-null*/ SwitchThemeData::lerp(/*nullable*/ shptr<class SwitchThemeData> a, /*nullable*/ shptr<class SwitchThemeData> b, /*non-null*/ double t) {
		auto m = ManagedCall("SwitchThemeData", "lerp");
		m.put("a", a);
		m.put("b", b);
		m.put("t", t);
		shptr<class SwitchThemeData> result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ SwitchThemeData::equals(/*non-null*/ shptr<class ObjBase> other) {
		auto m = ManagedCall("SwitchThemeData", "==");
		m.put("this", this);
		m.put("other", other, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class SwitchThemeData> /*non-null*/ SwitchThemeData::ctorMain(_ctorMain p) {
		auto m = ManagedCall("SwitchThemeData", "SwitchThemeData");
		m.put("thumbColor", p.thumbColor);
		m.put("trackColor", p.trackColor);
		m.put("trackOutlineColor", p.trackOutlineColor);
		m.put("trackOutlineWidth", p.trackOutlineWidth);
		m.put("materialTapTargetSize", p.materialTapTargetSize);
		m.put("mouseCursor", p.mouseCursor);
		m.put("overlayColor", p.overlayColor);
		m.put("splashRadius", p.splashRadius);
		m.put("thumbIcon", p.thumbIcon);
		shptr<class SwitchThemeData> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class SwitchThemeData> /*var-non-null*/ SwitchTheme::data() {
		auto m = ManagedCall("SwitchTheme", "data");
		m.put("this", this);
		shptr<class SwitchThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class SwitchThemeData> /*non-null*/ SwitchTheme::of(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("SwitchTheme", "of");
		m.put("context", context, true);
		shptr<class SwitchThemeData> result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ SwitchTheme::updateShouldNotify(/*non-null*/ shptr<class SwitchTheme> oldWidget) {
		auto m = ManagedCall("SwitchTheme", "updateShouldNotify");
		m.put("this", this);
		m.put("oldWidget", oldWidget, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class SwitchTheme> /*non-null*/ SwitchTheme::ctorMain(_ctorMain p) {
		auto m = ManagedCall("SwitchTheme", "SwitchTheme");
		m.put("key", p.key);
		m.put("data", p.data, true);
		m.put("child", p.child, true);
		shptr<class SwitchTheme> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class TextButtonThemeData> /*var-non-null*/ TextButtonTheme::data() {
		auto m = ManagedCall("TextButtonTheme", "data");
		m.put("this", this);
		shptr<class TextButtonThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class TextButtonThemeData> /*non-null*/ TextButtonTheme::of(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("TextButtonTheme", "of");
		m.put("context", context, true);
		shptr<class TextButtonThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Widget> /*non-null*/ TextButtonTheme::wrap(/*non-null*/ shptr<class BuildContext> context, /*non-null*/ shptr<class Widget> child) {
		auto m = ManagedCall("TextButtonTheme", "wrap");
		m.put("this", this);
		m.put("context", context, true);
		m.put("child", child, true);
		shptr<class Widget> result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ TextButtonTheme::updateShouldNotify(/*non-null*/ shptr<class TextButtonTheme> oldWidget) {
		auto m = ManagedCall("TextButtonTheme", "updateShouldNotify");
		m.put("this", this);
		m.put("oldWidget", oldWidget, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class TextButtonTheme> /*non-null*/ TextButtonTheme::ctorMain(_ctorMain p) {
		auto m = ManagedCall("TextButtonTheme", "TextButtonTheme");
		m.put("key", p.key);
		m.put("data", p.data, true);
		m.put("child", p.child, true);
		shptr<class TextButtonTheme> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class ButtonStyle> /*var-nullable*/ TextButtonThemeData::style() {
		auto m = ManagedCall("TextButtonThemeData", "style");
		m.put("this", this);
		shptr<class ButtonStyle> result;
		m.call(result);
		return result;
	}

	shptr<class TextButtonThemeData> /*nullable*/ TextButtonThemeData::lerp(/*nullable*/ shptr<class TextButtonThemeData> a, /*nullable*/ shptr<class TextButtonThemeData> b, /*non-null*/ double t) {
		auto m = ManagedCall("TextButtonThemeData", "lerp");
		m.put("a", a);
		m.put("b", b);
		m.put("t", t);
		shptr<class TextButtonThemeData> result;
		m.call(result);
		return result;
	}

	bool /*non-null*/ TextButtonThemeData::equals(/*non-null*/ shptr<class ObjBase> other) {
		auto m = ManagedCall("TextButtonThemeData", "==");
		m.put("this", this);
		m.put("other", other, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class TextButtonThemeData> /*non-null*/ TextButtonThemeData::ctorMain(_ctorMain p) {
		auto m = ManagedCall("TextButtonThemeData", "TextButtonThemeData");
		m.put("style", p.style);
		shptr<class TextButtonThemeData> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Color> /*var-nullable*/ TextSelectionThemeData::cursorColor() {
		auto m = ManagedCall("TextSelectionThemeData", "cursorColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ TextSelectionThemeData::selectionColor() {
		auto m = ManagedCall("TextSelectionThemeData", "selectionColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ TextSelectionThemeData::selectionHandleColor() {
		auto m = ManagedCall("TextSelectionThemeData", "selectionHandleColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class TextSelectionThemeData> /*non-null*/ TextSelectionThemeData::copyWith(_copyWith p) {
		auto m = ManagedCall("TextSelectionThemeData", "copyWith");
		m.put("this", this);
		m.put("cursorColor", p.cursorColor);
		m.put("selectionColor", p.selectionColor);
		m.put("selectionHandleColor", p.selectionHandleColor);
		shptr<class TextSelectionThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class TextSelectionThemeData> /*nullable*/ TextSelectionThemeData::lerp(/*nullable*/ shptr<class TextSelectionThemeData> a, /*nullable*/ shptr<class TextSelectionThemeData> b, /*non-null*/ double t) {
		auto m = ManagedCall("TextSelectionThemeData", "lerp");
		m.put("a", a);
		m.put("b", b);
		m.put("t", t);
		shptr<class TextSelectionThemeData> result;
		m.call(result);
		return result;
	}

	bool /*non-null*/ TextSelectionThemeData::equals(/*non-null*/ shptr<class ObjBase> other) {
		auto m = ManagedCall("TextSelectionThemeData", "==");
		m.put("this", this);
		m.put("other", other, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class TextSelectionThemeData> /*non-null*/ TextSelectionThemeData::ctorMain(_ctorMain p) {
		auto m = ManagedCall("TextSelectionThemeData", "TextSelectionThemeData");
		m.put("cursorColor", p.cursorColor);
		m.put("selectionColor", p.selectionColor);
		m.put("selectionHandleColor", p.selectionHandleColor);
		shptr<class TextSelectionThemeData> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class TextSelectionThemeData> /*var-non-null*/ TextSelectionTheme::data() {
		auto m = ManagedCall("TextSelectionTheme", "data");
		m.put("this", this);
		shptr<class TextSelectionThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Widget> /*get-non-null*/ TextSelectionTheme::child() {
		auto m = ManagedCall("TextSelectionTheme", "child");
		m.put("this", this);
		shptr<class Widget> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class TextSelectionThemeData> /*non-null*/ TextSelectionTheme::of(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("TextSelectionTheme", "of");
		m.put("context", context, true);
		shptr<class TextSelectionThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Widget> /*non-null*/ TextSelectionTheme::wrap(/*non-null*/ shptr<class BuildContext> context, /*non-null*/ shptr<class Widget> child) {
		auto m = ManagedCall("TextSelectionTheme", "wrap");
		m.put("this", this);
		m.put("context", context, true);
		m.put("child", child, true);
		shptr<class Widget> result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ TextSelectionTheme::updateShouldNotify(/*non-null*/ shptr<class TextSelectionTheme> oldWidget) {
		auto m = ManagedCall("TextSelectionTheme", "updateShouldNotify");
		m.put("this", this);
		m.put("oldWidget", oldWidget, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class TextSelectionTheme> /*non-null*/ TextSelectionTheme::ctorMain(_ctorMain p) {
		auto m = ManagedCall("TextSelectionTheme", "TextSelectionTheme");
		m.put("key", p.key);
		m.put("data", p.data, true);
		m.put("child", p.child, true);
		shptr<class TextSelectionTheme> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Color> /*var-nullable*/ TimePickerThemeData::backgroundColor() {
		auto m = ManagedCall("TimePickerThemeData", "backgroundColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class ButtonStyle> /*var-nullable*/ TimePickerThemeData::cancelButtonStyle() {
		auto m = ManagedCall("TimePickerThemeData", "cancelButtonStyle");
		m.put("this", this);
		shptr<class ButtonStyle> result;
		m.call(result);
		return result;
	}

	shptr<class ButtonStyle> /*var-nullable*/ TimePickerThemeData::confirmButtonStyle() {
		auto m = ManagedCall("TimePickerThemeData", "confirmButtonStyle");
		m.put("this", this);
		shptr<class ButtonStyle> result;
		m.call(result);
		return result;
	}

	shptr<class BorderSide> /*var-nullable*/ TimePickerThemeData::dayPeriodBorderSide() {
		auto m = ManagedCall("TimePickerThemeData", "dayPeriodBorderSide");
		m.put("this", this);
		shptr<class BorderSide> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ TimePickerThemeData::dayPeriodColor() {
		auto m = ManagedCall("TimePickerThemeData", "dayPeriodColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class OutlinedBorder> /*var-nullable*/ TimePickerThemeData::dayPeriodShape() {
		auto m = ManagedCall("TimePickerThemeData", "dayPeriodShape");
		m.put("this", this);
		shptr<class OutlinedBorder> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ TimePickerThemeData::dayPeriodTextColor() {
		auto m = ManagedCall("TimePickerThemeData", "dayPeriodTextColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class TextStyle> /*var-nullable*/ TimePickerThemeData::dayPeriodTextStyle() {
		auto m = ManagedCall("TimePickerThemeData", "dayPeriodTextStyle");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ TimePickerThemeData::dialBackgroundColor() {
		auto m = ManagedCall("TimePickerThemeData", "dialBackgroundColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ TimePickerThemeData::dialHandColor() {
		auto m = ManagedCall("TimePickerThemeData", "dialHandColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ TimePickerThemeData::dialTextColor() {
		auto m = ManagedCall("TimePickerThemeData", "dialTextColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class TextStyle> /*var-nullable*/ TimePickerThemeData::dialTextStyle() {
		auto m = ManagedCall("TimePickerThemeData", "dialTextStyle");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ TimePickerThemeData::elevation() {
		auto m = ManagedCall("TimePickerThemeData", "elevation");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ TimePickerThemeData::entryModeIconColor() {
		auto m = ManagedCall("TimePickerThemeData", "entryModeIconColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class TextStyle> /*var-nullable*/ TimePickerThemeData::helpTextStyle() {
		auto m = ManagedCall("TimePickerThemeData", "helpTextStyle");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ TimePickerThemeData::hourMinuteColor() {
		auto m = ManagedCall("TimePickerThemeData", "hourMinuteColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class ShapeBorder> /*var-nullable*/ TimePickerThemeData::hourMinuteShape() {
		auto m = ManagedCall("TimePickerThemeData", "hourMinuteShape");
		m.put("this", this);
		shptr<class ShapeBorder> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ TimePickerThemeData::hourMinuteTextColor() {
		auto m = ManagedCall("TimePickerThemeData", "hourMinuteTextColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class TextStyle> /*var-nullable*/ TimePickerThemeData::hourMinuteTextStyle() {
		auto m = ManagedCall("TimePickerThemeData", "hourMinuteTextStyle");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.call(result);
		return result;
	}

	shptr<class InputDecorationTheme> /*var-nullable*/ TimePickerThemeData::inputDecorationTheme() {
		auto m = ManagedCall("TimePickerThemeData", "inputDecorationTheme");
		m.put("this", this);
		shptr<class InputDecorationTheme> result;
		m.call(result);
		return result;
	}

	shptr<class EdgeInsetsGeometry> /*var-nullable*/ TimePickerThemeData::padding() {
		auto m = ManagedCall("TimePickerThemeData", "padding");
		m.put("this", this);
		shptr<class EdgeInsetsGeometry> result;
		m.call(result);
		return result;
	}

	shptr<class ShapeBorder> /*var-nullable*/ TimePickerThemeData::shape() {
		auto m = ManagedCall("TimePickerThemeData", "shape");
		m.put("this", this);
		shptr<class ShapeBorder> result;
		m.call(result);
		return result;
	}

	shptr<class TimePickerThemeData> /*non-null*/ TimePickerThemeData::copyWith(_copyWith p) {
		auto m = ManagedCall("TimePickerThemeData", "copyWith");
		m.put("this", this);
		m.put("backgroundColor", p.backgroundColor);
		m.put("cancelButtonStyle", p.cancelButtonStyle);
		m.put("confirmButtonStyle", p.confirmButtonStyle);
		m.put("dayPeriodButtonStyle", p.dayPeriodButtonStyle);
		m.put("dayPeriodBorderSide", p.dayPeriodBorderSide);
		m.put("dayPeriodColor", p.dayPeriodColor);
		m.put("dayPeriodShape", p.dayPeriodShape);
		m.put("dayPeriodTextColor", p.dayPeriodTextColor);
		m.put("dayPeriodTextStyle", p.dayPeriodTextStyle);
		m.put("dialBackgroundColor", p.dialBackgroundColor);
		m.put("dialHandColor", p.dialHandColor);
		m.put("dialTextColor", p.dialTextColor);
		m.put("dialTextStyle", p.dialTextStyle);
		m.put("elevation", p.elevation);
		m.put("entryModeIconColor", p.entryModeIconColor);
		m.put("helpTextStyle", p.helpTextStyle);
		m.put("hourMinuteColor", p.hourMinuteColor);
		m.put("hourMinuteShape", p.hourMinuteShape);
		m.put("hourMinuteTextColor", p.hourMinuteTextColor);
		m.put("hourMinuteTextStyle", p.hourMinuteTextStyle);
		m.put("inputDecorationTheme", p.inputDecorationTheme);
		m.put("padding", p.padding);
		m.put("shape", p.shape);
		shptr<class TimePickerThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class TimePickerThemeData> /*non-null*/ TimePickerThemeData::lerp(/*nullable*/ shptr<class TimePickerThemeData> a, /*nullable*/ shptr<class TimePickerThemeData> b, /*non-null*/ double t) {
		auto m = ManagedCall("TimePickerThemeData", "lerp");
		m.put("a", a);
		m.put("b", b);
		m.put("t", t);
		shptr<class TimePickerThemeData> result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ TimePickerThemeData::equals(/*non-null*/ shptr<class ObjBase> other) {
		auto m = ManagedCall("TimePickerThemeData", "==");
		m.put("this", this);
		m.put("other", other, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class TimePickerThemeData> /*non-null*/ TimePickerThemeData::ctorMain(_ctorMain p) {
		auto m = ManagedCall("TimePickerThemeData", "TimePickerThemeData");
		m.put("backgroundColor", p.backgroundColor);
		m.put("cancelButtonStyle", p.cancelButtonStyle);
		m.put("confirmButtonStyle", p.confirmButtonStyle);
		m.put("dayPeriodBorderSide", p.dayPeriodBorderSide);
		m.put("dayPeriodColor", p.dayPeriodColor);
		m.put("dayPeriodShape", p.dayPeriodShape);
		m.put("dayPeriodTextColor", p.dayPeriodTextColor);
		m.put("dayPeriodTextStyle", p.dayPeriodTextStyle);
		m.put("dialBackgroundColor", p.dialBackgroundColor);
		m.put("dialHandColor", p.dialHandColor);
		m.put("dialTextColor", p.dialTextColor);
		m.put("dialTextStyle", p.dialTextStyle);
		m.put("elevation", p.elevation);
		m.put("entryModeIconColor", p.entryModeIconColor);
		m.put("helpTextStyle", p.helpTextStyle);
		m.put("hourMinuteColor", p.hourMinuteColor);
		m.put("hourMinuteShape", p.hourMinuteShape);
		m.put("hourMinuteTextColor", p.hourMinuteTextColor);
		m.put("hourMinuteTextStyle", p.hourMinuteTextStyle);
		m.put("inputDecorationTheme", p.inputDecorationTheme);
		m.put("padding", p.padding);
		m.put("shape", p.shape);
		shptr<class TimePickerThemeData> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class TimePickerThemeData> /*var-non-null*/ TimePickerTheme::data() {
		auto m = ManagedCall("TimePickerTheme", "data");
		m.put("this", this);
		shptr<class TimePickerThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class TimePickerThemeData> /*non-null*/ TimePickerTheme::of(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("TimePickerTheme", "of");
		m.put("context", context, true);
		shptr<class TimePickerThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Widget> /*non-null*/ TimePickerTheme::wrap(/*non-null*/ shptr<class BuildContext> context, /*non-null*/ shptr<class Widget> child) {
		auto m = ManagedCall("TimePickerTheme", "wrap");
		m.put("this", this);
		m.put("context", context, true);
		m.put("child", child, true);
		shptr<class Widget> result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ TimePickerTheme::updateShouldNotify(/*non-null*/ shptr<class TimePickerTheme> oldWidget) {
		auto m = ManagedCall("TimePickerTheme", "updateShouldNotify");
		m.put("this", this);
		m.put("oldWidget", oldWidget, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class TimePickerTheme> /*non-null*/ TimePickerTheme::ctorMain(_ctorMain p) {
		auto m = ManagedCall("TimePickerTheme", "TimePickerTheme");
		m.put("key", p.key);
		m.put("data", p.data, true);
		m.put("child", p.child, true);
		shptr<class TimePickerTheme> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class TextStyle> /*var-nullable*/ ToggleButtonsThemeData::textStyle() {
		auto m = ManagedCall("ToggleButtonsThemeData", "textStyle");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.call(result);
		return result;
	}

	shptr<class BoxConstraints> /*var-nullable*/ ToggleButtonsThemeData::constraints() {
		auto m = ManagedCall("ToggleButtonsThemeData", "constraints");
		m.put("this", this);
		shptr<class BoxConstraints> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ ToggleButtonsThemeData::color() {
		auto m = ManagedCall("ToggleButtonsThemeData", "color");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ ToggleButtonsThemeData::selectedColor() {
		auto m = ManagedCall("ToggleButtonsThemeData", "selectedColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ ToggleButtonsThemeData::disabledColor() {
		auto m = ManagedCall("ToggleButtonsThemeData", "disabledColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ ToggleButtonsThemeData::fillColor() {
		auto m = ManagedCall("ToggleButtonsThemeData", "fillColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ ToggleButtonsThemeData::focusColor() {
		auto m = ManagedCall("ToggleButtonsThemeData", "focusColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ ToggleButtonsThemeData::highlightColor() {
		auto m = ManagedCall("ToggleButtonsThemeData", "highlightColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ ToggleButtonsThemeData::splashColor() {
		auto m = ManagedCall("ToggleButtonsThemeData", "splashColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ ToggleButtonsThemeData::hoverColor() {
		auto m = ManagedCall("ToggleButtonsThemeData", "hoverColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ ToggleButtonsThemeData::borderColor() {
		auto m = ManagedCall("ToggleButtonsThemeData", "borderColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ ToggleButtonsThemeData::selectedBorderColor() {
		auto m = ManagedCall("ToggleButtonsThemeData", "selectedBorderColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ ToggleButtonsThemeData::disabledBorderColor() {
		auto m = ManagedCall("ToggleButtonsThemeData", "disabledBorderColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ ToggleButtonsThemeData::borderWidth() {
		auto m = ManagedCall("ToggleButtonsThemeData", "borderWidth");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	shptr<class BorderRadius> /*var-nullable*/ ToggleButtonsThemeData::borderRadius() {
		auto m = ManagedCall("ToggleButtonsThemeData", "borderRadius");
		m.put("this", this);
		shptr<class BorderRadius> result;
		m.call(result);
		return result;
	}

	shptr<class ToggleButtonsThemeData> /*non-null*/ ToggleButtonsThemeData::copyWith(_copyWith p) {
		auto m = ManagedCall("ToggleButtonsThemeData", "copyWith");
		m.put("this", this);
		m.put("textStyle", p.textStyle);
		m.put("constraints", p.constraints);
		m.put("color", p.color);
		m.put("selectedColor", p.selectedColor);
		m.put("disabledColor", p.disabledColor);
		m.put("fillColor", p.fillColor);
		m.put("focusColor", p.focusColor);
		m.put("highlightColor", p.highlightColor);
		m.put("hoverColor", p.hoverColor);
		m.put("splashColor", p.splashColor);
		m.put("borderColor", p.borderColor);
		m.put("selectedBorderColor", p.selectedBorderColor);
		m.put("disabledBorderColor", p.disabledBorderColor);
		m.put("borderRadius", p.borderRadius);
		m.put("borderWidth", p.borderWidth);
		shptr<class ToggleButtonsThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ToggleButtonsThemeData> /*nullable*/ ToggleButtonsThemeData::lerp(/*nullable*/ shptr<class ToggleButtonsThemeData> a, /*nullable*/ shptr<class ToggleButtonsThemeData> b, /*non-null*/ double t) {
		auto m = ManagedCall("ToggleButtonsThemeData", "lerp");
		m.put("a", a);
		m.put("b", b);
		m.put("t", t);
		shptr<class ToggleButtonsThemeData> result;
		m.call(result);
		return result;
	}

	bool /*non-null*/ ToggleButtonsThemeData::equals(/*non-null*/ shptr<class ObjBase> other) {
		auto m = ManagedCall("ToggleButtonsThemeData", "==");
		m.put("this", this);
		m.put("other", other, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ToggleButtonsThemeData> /*non-null*/ ToggleButtonsThemeData::ctorMain(_ctorMain p) {
		auto m = ManagedCall("ToggleButtonsThemeData", "ToggleButtonsThemeData");
		m.put("textStyle", p.textStyle);
		m.put("constraints", p.constraints);
		m.put("color", p.color);
		m.put("selectedColor", p.selectedColor);
		m.put("disabledColor", p.disabledColor);
		m.put("fillColor", p.fillColor);
		m.put("focusColor", p.focusColor);
		m.put("highlightColor", p.highlightColor);
		m.put("hoverColor", p.hoverColor);
		m.put("splashColor", p.splashColor);
		m.put("borderColor", p.borderColor);
		m.put("selectedBorderColor", p.selectedBorderColor);
		m.put("disabledBorderColor", p.disabledBorderColor);
		m.put("borderRadius", p.borderRadius);
		m.put("borderWidth", p.borderWidth);
		shptr<class ToggleButtonsThemeData> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class ToggleButtonsThemeData> /*var-non-null*/ ToggleButtonsTheme::data() {
		auto m = ManagedCall("ToggleButtonsTheme", "data");
		m.put("this", this);
		shptr<class ToggleButtonsThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ToggleButtonsThemeData> /*non-null*/ ToggleButtonsTheme::of(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("ToggleButtonsTheme", "of");
		m.put("context", context, true);
		shptr<class ToggleButtonsThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Widget> /*non-null*/ ToggleButtonsTheme::wrap(/*non-null*/ shptr<class BuildContext> context, /*non-null*/ shptr<class Widget> child) {
		auto m = ManagedCall("ToggleButtonsTheme", "wrap");
		m.put("this", this);
		m.put("context", context, true);
		m.put("child", child, true);
		shptr<class Widget> result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ ToggleButtonsTheme::updateShouldNotify(/*non-null*/ shptr<class ToggleButtonsTheme> oldWidget) {
		auto m = ManagedCall("ToggleButtonsTheme", "updateShouldNotify");
		m.put("this", this);
		m.put("oldWidget", oldWidget, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class ToggleButtonsTheme> /*non-null*/ ToggleButtonsTheme::ctorMain(_ctorMain p) {
		auto m = ManagedCall("ToggleButtonsTheme", "ToggleButtonsTheme");
		m.put("key", p.key);
		m.put("data", p.data, true);
		m.put("child", p.child, true);
		shptr<class ToggleButtonsTheme> result;
		m.check(m.call(result, true));
		return result;
	}

	stdop<double> /*var-nullable*/ TooltipThemeData::height() {
		auto m = ManagedCall("TooltipThemeData", "height");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	shptr<class EdgeInsetsGeometry> /*var-nullable*/ TooltipThemeData::padding() {
		auto m = ManagedCall("TooltipThemeData", "padding");
		m.put("this", this);
		shptr<class EdgeInsetsGeometry> result;
		m.call(result);
		return result;
	}

	shptr<class EdgeInsetsGeometry> /*var-nullable*/ TooltipThemeData::margin() {
		auto m = ManagedCall("TooltipThemeData", "margin");
		m.put("this", this);
		shptr<class EdgeInsetsGeometry> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ TooltipThemeData::verticalOffset() {
		auto m = ManagedCall("TooltipThemeData", "verticalOffset");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	stdop<bool> /*var-nullable*/ TooltipThemeData::preferBelow() {
		auto m = ManagedCall("TooltipThemeData", "preferBelow");
		m.put("this", this);
		stdop<bool> result;
		m.call(result);
		return result;
	}

	stdop<bool> /*var-nullable*/ TooltipThemeData::excludeFromSemantics() {
		auto m = ManagedCall("TooltipThemeData", "excludeFromSemantics");
		m.put("this", this);
		stdop<bool> result;
		m.call(result);
		return result;
	}

	shptr<class Decoration> /*var-nullable*/ TooltipThemeData::decoration() {
		auto m = ManagedCall("TooltipThemeData", "decoration");
		m.put("this", this);
		shptr<class Decoration> result;
		m.call(result);
		return result;
	}

	shptr<class TextStyle> /*var-nullable*/ TooltipThemeData::textStyle() {
		auto m = ManagedCall("TooltipThemeData", "textStyle");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.call(result);
		return result;
	}

	stdop<TextAlign> /*var-nullable*/ TooltipThemeData::textAlign() {
		auto m = ManagedCall("TooltipThemeData", "textAlign");
		m.put("this", this);
		stdop<TextAlign> result;
		m.call(result);
		return result;
	}

	shptr<class Duration> /*var-nullable*/ TooltipThemeData::waitDuration() {
		auto m = ManagedCall("TooltipThemeData", "waitDuration");
		m.put("this", this);
		shptr<class Duration> result;
		m.call(result);
		return result;
	}

	shptr<class Duration> /*var-nullable*/ TooltipThemeData::showDuration() {
		auto m = ManagedCall("TooltipThemeData", "showDuration");
		m.put("this", this);
		shptr<class Duration> result;
		m.call(result);
		return result;
	}

	stdop<TooltipTriggerMode> /*var-nullable*/ TooltipThemeData::triggerMode() {
		auto m = ManagedCall("TooltipThemeData", "triggerMode");
		m.put("this", this);
		stdop<TooltipTriggerMode> result;
		m.call(result);
		return result;
	}

	stdop<bool> /*var-nullable*/ TooltipThemeData::enableFeedback() {
		auto m = ManagedCall("TooltipThemeData", "enableFeedback");
		m.put("this", this);
		stdop<bool> result;
		m.call(result);
		return result;
	}

	shptr<class TooltipThemeData> /*non-null*/ TooltipThemeData::copyWith(_copyWith p) {
		auto m = ManagedCall("TooltipThemeData", "copyWith");
		m.put("this", this);
		m.put("height", p.height);
		m.put("padding", p.padding);
		m.put("margin", p.margin);
		m.put("verticalOffset", p.verticalOffset);
		m.put("preferBelow", p.preferBelow);
		m.put("excludeFromSemantics", p.excludeFromSemantics);
		m.put("decoration", p.decoration);
		m.put("textStyle", p.textStyle);
		m.put("textAlign", p.textAlign);
		m.put("waitDuration", p.waitDuration);
		m.put("showDuration", p.showDuration);
		m.put("triggerMode", p.triggerMode);
		m.put("enableFeedback", p.enableFeedback);
		shptr<class TooltipThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class TooltipThemeData> /*nullable*/ TooltipThemeData::lerp(/*nullable*/ shptr<class TooltipThemeData> a, /*nullable*/ shptr<class TooltipThemeData> b, /*non-null*/ double t) {
		auto m = ManagedCall("TooltipThemeData", "lerp");
		m.put("a", a);
		m.put("b", b);
		m.put("t", t);
		shptr<class TooltipThemeData> result;
		m.call(result);
		return result;
	}

	bool /*non-null*/ TooltipThemeData::equals(/*non-null*/ shptr<class ObjBase> other) {
		auto m = ManagedCall("TooltipThemeData", "==");
		m.put("this", this);
		m.put("other", other, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class TooltipThemeData> /*non-null*/ TooltipThemeData::ctorMain(_ctorMain p) {
		auto m = ManagedCall("TooltipThemeData", "TooltipThemeData");
		m.put("height", p.height);
		m.put("padding", p.padding);
		m.put("margin", p.margin);
		m.put("verticalOffset", p.verticalOffset);
		m.put("preferBelow", p.preferBelow);
		m.put("excludeFromSemantics", p.excludeFromSemantics);
		m.put("decoration", p.decoration);
		m.put("textStyle", p.textStyle);
		m.put("textAlign", p.textAlign);
		m.put("waitDuration", p.waitDuration);
		m.put("showDuration", p.showDuration);
		m.put("triggerMode", p.triggerMode);
		m.put("enableFeedback", p.enableFeedback);
		shptr<class TooltipThemeData> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class TooltipThemeData> /*var-non-null*/ TooltipTheme::data() {
		auto m = ManagedCall("TooltipTheme", "data");
		m.put("this", this);
		shptr<class TooltipThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class TooltipThemeData> /*non-null*/ TooltipTheme::of(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("TooltipTheme", "of");
		m.put("context", context, true);
		shptr<class TooltipThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Widget> /*non-null*/ TooltipTheme::wrap(/*non-null*/ shptr<class BuildContext> context, /*non-null*/ shptr<class Widget> child) {
		auto m = ManagedCall("TooltipTheme", "wrap");
		m.put("this", this);
		m.put("context", context, true);
		m.put("child", child, true);
		shptr<class Widget> result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ TooltipTheme::updateShouldNotify(/*non-null*/ shptr<class TooltipTheme> oldWidget) {
		auto m = ManagedCall("TooltipTheme", "updateShouldNotify");
		m.put("this", this);
		m.put("oldWidget", oldWidget, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class TooltipTheme> /*non-null*/ TooltipTheme::ctorMain(_ctorMain p) {
		auto m = ManagedCall("TooltipTheme", "TooltipTheme");
		m.put("key", p.key);
		m.put("data", p.data, true);
		m.put("child", p.child, true);
		shptr<class TooltipTheme> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class IconThemeData> /*var-non-null*/ IconTheme::data() {
		auto m = ManagedCall("IconTheme", "data");
		m.put("this", this);
		shptr<class IconThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Widget> /*non-null*/ IconTheme::merge(_merge p) {
		auto m = ManagedCall("IconTheme", "merge");
		m.put("key", p.key);
		m.put("data", p.data, true);
		m.put("child", p.child, true);
		shptr<class Widget> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class IconThemeData> /*non-null*/ IconTheme::of(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("IconTheme", "of");
		m.put("context", context, true);
		shptr<class IconThemeData> result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ IconTheme::updateShouldNotify(/*non-null*/ shptr<class IconTheme> oldWidget) {
		auto m = ManagedCall("IconTheme", "updateShouldNotify");
		m.put("this", this);
		m.put("oldWidget", oldWidget, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Widget> /*non-null*/ IconTheme::wrap(/*non-null*/ shptr<class BuildContext> context, /*non-null*/ shptr<class Widget> child) {
		auto m = ManagedCall("IconTheme", "wrap");
		m.put("this", this);
		m.put("context", context, true);
		m.put("child", child, true);
		shptr<class Widget> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class IconTheme> /*non-null*/ IconTheme::ctorMain(_ctorMain p) {
		auto m = ManagedCall("IconTheme", "IconTheme");
		m.put("key", p.key);
		m.put("data", p.data, true);
		m.put("child", p.child, true);
		shptr<class IconTheme> result;
		m.check(m.call(result, true));
		return result;
	}

	stdop<double> /*var-nullable*/ IconThemeData::size() {
		auto m = ManagedCall("IconThemeData", "size");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ IconThemeData::fill() {
		auto m = ManagedCall("IconThemeData", "fill");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ IconThemeData::weight() {
		auto m = ManagedCall("IconThemeData", "weight");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ IconThemeData::grade() {
		auto m = ManagedCall("IconThemeData", "grade");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ IconThemeData::opticalSize() {
		auto m = ManagedCall("IconThemeData", "opticalSize");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ IconThemeData::color() {
		auto m = ManagedCall("IconThemeData", "color");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	bool /*get-non-null*/ IconThemeData::isConcrete() {
		auto m = ManagedCall("IconThemeData", "isConcrete");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	stdop<double> /*get-nullable*/ IconThemeData::opacity() {
		auto m = ManagedCall("IconThemeData", "opacity");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	shptr<class IconThemeData> /*non-null*/ IconThemeData::copyWith(_copyWith p) {
		auto m = ManagedCall("IconThemeData", "copyWith");
		m.put("this", this);
		m.put("size", p.size);
		m.put("fill", p.fill);
		m.put("weight", p.weight);
		m.put("grade", p.grade);
		m.put("opticalSize", p.opticalSize);
		m.put("color", p.color);
		m.put("opacity", p.opacity);
		m.put("shadows", p.shadows);
		shptr<class IconThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class IconThemeData> /*non-null*/ IconThemeData::merge(/*nullable*/ shptr<class IconThemeData> other) {
		auto m = ManagedCall("IconThemeData", "merge");
		m.put("this", this);
		m.put("other", other);
		shptr<class IconThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class IconThemeData> /*non-null*/ IconThemeData::resolve(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("IconThemeData", "resolve");
		m.put("this", this);
		m.put("context", context, true);
		shptr<class IconThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class IconThemeData> /*non-null*/ IconThemeData::lerp(/*nullable*/ shptr<class IconThemeData> a, /*nullable*/ shptr<class IconThemeData> b, /*non-null*/ double t) {
		auto m = ManagedCall("IconThemeData", "lerp");
		m.put("a", a);
		m.put("b", b);
		m.put("t", t);
		shptr<class IconThemeData> result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ IconThemeData::equals(/*non-null*/ shptr<class ObjBase> other) {
		auto m = ManagedCall("IconThemeData", "==");
		m.put("this", this);
		m.put("other", other, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class IconThemeData> /*non-null*/ IconThemeData::ctorMain(_ctorMain p) {
		auto m = ManagedCall("IconThemeData", "IconThemeData");
		m.put("size", p.size);
		m.put("fill", p.fill);
		m.put("weight", p.weight);
		m.put("grade", p.grade);
		m.put("opticalSize", p.opticalSize);
		m.put("color", p.color);
		m.put("opacity", p.opacity);
		m.put("shadows", p.shadows);
		shptr<class IconThemeData> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class IconThemeData> /*non-null*/ IconThemeData::fallback() {
		auto m = ManagedCall("IconThemeData", "fallback");
		shptr<class IconThemeData> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class IconThemeData> /*non-null*/ CupertinoIconThemeData::resolve(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("CupertinoIconThemeData", "resolve");
		m.put("this", this);
		m.put("context", context, true);
		shptr<class IconThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class CupertinoIconThemeData> /*non-null*/ CupertinoIconThemeData::copyWith(_copyWith p) {
		auto m = ManagedCall("CupertinoIconThemeData", "copyWith");
		m.put("this", this);
		m.put("size", p.size);
		m.put("fill", p.fill);
		m.put("weight", p.weight);
		m.put("grade", p.grade);
		m.put("opticalSize", p.opticalSize);
		m.put("color", p.color);
		m.put("opacity", p.opacity);
		m.put("shadows", p.shadows);
		shptr<class CupertinoIconThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class CupertinoIconThemeData> /*non-null*/ CupertinoIconThemeData::ctorMain(_ctorMain p) {
		auto m = ManagedCall("CupertinoIconThemeData", "CupertinoIconThemeData");
		m.put("size", p.size);
		m.put("fill", p.fill);
		m.put("weight", p.weight);
		m.put("grade", p.grade);
		m.put("opticalSize", p.opticalSize);
		m.put("color", p.color);
		m.put("opacity", p.opacity);
		m.put("shadows", p.shadows);
		shptr<class CupertinoIconThemeData> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class TextStyle> /*get-non-null*/ CupertinoTextThemeData::textStyle() {
		auto m = ManagedCall("CupertinoTextThemeData", "textStyle");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class TextStyle> /*get-non-null*/ CupertinoTextThemeData::actionTextStyle() {
		auto m = ManagedCall("CupertinoTextThemeData", "actionTextStyle");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class TextStyle> /*get-non-null*/ CupertinoTextThemeData::tabLabelTextStyle() {
		auto m = ManagedCall("CupertinoTextThemeData", "tabLabelTextStyle");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class TextStyle> /*get-non-null*/ CupertinoTextThemeData::navTitleTextStyle() {
		auto m = ManagedCall("CupertinoTextThemeData", "navTitleTextStyle");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class TextStyle> /*get-non-null*/ CupertinoTextThemeData::navLargeTitleTextStyle() {
		auto m = ManagedCall("CupertinoTextThemeData", "navLargeTitleTextStyle");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class TextStyle> /*get-non-null*/ CupertinoTextThemeData::navActionTextStyle() {
		auto m = ManagedCall("CupertinoTextThemeData", "navActionTextStyle");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class TextStyle> /*get-non-null*/ CupertinoTextThemeData::pickerTextStyle() {
		auto m = ManagedCall("CupertinoTextThemeData", "pickerTextStyle");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class TextStyle> /*get-non-null*/ CupertinoTextThemeData::dateTimePickerTextStyle() {
		auto m = ManagedCall("CupertinoTextThemeData", "dateTimePickerTextStyle");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class CupertinoTextThemeData> /*non-null*/ CupertinoTextThemeData::resolveFrom(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("CupertinoTextThemeData", "resolveFrom");
		m.put("this", this);
		m.put("context", context, true);
		shptr<class CupertinoTextThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class CupertinoTextThemeData> /*non-null*/ CupertinoTextThemeData::copyWith(_copyWith p) {
		auto m = ManagedCall("CupertinoTextThemeData", "copyWith");
		m.put("this", this);
		m.put("primaryColor", p.primaryColor);
		m.put("textStyle", p.textStyle);
		m.put("actionTextStyle", p.actionTextStyle);
		m.put("tabLabelTextStyle", p.tabLabelTextStyle);
		m.put("navTitleTextStyle", p.navTitleTextStyle);
		m.put("navLargeTitleTextStyle", p.navLargeTitleTextStyle);
		m.put("navActionTextStyle", p.navActionTextStyle);
		m.put("pickerTextStyle", p.pickerTextStyle);
		m.put("dateTimePickerTextStyle", p.dateTimePickerTextStyle);
		shptr<class CupertinoTextThemeData> result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ CupertinoTextThemeData::equals(/*non-null*/ shptr<class ObjBase> other) {
		auto m = ManagedCall("CupertinoTextThemeData", "==");
		m.put("this", this);
		m.put("other", other, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class CupertinoTextThemeData> /*non-null*/ CupertinoTextThemeData::ctorMain(_ctorMain p) {
		auto m = ManagedCall("CupertinoTextThemeData", "CupertinoTextThemeData");
		m.put("primaryColor", p.primaryColor, true);
		m.put("textStyle", p.textStyle);
		m.put("actionTextStyle", p.actionTextStyle);
		m.put("tabLabelTextStyle", p.tabLabelTextStyle);
		m.put("navTitleTextStyle", p.navTitleTextStyle);
		m.put("navLargeTitleTextStyle", p.navLargeTitleTextStyle);
		m.put("navActionTextStyle", p.navActionTextStyle);
		m.put("pickerTextStyle", p.pickerTextStyle);
		m.put("dateTimePickerTextStyle", p.dateTimePickerTextStyle);
		shptr<class CupertinoTextThemeData> result;
		m.check(m.call(result, true));
		return result;
	}

	stdop<Brightness> /*var-nullable*/ NoDefaultCupertinoThemeData::brightness() {
		auto m = ManagedCall("NoDefaultCupertinoThemeData", "brightness");
		m.put("this", this);
		stdop<Brightness> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ NoDefaultCupertinoThemeData::primaryColor() {
		auto m = ManagedCall("NoDefaultCupertinoThemeData", "primaryColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ NoDefaultCupertinoThemeData::primaryContrastingColor() {
		auto m = ManagedCall("NoDefaultCupertinoThemeData", "primaryContrastingColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class CupertinoTextThemeData> /*var-nullable*/ NoDefaultCupertinoThemeData::textTheme() {
		auto m = ManagedCall("NoDefaultCupertinoThemeData", "textTheme");
		m.put("this", this);
		shptr<class CupertinoTextThemeData> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ NoDefaultCupertinoThemeData::barBackgroundColor() {
		auto m = ManagedCall("NoDefaultCupertinoThemeData", "barBackgroundColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ NoDefaultCupertinoThemeData::scaffoldBackgroundColor() {
		auto m = ManagedCall("NoDefaultCupertinoThemeData", "scaffoldBackgroundColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	stdop<bool> /*var-nullable*/ NoDefaultCupertinoThemeData::applyThemeToAll() {
		auto m = ManagedCall("NoDefaultCupertinoThemeData", "applyThemeToAll");
		m.put("this", this);
		stdop<bool> result;
		m.call(result);
		return result;
	}

	shptr<class NoDefaultCupertinoThemeData> /*non-null*/ NoDefaultCupertinoThemeData::noDefault() {
		auto m = ManagedCall("NoDefaultCupertinoThemeData", "noDefault");
		m.put("this", this);
		shptr<class NoDefaultCupertinoThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class NoDefaultCupertinoThemeData> /*non-null*/ NoDefaultCupertinoThemeData::resolveFrom(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("NoDefaultCupertinoThemeData", "resolveFrom");
		m.put("this", this);
		m.put("context", context, true);
		shptr<class NoDefaultCupertinoThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class NoDefaultCupertinoThemeData> /*non-null*/ NoDefaultCupertinoThemeData::copyWith(_copyWith p) {
		auto m = ManagedCall("NoDefaultCupertinoThemeData", "copyWith");
		m.put("this", this);
		m.put("brightness", p.brightness);
		m.put("primaryColor", p.primaryColor);
		m.put("primaryContrastingColor", p.primaryContrastingColor);
		m.put("textTheme", p.textTheme);
		m.put("barBackgroundColor", p.barBackgroundColor);
		m.put("scaffoldBackgroundColor", p.scaffoldBackgroundColor);
		m.put("applyThemeToAll", p.applyThemeToAll);
		shptr<class NoDefaultCupertinoThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class NoDefaultCupertinoThemeData> /*non-null*/ NoDefaultCupertinoThemeData::ctorMain(_ctorMain p) {
		auto m = ManagedCall("NoDefaultCupertinoThemeData", "NoDefaultCupertinoThemeData");
		m.put("brightness", p.brightness);
		m.put("primaryColor", p.primaryColor);
		m.put("primaryContrastingColor", p.primaryContrastingColor);
		m.put("textTheme", p.textTheme);
		m.put("barBackgroundColor", p.barBackgroundColor);
		m.put("scaffoldBackgroundColor", p.scaffoldBackgroundColor);
		m.put("applyThemeToAll", p.applyThemeToAll);
		shptr<class NoDefaultCupertinoThemeData> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class CupertinoThemeData> /*var-non-null*/ CupertinoTheme::data() {
		auto m = ManagedCall("CupertinoTheme", "data");
		m.put("this", this);
		shptr<class CupertinoThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Widget> /*var-non-null*/ CupertinoTheme::child() {
		auto m = ManagedCall("CupertinoTheme", "child");
		m.put("this", this);
		shptr<class Widget> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class CupertinoThemeData> /*non-null*/ CupertinoTheme::of(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("CupertinoTheme", "of");
		m.put("context", context, true);
		shptr<class CupertinoThemeData> result;
		m.check(m.call(result));
		return result;
	}

	Brightness /*non-null*/ CupertinoTheme::brightnessOf(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("CupertinoTheme", "brightnessOf");
		m.put("context", context, true);
		Brightness result;
		m.check(m.call(result));
		return result;
	}

	stdop<Brightness> /*nullable*/ CupertinoTheme::maybeBrightnessOf(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("CupertinoTheme", "maybeBrightnessOf");
		m.put("context", context, true);
		stdop<Brightness> result;
		m.call(result);
		return result;
	}

	shptr<class CupertinoTheme> /*non-null*/ CupertinoTheme::ctorMain(_ctorMain p) {
		auto m = ManagedCall("CupertinoTheme", "CupertinoTheme");
		m.put("key", p.key);
		m.put("data", p.data, true);
		m.put("child", p.child, true);
		shptr<class CupertinoTheme> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Color> /*get-non-null*/ CupertinoThemeData::primaryColor() {
		auto m = ManagedCall("CupertinoThemeData", "primaryColor");
		m.put("this", this);
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*get-non-null*/ CupertinoThemeData::primaryContrastingColor() {
		auto m = ManagedCall("CupertinoThemeData", "primaryContrastingColor");
		m.put("this", this);
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class CupertinoTextThemeData> /*get-non-null*/ CupertinoThemeData::textTheme() {
		auto m = ManagedCall("CupertinoThemeData", "textTheme");
		m.put("this", this);
		shptr<class CupertinoTextThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*get-non-null*/ CupertinoThemeData::barBackgroundColor() {
		auto m = ManagedCall("CupertinoThemeData", "barBackgroundColor");
		m.put("this", this);
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*get-non-null*/ CupertinoThemeData::scaffoldBackgroundColor() {
		auto m = ManagedCall("CupertinoThemeData", "scaffoldBackgroundColor");
		m.put("this", this);
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	bool /*get-non-null*/ CupertinoThemeData::applyThemeToAll() {
		auto m = ManagedCall("CupertinoThemeData", "applyThemeToAll");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class NoDefaultCupertinoThemeData> /*non-null*/ CupertinoThemeData::noDefault() {
		auto m = ManagedCall("CupertinoThemeData", "noDefault");
		m.put("this", this);
		shptr<class NoDefaultCupertinoThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class CupertinoThemeData> /*non-null*/ CupertinoThemeData::resolveFrom(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("CupertinoThemeData", "resolveFrom");
		m.put("this", this);
		m.put("context", context, true);
		shptr<class CupertinoThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class CupertinoThemeData> /*non-null*/ CupertinoThemeData::copyWith(_copyWith p) {
		auto m = ManagedCall("CupertinoThemeData", "copyWith");
		m.put("this", this);
		m.put("brightness", p.brightness);
		m.put("primaryColor", p.primaryColor);
		m.put("primaryContrastingColor", p.primaryContrastingColor);
		m.put("textTheme", p.textTheme);
		m.put("barBackgroundColor", p.barBackgroundColor);
		m.put("scaffoldBackgroundColor", p.scaffoldBackgroundColor);
		m.put("applyThemeToAll", p.applyThemeToAll);
		shptr<class CupertinoThemeData> result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ CupertinoThemeData::equals(/*non-null*/ shptr<class ObjBase> other) {
		auto m = ManagedCall("CupertinoThemeData", "==");
		m.put("this", this);
		m.put("other", other, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class CupertinoThemeData> /*non-null*/ CupertinoThemeData::ctorMain(_ctorMain p) {
		auto m = ManagedCall("CupertinoThemeData", "CupertinoThemeData");
		m.put("brightness", p.brightness);
		m.put("primaryColor", p.primaryColor);
		m.put("primaryContrastingColor", p.primaryContrastingColor);
		m.put("textTheme", p.textTheme);
		m.put("barBackgroundColor", p.barBackgroundColor);
		m.put("scaffoldBackgroundColor", p.scaffoldBackgroundColor);
		m.put("applyThemeToAll", p.applyThemeToAll);
		shptr<class CupertinoThemeData> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class CupertinoThemeData> /*non-null*/ CupertinoThemeData::raw(/*nullable*/ stdop<Brightness> brightness, /*nullable*/ shptr<class Color> primaryColor, /*nullable*/ shptr<class Color> primaryContrastingColor, /*nullable*/ shptr<class CupertinoTextThemeData> textTheme, /*nullable*/ shptr<class Color> barBackgroundColor, /*nullable*/ shptr<class Color> scaffoldBackgroundColor, /*nullable*/ stdop<bool> applyThemeToAll) {
		auto m = ManagedCall("CupertinoThemeData", "raw");
		m.put("brightness", brightness);
		m.put("primaryColor", primaryColor);
		m.put("primaryContrastingColor", primaryContrastingColor);
		m.put("textTheme", textTheme);
		m.put("barBackgroundColor", barBackgroundColor);
		m.put("scaffoldBackgroundColor", scaffoldBackgroundColor);
		m.put("applyThemeToAll", applyThemeToAll);
		shptr<class CupertinoThemeData> result;
		m.check(m.call(result, true));
		return result;
	}

	Brightness /*get-non-null*/ MaterialBasedCupertinoThemeData::brightness() {
		auto m = ManagedCall("MaterialBasedCupertinoThemeData", "brightness");
		m.put("this", this);
		Brightness result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*get-non-null*/ MaterialBasedCupertinoThemeData::primaryColor() {
		auto m = ManagedCall("MaterialBasedCupertinoThemeData", "primaryColor");
		m.put("this", this);
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*get-non-null*/ MaterialBasedCupertinoThemeData::primaryContrastingColor() {
		auto m = ManagedCall("MaterialBasedCupertinoThemeData", "primaryContrastingColor");
		m.put("this", this);
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*get-non-null*/ MaterialBasedCupertinoThemeData::scaffoldBackgroundColor() {
		auto m = ManagedCall("MaterialBasedCupertinoThemeData", "scaffoldBackgroundColor");
		m.put("this", this);
		shptr<class Color> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class MaterialBasedCupertinoThemeData> /*non-null*/ MaterialBasedCupertinoThemeData::copyWith(_copyWith p) {
		auto m = ManagedCall("MaterialBasedCupertinoThemeData", "copyWith");
		m.put("this", this);
		m.put("brightness", p.brightness);
		m.put("primaryColor", p.primaryColor);
		m.put("primaryContrastingColor", p.primaryContrastingColor);
		m.put("textTheme", p.textTheme);
		m.put("barBackgroundColor", p.barBackgroundColor);
		m.put("scaffoldBackgroundColor", p.scaffoldBackgroundColor);
		m.put("applyThemeToAll", p.applyThemeToAll);
		shptr<class MaterialBasedCupertinoThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class CupertinoThemeData> /*non-null*/ MaterialBasedCupertinoThemeData::resolveFrom(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("MaterialBasedCupertinoThemeData", "resolveFrom");
		m.put("this", this);
		m.put("context", context, true);
		shptr<class CupertinoThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class MaterialBasedCupertinoThemeData> /*non-null*/ MaterialBasedCupertinoThemeData::ctorMain(_ctorMain p) {
		auto m = ManagedCall("MaterialBasedCupertinoThemeData", "MaterialBasedCupertinoThemeData");
		m.put("materialTheme", p.materialTheme, true);
		shptr<class MaterialBasedCupertinoThemeData> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Color> /*var-nullable*/ AppBarTheme::backgroundColor() {
		auto m = ManagedCall("AppBarTheme", "backgroundColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ AppBarTheme::foregroundColor() {
		auto m = ManagedCall("AppBarTheme", "foregroundColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ AppBarTheme::elevation() {
		auto m = ManagedCall("AppBarTheme", "elevation");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ AppBarTheme::scrolledUnderElevation() {
		auto m = ManagedCall("AppBarTheme", "scrolledUnderElevation");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ AppBarTheme::shadowColor() {
		auto m = ManagedCall("AppBarTheme", "shadowColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ AppBarTheme::surfaceTintColor() {
		auto m = ManagedCall("AppBarTheme", "surfaceTintColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class ShapeBorder> /*var-nullable*/ AppBarTheme::shape() {
		auto m = ManagedCall("AppBarTheme", "shape");
		m.put("this", this);
		shptr<class ShapeBorder> result;
		m.call(result);
		return result;
	}

	shptr<class IconThemeData> /*var-nullable*/ AppBarTheme::iconTheme() {
		auto m = ManagedCall("AppBarTheme", "iconTheme");
		m.put("this", this);
		shptr<class IconThemeData> result;
		m.call(result);
		return result;
	}

	shptr<class IconThemeData> /*var-nullable*/ AppBarTheme::actionsIconTheme() {
		auto m = ManagedCall("AppBarTheme", "actionsIconTheme");
		m.put("this", this);
		shptr<class IconThemeData> result;
		m.call(result);
		return result;
	}

	stdop<bool> /*var-nullable*/ AppBarTheme::centerTitle() {
		auto m = ManagedCall("AppBarTheme", "centerTitle");
		m.put("this", this);
		stdop<bool> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ AppBarTheme::titleSpacing() {
		auto m = ManagedCall("AppBarTheme", "titleSpacing");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ AppBarTheme::toolbarHeight() {
		auto m = ManagedCall("AppBarTheme", "toolbarHeight");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	shptr<class TextStyle> /*var-nullable*/ AppBarTheme::toolbarTextStyle() {
		auto m = ManagedCall("AppBarTheme", "toolbarTextStyle");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.call(result);
		return result;
	}

	shptr<class TextStyle> /*var-nullable*/ AppBarTheme::titleTextStyle() {
		auto m = ManagedCall("AppBarTheme", "titleTextStyle");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.call(result);
		return result;
	}

	shptr<class SystemUiOverlayStyle> /*var-nullable*/ AppBarTheme::systemOverlayStyle() {
		auto m = ManagedCall("AppBarTheme", "systemOverlayStyle");
		m.put("this", this);
		shptr<class SystemUiOverlayStyle> result;
		m.call(result);
		return result;
	}

	shptr<class AppBarTheme> /*non-null*/ AppBarTheme::copyWith(_copyWith p) {
		auto m = ManagedCall("AppBarTheme", "copyWith");
		m.put("this", this);
		m.put("actionsIconTheme", p.actionsIconTheme);
		m.put("color", p.color);
		m.put("backgroundColor", p.backgroundColor);
		m.put("foregroundColor", p.foregroundColor);
		m.put("elevation", p.elevation);
		m.put("scrolledUnderElevation", p.scrolledUnderElevation);
		m.put("shadowColor", p.shadowColor);
		m.put("surfaceTintColor", p.surfaceTintColor);
		m.put("shape", p.shape);
		m.put("iconTheme", p.iconTheme);
		m.put("centerTitle", p.centerTitle);
		m.put("titleSpacing", p.titleSpacing);
		m.put("toolbarHeight", p.toolbarHeight);
		m.put("toolbarTextStyle", p.toolbarTextStyle);
		m.put("titleTextStyle", p.titleTextStyle);
		m.put("systemOverlayStyle", p.systemOverlayStyle);
		shptr<class AppBarTheme> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class AppBarTheme> /*non-null*/ AppBarTheme::of(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("AppBarTheme", "of");
		m.put("context", context, true);
		shptr<class AppBarTheme> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class AppBarTheme> /*non-null*/ AppBarTheme::lerp(/*nullable*/ shptr<class AppBarTheme> a, /*nullable*/ shptr<class AppBarTheme> b, /*non-null*/ double t) {
		auto m = ManagedCall("AppBarTheme", "lerp");
		m.put("a", a);
		m.put("b", b);
		m.put("t", t);
		shptr<class AppBarTheme> result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ AppBarTheme::equals(/*non-null*/ shptr<class ObjBase> other) {
		auto m = ManagedCall("AppBarTheme", "==");
		m.put("this", this);
		m.put("other", other, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class AppBarTheme> /*non-null*/ AppBarTheme::ctorMain(_ctorMain p) {
		auto m = ManagedCall("AppBarTheme", "AppBarTheme");
		m.put("color", p.color);
		m.put("backgroundColor", p.backgroundColor);
		m.put("foregroundColor", p.foregroundColor);
		m.put("elevation", p.elevation);
		m.put("scrolledUnderElevation", p.scrolledUnderElevation);
		m.put("shadowColor", p.shadowColor);
		m.put("surfaceTintColor", p.surfaceTintColor);
		m.put("shape", p.shape);
		m.put("iconTheme", p.iconTheme);
		m.put("actionsIconTheme", p.actionsIconTheme);
		m.put("centerTitle", p.centerTitle);
		m.put("titleSpacing", p.titleSpacing);
		m.put("toolbarHeight", p.toolbarHeight);
		m.put("toolbarTextStyle", p.toolbarTextStyle);
		m.put("titleTextStyle", p.titleTextStyle);
		m.put("systemOverlayStyle", p.systemOverlayStyle);
		shptr<class AppBarTheme> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Color> /*var-nullable*/ BottomAppBarTheme::color() {
		auto m = ManagedCall("BottomAppBarTheme", "color");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ BottomAppBarTheme::elevation() {
		auto m = ManagedCall("BottomAppBarTheme", "elevation");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	shptr<class NotchedShape> /*var-nullable*/ BottomAppBarTheme::shape() {
		auto m = ManagedCall("BottomAppBarTheme", "shape");
		m.put("this", this);
		shptr<class NotchedShape> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ BottomAppBarTheme::height() {
		auto m = ManagedCall("BottomAppBarTheme", "height");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ BottomAppBarTheme::surfaceTintColor() {
		auto m = ManagedCall("BottomAppBarTheme", "surfaceTintColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ BottomAppBarTheme::shadowColor() {
		auto m = ManagedCall("BottomAppBarTheme", "shadowColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class EdgeInsetsGeometry> /*var-nullable*/ BottomAppBarTheme::padding() {
		auto m = ManagedCall("BottomAppBarTheme", "padding");
		m.put("this", this);
		shptr<class EdgeInsetsGeometry> result;
		m.call(result);
		return result;
	}

	shptr<class BottomAppBarTheme> /*non-null*/ BottomAppBarTheme::copyWith(_copyWith p) {
		auto m = ManagedCall("BottomAppBarTheme", "copyWith");
		m.put("this", this);
		m.put("color", p.color);
		m.put("elevation", p.elevation);
		m.put("shape", p.shape);
		m.put("height", p.height);
		m.put("surfaceTintColor", p.surfaceTintColor);
		m.put("shadowColor", p.shadowColor);
		m.put("padding", p.padding);
		shptr<class BottomAppBarTheme> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class BottomAppBarTheme> /*non-null*/ BottomAppBarTheme::of(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("BottomAppBarTheme", "of");
		m.put("context", context, true);
		shptr<class BottomAppBarTheme> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class BottomAppBarTheme> /*non-null*/ BottomAppBarTheme::lerp(/*nullable*/ shptr<class BottomAppBarTheme> a, /*nullable*/ shptr<class BottomAppBarTheme> b, /*non-null*/ double t) {
		auto m = ManagedCall("BottomAppBarTheme", "lerp");
		m.put("a", a);
		m.put("b", b);
		m.put("t", t);
		shptr<class BottomAppBarTheme> result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ BottomAppBarTheme::equals(/*non-null*/ shptr<class ObjBase> other) {
		auto m = ManagedCall("BottomAppBarTheme", "==");
		m.put("this", this);
		m.put("other", other, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class BottomAppBarTheme> /*non-null*/ BottomAppBarTheme::ctorMain(_ctorMain p) {
		auto m = ManagedCall("BottomAppBarTheme", "BottomAppBarTheme");
		m.put("color", p.color);
		m.put("elevation", p.elevation);
		m.put("shape", p.shape);
		m.put("height", p.height);
		m.put("surfaceTintColor", p.surfaceTintColor);
		m.put("shadowColor", p.shadowColor);
		m.put("padding", p.padding);
		shptr<class BottomAppBarTheme> result;
		m.check(m.call(result, true));
		return result;
	}

	stdop<Clip> /*var-nullable*/ CardTheme::clipBehavior() {
		auto m = ManagedCall("CardTheme", "clipBehavior");
		m.put("this", this);
		stdop<Clip> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ CardTheme::color() {
		auto m = ManagedCall("CardTheme", "color");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ CardTheme::shadowColor() {
		auto m = ManagedCall("CardTheme", "shadowColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ CardTheme::surfaceTintColor() {
		auto m = ManagedCall("CardTheme", "surfaceTintColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ CardTheme::elevation() {
		auto m = ManagedCall("CardTheme", "elevation");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	shptr<class EdgeInsetsGeometry> /*var-nullable*/ CardTheme::margin() {
		auto m = ManagedCall("CardTheme", "margin");
		m.put("this", this);
		shptr<class EdgeInsetsGeometry> result;
		m.call(result);
		return result;
	}

	shptr<class ShapeBorder> /*var-nullable*/ CardTheme::shape() {
		auto m = ManagedCall("CardTheme", "shape");
		m.put("this", this);
		shptr<class ShapeBorder> result;
		m.call(result);
		return result;
	}

	shptr<class CardTheme> /*non-null*/ CardTheme::copyWith(_copyWith p) {
		auto m = ManagedCall("CardTheme", "copyWith");
		m.put("this", this);
		m.put("clipBehavior", p.clipBehavior);
		m.put("color", p.color);
		m.put("shadowColor", p.shadowColor);
		m.put("surfaceTintColor", p.surfaceTintColor);
		m.put("elevation", p.elevation);
		m.put("margin", p.margin);
		m.put("shape", p.shape);
		shptr<class CardTheme> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class CardTheme> /*non-null*/ CardTheme::of(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("CardTheme", "of");
		m.put("context", context, true);
		shptr<class CardTheme> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class CardTheme> /*non-null*/ CardTheme::lerp(/*nullable*/ shptr<class CardTheme> a, /*nullable*/ shptr<class CardTheme> b, /*non-null*/ double t) {
		auto m = ManagedCall("CardTheme", "lerp");
		m.put("a", a);
		m.put("b", b);
		m.put("t", t);
		shptr<class CardTheme> result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ CardTheme::equals(/*non-null*/ shptr<class ObjBase> other) {
		auto m = ManagedCall("CardTheme", "==");
		m.put("this", this);
		m.put("other", other, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class CardTheme> /*non-null*/ CardTheme::ctorMain(_ctorMain p) {
		auto m = ManagedCall("CardTheme", "CardTheme");
		m.put("clipBehavior", p.clipBehavior);
		m.put("color", p.color);
		m.put("shadowColor", p.shadowColor);
		m.put("surfaceTintColor", p.surfaceTintColor);
		m.put("elevation", p.elevation);
		m.put("margin", p.margin);
		m.put("shape", p.shape);
		shptr<class CardTheme> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Color> /*var-nullable*/ DialogTheme::backgroundColor() {
		auto m = ManagedCall("DialogTheme", "backgroundColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	stdop<double> /*var-nullable*/ DialogTheme::elevation() {
		auto m = ManagedCall("DialogTheme", "elevation");
		m.put("this", this);
		stdop<double> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ DialogTheme::shadowColor() {
		auto m = ManagedCall("DialogTheme", "shadowColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ DialogTheme::surfaceTintColor() {
		auto m = ManagedCall("DialogTheme", "surfaceTintColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class ShapeBorder> /*var-nullable*/ DialogTheme::shape() {
		auto m = ManagedCall("DialogTheme", "shape");
		m.put("this", this);
		shptr<class ShapeBorder> result;
		m.call(result);
		return result;
	}

	shptr<class AlignmentGeometry> /*var-nullable*/ DialogTheme::alignment() {
		auto m = ManagedCall("DialogTheme", "alignment");
		m.put("this", this);
		shptr<class AlignmentGeometry> result;
		m.call(result);
		return result;
	}

	shptr<class TextStyle> /*var-nullable*/ DialogTheme::titleTextStyle() {
		auto m = ManagedCall("DialogTheme", "titleTextStyle");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.call(result);
		return result;
	}

	shptr<class TextStyle> /*var-nullable*/ DialogTheme::contentTextStyle() {
		auto m = ManagedCall("DialogTheme", "contentTextStyle");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.call(result);
		return result;
	}

	shptr<class EdgeInsetsGeometry> /*var-nullable*/ DialogTheme::actionsPadding() {
		auto m = ManagedCall("DialogTheme", "actionsPadding");
		m.put("this", this);
		shptr<class EdgeInsetsGeometry> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ DialogTheme::iconColor() {
		auto m = ManagedCall("DialogTheme", "iconColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class DialogTheme> /*non-null*/ DialogTheme::copyWith(_copyWith p) {
		auto m = ManagedCall("DialogTheme", "copyWith");
		m.put("this", this);
		m.put("backgroundColor", p.backgroundColor);
		m.put("elevation", p.elevation);
		m.put("shadowColor", p.shadowColor);
		m.put("surfaceTintColor", p.surfaceTintColor);
		m.put("shape", p.shape);
		m.put("alignment", p.alignment);
		m.put("iconColor", p.iconColor);
		m.put("titleTextStyle", p.titleTextStyle);
		m.put("contentTextStyle", p.contentTextStyle);
		m.put("actionsPadding", p.actionsPadding);
		shptr<class DialogTheme> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class DialogTheme> /*non-null*/ DialogTheme::of(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("DialogTheme", "of");
		m.put("context", context, true);
		shptr<class DialogTheme> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class DialogTheme> /*non-null*/ DialogTheme::lerp(/*nullable*/ shptr<class DialogTheme> a, /*nullable*/ shptr<class DialogTheme> b, /*non-null*/ double t) {
		auto m = ManagedCall("DialogTheme", "lerp");
		m.put("a", a);
		m.put("b", b);
		m.put("t", t);
		shptr<class DialogTheme> result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ DialogTheme::equals(/*non-null*/ shptr<class ObjBase> other) {
		auto m = ManagedCall("DialogTheme", "==");
		m.put("this", this);
		m.put("other", other, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class DialogTheme> /*non-null*/ DialogTheme::ctorMain(_ctorMain p) {
		auto m = ManagedCall("DialogTheme", "DialogTheme");
		m.put("backgroundColor", p.backgroundColor);
		m.put("elevation", p.elevation);
		m.put("shadowColor", p.shadowColor);
		m.put("surfaceTintColor", p.surfaceTintColor);
		m.put("shape", p.shape);
		m.put("alignment", p.alignment);
		m.put("iconColor", p.iconColor);
		m.put("titleTextStyle", p.titleTextStyle);
		m.put("contentTextStyle", p.contentTextStyle);
		m.put("actionsPadding", p.actionsPadding);
		shptr<class DialogTheme> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class FloatingLabelAlignment> /*var-non-null*/ FloatingLabelAlignment::start() {
		auto m = ManagedCall("FloatingLabelAlignment", "start");
		shptr<class FloatingLabelAlignment> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class FloatingLabelAlignment> /*var-non-null*/ FloatingLabelAlignment::center() {
		auto m = ManagedCall("FloatingLabelAlignment", "center");
		shptr<class FloatingLabelAlignment> result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ FloatingLabelAlignment::equals(/*non-null*/ shptr<class ObjBase> other) {
		auto m = ManagedCall("FloatingLabelAlignment", "==");
		m.put("this", this);
		m.put("other", other, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class TextStyle> /*var-nullable*/ InputDecorationTheme::labelStyle() {
		auto m = ManagedCall("InputDecorationTheme", "labelStyle");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.call(result);
		return result;
	}

	shptr<class TextStyle> /*var-nullable*/ InputDecorationTheme::floatingLabelStyle() {
		auto m = ManagedCall("InputDecorationTheme", "floatingLabelStyle");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.call(result);
		return result;
	}

	shptr<class TextStyle> /*var-nullable*/ InputDecorationTheme::helperStyle() {
		auto m = ManagedCall("InputDecorationTheme", "helperStyle");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.call(result);
		return result;
	}

	stdop<int64> /*var-nullable*/ InputDecorationTheme::helperMaxLines() {
		auto m = ManagedCall("InputDecorationTheme", "helperMaxLines");
		m.put("this", this);
		stdop<int64> result;
		m.call(result);
		return result;
	}

	shptr<class TextStyle> /*var-nullable*/ InputDecorationTheme::hintStyle() {
		auto m = ManagedCall("InputDecorationTheme", "hintStyle");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.call(result);
		return result;
	}

	shptr<class TextStyle> /*var-nullable*/ InputDecorationTheme::errorStyle() {
		auto m = ManagedCall("InputDecorationTheme", "errorStyle");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.call(result);
		return result;
	}

	stdop<int64> /*var-nullable*/ InputDecorationTheme::errorMaxLines() {
		auto m = ManagedCall("InputDecorationTheme", "errorMaxLines");
		m.put("this", this);
		stdop<int64> result;
		m.call(result);
		return result;
	}

	FloatingLabelBehavior /*var-non-null*/ InputDecorationTheme::floatingLabelBehavior() {
		auto m = ManagedCall("InputDecorationTheme", "floatingLabelBehavior");
		m.put("this", this);
		FloatingLabelBehavior result;
		m.check(m.call(result));
		return result;
	}

	shptr<class FloatingLabelAlignment> /*var-non-null*/ InputDecorationTheme::floatingLabelAlignment() {
		auto m = ManagedCall("InputDecorationTheme", "floatingLabelAlignment");
		m.put("this", this);
		shptr<class FloatingLabelAlignment> result;
		m.check(m.call(result));
		return result;
	}

	bool /*var-non-null*/ InputDecorationTheme::isDense() {
		auto m = ManagedCall("InputDecorationTheme", "isDense");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class EdgeInsetsGeometry> /*var-nullable*/ InputDecorationTheme::contentPadding() {
		auto m = ManagedCall("InputDecorationTheme", "contentPadding");
		m.put("this", this);
		shptr<class EdgeInsetsGeometry> result;
		m.call(result);
		return result;
	}

	bool /*var-non-null*/ InputDecorationTheme::isCollapsed() {
		auto m = ManagedCall("InputDecorationTheme", "isCollapsed");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*var-nullable*/ InputDecorationTheme::iconColor() {
		auto m = ManagedCall("InputDecorationTheme", "iconColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class TextStyle> /*var-nullable*/ InputDecorationTheme::prefixStyle() {
		auto m = ManagedCall("InputDecorationTheme", "prefixStyle");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ InputDecorationTheme::prefixIconColor() {
		auto m = ManagedCall("InputDecorationTheme", "prefixIconColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class TextStyle> /*var-nullable*/ InputDecorationTheme::suffixStyle() {
		auto m = ManagedCall("InputDecorationTheme", "suffixStyle");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ InputDecorationTheme::suffixIconColor() {
		auto m = ManagedCall("InputDecorationTheme", "suffixIconColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class TextStyle> /*var-nullable*/ InputDecorationTheme::counterStyle() {
		auto m = ManagedCall("InputDecorationTheme", "counterStyle");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.call(result);
		return result;
	}

	bool /*var-non-null*/ InputDecorationTheme::filled() {
		auto m = ManagedCall("InputDecorationTheme", "filled");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Color> /*var-nullable*/ InputDecorationTheme::fillColor() {
		auto m = ManagedCall("InputDecorationTheme", "fillColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class BorderSide> /*var-nullable*/ InputDecorationTheme::outlineBorder() {
		auto m = ManagedCall("InputDecorationTheme", "outlineBorder");
		m.put("this", this);
		shptr<class BorderSide> result;
		m.call(result);
		return result;
	}

	shptr<class BorderSide> /*var-nullable*/ InputDecorationTheme::activeIndicatorBorder() {
		auto m = ManagedCall("InputDecorationTheme", "activeIndicatorBorder");
		m.put("this", this);
		shptr<class BorderSide> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ InputDecorationTheme::focusColor() {
		auto m = ManagedCall("InputDecorationTheme", "focusColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ InputDecorationTheme::hoverColor() {
		auto m = ManagedCall("InputDecorationTheme", "hoverColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class InputBorder> /*var-nullable*/ InputDecorationTheme::errorBorder() {
		auto m = ManagedCall("InputDecorationTheme", "errorBorder");
		m.put("this", this);
		shptr<class InputBorder> result;
		m.call(result);
		return result;
	}

	shptr<class InputBorder> /*var-nullable*/ InputDecorationTheme::focusedBorder() {
		auto m = ManagedCall("InputDecorationTheme", "focusedBorder");
		m.put("this", this);
		shptr<class InputBorder> result;
		m.call(result);
		return result;
	}

	shptr<class InputBorder> /*var-nullable*/ InputDecorationTheme::focusedErrorBorder() {
		auto m = ManagedCall("InputDecorationTheme", "focusedErrorBorder");
		m.put("this", this);
		shptr<class InputBorder> result;
		m.call(result);
		return result;
	}

	shptr<class InputBorder> /*var-nullable*/ InputDecorationTheme::disabledBorder() {
		auto m = ManagedCall("InputDecorationTheme", "disabledBorder");
		m.put("this", this);
		shptr<class InputBorder> result;
		m.call(result);
		return result;
	}

	shptr<class InputBorder> /*var-nullable*/ InputDecorationTheme::enabledBorder() {
		auto m = ManagedCall("InputDecorationTheme", "enabledBorder");
		m.put("this", this);
		shptr<class InputBorder> result;
		m.call(result);
		return result;
	}

	shptr<class InputBorder> /*var-nullable*/ InputDecorationTheme::border() {
		auto m = ManagedCall("InputDecorationTheme", "border");
		m.put("this", this);
		shptr<class InputBorder> result;
		m.call(result);
		return result;
	}

	bool /*var-non-null*/ InputDecorationTheme::alignLabelWithHint() {
		auto m = ManagedCall("InputDecorationTheme", "alignLabelWithHint");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class BoxConstraints> /*var-nullable*/ InputDecorationTheme::constraints() {
		auto m = ManagedCall("InputDecorationTheme", "constraints");
		m.put("this", this);
		shptr<class BoxConstraints> result;
		m.call(result);
		return result;
	}

	shptr<class InputDecorationTheme> /*non-null*/ InputDecorationTheme::copyWith(_copyWith p) {
		auto m = ManagedCall("InputDecorationTheme", "copyWith");
		m.put("this", this);
		m.put("labelStyle", p.labelStyle);
		m.put("floatingLabelStyle", p.floatingLabelStyle);
		m.put("helperStyle", p.helperStyle);
		m.put("helperMaxLines", p.helperMaxLines);
		m.put("hintStyle", p.hintStyle);
		m.put("errorStyle", p.errorStyle);
		m.put("errorMaxLines", p.errorMaxLines);
		m.put("floatingLabelBehavior", p.floatingLabelBehavior);
		m.put("floatingLabelAlignment", p.floatingLabelAlignment);
		m.put("isDense", p.isDense);
		m.put("contentPadding", p.contentPadding);
		m.put("isCollapsed", p.isCollapsed);
		m.put("iconColor", p.iconColor);
		m.put("prefixStyle", p.prefixStyle);
		m.put("prefixIconColor", p.prefixIconColor);
		m.put("suffixStyle", p.suffixStyle);
		m.put("suffixIconColor", p.suffixIconColor);
		m.put("counterStyle", p.counterStyle);
		m.put("filled", p.filled);
		m.put("fillColor", p.fillColor);
		m.put("activeIndicatorBorder", p.activeIndicatorBorder);
		m.put("outlineBorder", p.outlineBorder);
		m.put("focusColor", p.focusColor);
		m.put("hoverColor", p.hoverColor);
		m.put("errorBorder", p.errorBorder);
		m.put("focusedBorder", p.focusedBorder);
		m.put("focusedErrorBorder", p.focusedErrorBorder);
		m.put("disabledBorder", p.disabledBorder);
		m.put("enabledBorder", p.enabledBorder);
		m.put("border", p.border);
		m.put("alignLabelWithHint", p.alignLabelWithHint);
		m.put("constraints", p.constraints);
		shptr<class InputDecorationTheme> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class InputDecorationTheme> /*non-null*/ InputDecorationTheme::merge(/*nullable*/ shptr<class InputDecorationTheme> inputDecorationTheme) {
		auto m = ManagedCall("InputDecorationTheme", "merge");
		m.put("this", this);
		m.put("inputDecorationTheme", inputDecorationTheme);
		shptr<class InputDecorationTheme> result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ InputDecorationTheme::equals(/*non-null*/ shptr<class ObjBase> other) {
		auto m = ManagedCall("InputDecorationTheme", "==");
		m.put("this", this);
		m.put("other", other, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class InputDecorationTheme> /*non-null*/ InputDecorationTheme::ctorMain(_ctorMain p) {
		auto m = ManagedCall("InputDecorationTheme", "InputDecorationTheme");
		m.put("labelStyle", p.labelStyle);
		m.put("floatingLabelStyle", p.floatingLabelStyle);
		m.put("helperStyle", p.helperStyle);
		m.put("helperMaxLines", p.helperMaxLines);
		m.put("hintStyle", p.hintStyle);
		m.put("errorStyle", p.errorStyle);
		m.put("errorMaxLines", p.errorMaxLines);
		m.put("floatingLabelBehavior", p.floatingLabelBehavior);
		m.put("floatingLabelAlignment", p.floatingLabelAlignment, true);
		m.put("isDense", p.isDense);
		m.put("contentPadding", p.contentPadding);
		m.put("isCollapsed", p.isCollapsed);
		m.put("iconColor", p.iconColor);
		m.put("prefixStyle", p.prefixStyle);
		m.put("prefixIconColor", p.prefixIconColor);
		m.put("suffixStyle", p.suffixStyle);
		m.put("suffixIconColor", p.suffixIconColor);
		m.put("counterStyle", p.counterStyle);
		m.put("filled", p.filled);
		m.put("fillColor", p.fillColor);
		m.put("activeIndicatorBorder", p.activeIndicatorBorder);
		m.put("outlineBorder", p.outlineBorder);
		m.put("focusColor", p.focusColor);
		m.put("hoverColor", p.hoverColor);
		m.put("errorBorder", p.errorBorder);
		m.put("focusedBorder", p.focusedBorder);
		m.put("focusedErrorBorder", p.focusedErrorBorder);
		m.put("disabledBorder", p.disabledBorder);
		m.put("enabledBorder", p.enabledBorder);
		m.put("border", p.border);
		m.put("alignLabelWithHint", p.alignLabelWithHint);
		m.put("constraints", p.constraints);
		shptr<class InputDecorationTheme> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class Decoration> /*var-nullable*/ TabBarTheme::indicator() {
		auto m = ManagedCall("TabBarTheme", "indicator");
		m.put("this", this);
		shptr<class Decoration> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ TabBarTheme::indicatorColor() {
		auto m = ManagedCall("TabBarTheme", "indicatorColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	stdop<TabBarIndicatorSize> /*var-nullable*/ TabBarTheme::indicatorSize() {
		auto m = ManagedCall("TabBarTheme", "indicatorSize");
		m.put("this", this);
		stdop<TabBarIndicatorSize> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ TabBarTheme::dividerColor() {
		auto m = ManagedCall("TabBarTheme", "dividerColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ TabBarTheme::labelColor() {
		auto m = ManagedCall("TabBarTheme", "labelColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class EdgeInsetsGeometry> /*var-nullable*/ TabBarTheme::labelPadding() {
		auto m = ManagedCall("TabBarTheme", "labelPadding");
		m.put("this", this);
		shptr<class EdgeInsetsGeometry> result;
		m.call(result);
		return result;
	}

	shptr<class TextStyle> /*var-nullable*/ TabBarTheme::labelStyle() {
		auto m = ManagedCall("TabBarTheme", "labelStyle");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.call(result);
		return result;
	}

	shptr<class Color> /*var-nullable*/ TabBarTheme::unselectedLabelColor() {
		auto m = ManagedCall("TabBarTheme", "unselectedLabelColor");
		m.put("this", this);
		shptr<class Color> result;
		m.call(result);
		return result;
	}

	shptr<class TextStyle> /*var-nullable*/ TabBarTheme::unselectedLabelStyle() {
		auto m = ManagedCall("TabBarTheme", "unselectedLabelStyle");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.call(result);
		return result;
	}

	shptr<class InteractiveInkFeatureFactory> /*var-nullable*/ TabBarTheme::splashFactory() {
		auto m = ManagedCall("TabBarTheme", "splashFactory");
		m.put("this", this);
		shptr<class InteractiveInkFeatureFactory> result;
		m.call(result);
		return result;
	}

	stdop<TabAlignment> /*var-nullable*/ TabBarTheme::tabAlignment() {
		auto m = ManagedCall("TabBarTheme", "tabAlignment");
		m.put("this", this);
		stdop<TabAlignment> result;
		m.call(result);
		return result;
	}

	shptr<class TabBarTheme> /*non-null*/ TabBarTheme::copyWith(_copyWith p) {
		auto m = ManagedCall("TabBarTheme", "copyWith");
		m.put("this", this);
		m.put("indicator", p.indicator);
		m.put("indicatorColor", p.indicatorColor);
		m.put("indicatorSize", p.indicatorSize);
		m.put("dividerColor", p.dividerColor);
		m.put("labelColor", p.labelColor);
		m.put("labelPadding", p.labelPadding);
		m.put("labelStyle", p.labelStyle);
		m.put("unselectedLabelColor", p.unselectedLabelColor);
		m.put("unselectedLabelStyle", p.unselectedLabelStyle);
		m.put("overlayColor", p.overlayColor);
		m.put("splashFactory", p.splashFactory);
		m.put("mouseCursor", p.mouseCursor);
		m.put("tabAlignment", p.tabAlignment);
		shptr<class TabBarTheme> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class TabBarTheme> /*non-null*/ TabBarTheme::of(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("TabBarTheme", "of");
		m.put("context", context, true);
		shptr<class TabBarTheme> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class TabBarTheme> /*non-null*/ TabBarTheme::lerp(/*non-null*/ shptr<class TabBarTheme> a, /*non-null*/ shptr<class TabBarTheme> b, /*non-null*/ double t) {
		auto m = ManagedCall("TabBarTheme", "lerp");
		m.put("a", a, true);
		m.put("b", b, true);
		m.put("t", t);
		shptr<class TabBarTheme> result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ TabBarTheme::equals(/*non-null*/ shptr<class ObjBase> other) {
		auto m = ManagedCall("TabBarTheme", "==");
		m.put("this", this);
		m.put("other", other, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class TabBarTheme> /*non-null*/ TabBarTheme::ctorMain(_ctorMain p) {
		auto m = ManagedCall("TabBarTheme", "TabBarTheme");
		m.put("indicator", p.indicator);
		m.put("indicatorColor", p.indicatorColor);
		m.put("indicatorSize", p.indicatorSize);
		m.put("dividerColor", p.dividerColor);
		m.put("labelColor", p.labelColor);
		m.put("labelPadding", p.labelPadding);
		m.put("labelStyle", p.labelStyle);
		m.put("unselectedLabelColor", p.unselectedLabelColor);
		m.put("unselectedLabelStyle", p.unselectedLabelStyle);
		m.put("overlayColor", p.overlayColor);
		m.put("splashFactory", p.splashFactory);
		m.put("mouseCursor", p.mouseCursor);
		m.put("tabAlignment", p.tabAlignment);
		shptr<class TabBarTheme> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class TextStyle> /*var-nullable*/ TextTheme::displayLarge() {
		auto m = ManagedCall("TextTheme", "displayLarge");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.call(result);
		return result;
	}

	shptr<class TextStyle> /*var-nullable*/ TextTheme::displayMedium() {
		auto m = ManagedCall("TextTheme", "displayMedium");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.call(result);
		return result;
	}

	shptr<class TextStyle> /*var-nullable*/ TextTheme::displaySmall() {
		auto m = ManagedCall("TextTheme", "displaySmall");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.call(result);
		return result;
	}

	shptr<class TextStyle> /*var-nullable*/ TextTheme::headlineLarge() {
		auto m = ManagedCall("TextTheme", "headlineLarge");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.call(result);
		return result;
	}

	shptr<class TextStyle> /*var-nullable*/ TextTheme::headlineMedium() {
		auto m = ManagedCall("TextTheme", "headlineMedium");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.call(result);
		return result;
	}

	shptr<class TextStyle> /*var-nullable*/ TextTheme::headlineSmall() {
		auto m = ManagedCall("TextTheme", "headlineSmall");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.call(result);
		return result;
	}

	shptr<class TextStyle> /*var-nullable*/ TextTheme::titleLarge() {
		auto m = ManagedCall("TextTheme", "titleLarge");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.call(result);
		return result;
	}

	shptr<class TextStyle> /*var-nullable*/ TextTheme::titleMedium() {
		auto m = ManagedCall("TextTheme", "titleMedium");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.call(result);
		return result;
	}

	shptr<class TextStyle> /*var-nullable*/ TextTheme::titleSmall() {
		auto m = ManagedCall("TextTheme", "titleSmall");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.call(result);
		return result;
	}

	shptr<class TextStyle> /*var-nullable*/ TextTheme::bodyLarge() {
		auto m = ManagedCall("TextTheme", "bodyLarge");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.call(result);
		return result;
	}

	shptr<class TextStyle> /*var-nullable*/ TextTheme::bodyMedium() {
		auto m = ManagedCall("TextTheme", "bodyMedium");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.call(result);
		return result;
	}

	shptr<class TextStyle> /*var-nullable*/ TextTheme::bodySmall() {
		auto m = ManagedCall("TextTheme", "bodySmall");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.call(result);
		return result;
	}

	shptr<class TextStyle> /*var-nullable*/ TextTheme::labelLarge() {
		auto m = ManagedCall("TextTheme", "labelLarge");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.call(result);
		return result;
	}

	shptr<class TextStyle> /*var-nullable*/ TextTheme::labelMedium() {
		auto m = ManagedCall("TextTheme", "labelMedium");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.call(result);
		return result;
	}

	shptr<class TextStyle> /*var-nullable*/ TextTheme::labelSmall() {
		auto m = ManagedCall("TextTheme", "labelSmall");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.call(result);
		return result;
	}

	shptr<class TextStyle> /*get-nullable*/ TextTheme::headline1() {
		auto m = ManagedCall("TextTheme", "headline1");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.call(result);
		return result;
	}

	shptr<class TextStyle> /*get-nullable*/ TextTheme::headline2() {
		auto m = ManagedCall("TextTheme", "headline2");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.call(result);
		return result;
	}

	shptr<class TextStyle> /*get-nullable*/ TextTheme::headline3() {
		auto m = ManagedCall("TextTheme", "headline3");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.call(result);
		return result;
	}

	shptr<class TextStyle> /*get-nullable*/ TextTheme::headline4() {
		auto m = ManagedCall("TextTheme", "headline4");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.call(result);
		return result;
	}

	shptr<class TextStyle> /*get-nullable*/ TextTheme::headline5() {
		auto m = ManagedCall("TextTheme", "headline5");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.call(result);
		return result;
	}

	shptr<class TextStyle> /*get-nullable*/ TextTheme::headline6() {
		auto m = ManagedCall("TextTheme", "headline6");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.call(result);
		return result;
	}

	shptr<class TextStyle> /*get-nullable*/ TextTheme::subtitle1() {
		auto m = ManagedCall("TextTheme", "subtitle1");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.call(result);
		return result;
	}

	shptr<class TextStyle> /*get-nullable*/ TextTheme::subtitle2() {
		auto m = ManagedCall("TextTheme", "subtitle2");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.call(result);
		return result;
	}

	shptr<class TextStyle> /*get-nullable*/ TextTheme::bodyText1() {
		auto m = ManagedCall("TextTheme", "bodyText1");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.call(result);
		return result;
	}

	shptr<class TextStyle> /*get-nullable*/ TextTheme::bodyText2() {
		auto m = ManagedCall("TextTheme", "bodyText2");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.call(result);
		return result;
	}

	shptr<class TextStyle> /*get-nullable*/ TextTheme::caption() {
		auto m = ManagedCall("TextTheme", "caption");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.call(result);
		return result;
	}

	shptr<class TextStyle> /*get-nullable*/ TextTheme::button() {
		auto m = ManagedCall("TextTheme", "button");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.call(result);
		return result;
	}

	shptr<class TextStyle> /*get-nullable*/ TextTheme::overline() {
		auto m = ManagedCall("TextTheme", "overline");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.call(result);
		return result;
	}

	shptr<class TextTheme> /*non-null*/ TextTheme::copyWith(_copyWith p) {
		auto m = ManagedCall("TextTheme", "copyWith");
		m.put("this", this);
		m.put("displayLarge", p.displayLarge);
		m.put("displayMedium", p.displayMedium);
		m.put("displaySmall", p.displaySmall);
		m.put("headlineLarge", p.headlineLarge);
		m.put("headlineMedium", p.headlineMedium);
		m.put("headlineSmall", p.headlineSmall);
		m.put("titleLarge", p.titleLarge);
		m.put("titleMedium", p.titleMedium);
		m.put("titleSmall", p.titleSmall);
		m.put("bodyLarge", p.bodyLarge);
		m.put("bodyMedium", p.bodyMedium);
		m.put("bodySmall", p.bodySmall);
		m.put("labelLarge", p.labelLarge);
		m.put("labelMedium", p.labelMedium);
		m.put("labelSmall", p.labelSmall);
		m.put("headline1", p.headline1);
		m.put("headline2", p.headline2);
		m.put("headline3", p.headline3);
		m.put("headline4", p.headline4);
		m.put("headline5", p.headline5);
		m.put("headline6", p.headline6);
		m.put("subtitle1", p.subtitle1);
		m.put("subtitle2", p.subtitle2);
		m.put("bodyText1", p.bodyText1);
		m.put("bodyText2", p.bodyText2);
		m.put("caption", p.caption);
		m.put("button", p.button);
		m.put("overline", p.overline);
		shptr<class TextTheme> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class TextTheme> /*non-null*/ TextTheme::merge(/*nullable*/ shptr<class TextTheme> other) {
		auto m = ManagedCall("TextTheme", "merge");
		m.put("this", this);
		m.put("other", other);
		shptr<class TextTheme> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class TextTheme> /*non-null*/ TextTheme::apply(_apply p) {
		auto m = ManagedCall("TextTheme", "apply");
		m.put("this", this);
		m.put("fontFamily", p.fontFamily);
		m.put("fontFamilyFallback", p.fontFamilyFallback);
		m.put("package", p.package);
		m.put("fontSizeFactor", p.fontSizeFactor);
		m.put("fontSizeDelta", p.fontSizeDelta);
		m.put("displayColor", p.displayColor);
		m.put("bodyColor", p.bodyColor);
		m.put("decoration", p.decoration);
		m.put("decorationColor", p.decorationColor);
		m.put("decorationStyle", p.decorationStyle);
		shptr<class TextTheme> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class TextTheme> /*non-null*/ TextTheme::lerp(/*nullable*/ shptr<class TextTheme> a, /*nullable*/ shptr<class TextTheme> b, /*non-null*/ double t) {
		auto m = ManagedCall("TextTheme", "lerp");
		m.put("a", a);
		m.put("b", b);
		m.put("t", t);
		shptr<class TextTheme> result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ TextTheme::equals(/*non-null*/ shptr<class ObjBase> other) {
		auto m = ManagedCall("TextTheme", "==");
		m.put("this", this);
		m.put("other", other, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class TextTheme> /*non-null*/ TextTheme::ctorMain(_ctorMain p) {
		auto m = ManagedCall("TextTheme", "TextTheme");
		m.put("displayLarge", p.displayLarge);
		m.put("displayMedium", p.displayMedium);
		m.put("displaySmall", p.displaySmall);
		m.put("headlineLarge", p.headlineLarge);
		m.put("headlineMedium", p.headlineMedium);
		m.put("headlineSmall", p.headlineSmall);
		m.put("titleLarge", p.titleLarge);
		m.put("titleMedium", p.titleMedium);
		m.put("titleSmall", p.titleSmall);
		m.put("bodyLarge", p.bodyLarge);
		m.put("bodyMedium", p.bodyMedium);
		m.put("bodySmall", p.bodySmall);
		m.put("labelLarge", p.labelLarge);
		m.put("labelMedium", p.labelMedium);
		m.put("labelSmall", p.labelSmall);
		m.put("headline1", p.headline1);
		m.put("headline2", p.headline2);
		m.put("headline3", p.headline3);
		m.put("headline4", p.headline4);
		m.put("headline5", p.headline5);
		m.put("headline6", p.headline6);
		m.put("subtitle1", p.subtitle1);
		m.put("subtitle2", p.subtitle2);
		m.put("bodyText1", p.bodyText1);
		m.put("bodyText2", p.bodyText2);
		m.put("caption", p.caption);
		m.put("button", p.button);
		m.put("overline", p.overline);
		shptr<class TextTheme> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class ThemeData> /*var-non-null*/ AnimatedTheme::data() {
		auto m = ManagedCall("AnimatedTheme", "data");
		m.put("this", this);
		shptr<class ThemeData> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Widget> /*var-non-null*/ AnimatedTheme::child() {
		auto m = ManagedCall("AnimatedTheme", "child");
		m.put("this", this);
		shptr<class Widget> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class AnimatedTheme> /*non-null*/ AnimatedTheme::ctorMain(_ctorMain p) {
		auto m = ManagedCall("AnimatedTheme", "AnimatedTheme");
		m.put("key", p.key);
		m.put("data", p.data, true);
		m.put("curve", p.curve, true);
		m.put("duration", p.duration, true);
		m.put("onEnd", p.onEnd);
		m.put("child", p.child, true);
		shptr<class AnimatedTheme> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class TextHeightBehavior> /*var-non-null*/ DefaultTextHeightBehavior::textHeightBehavior() {
		auto m = ManagedCall("DefaultTextHeightBehavior", "textHeightBehavior");
		m.put("this", this);
		shptr<class TextHeightBehavior> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class TextHeightBehavior> /*nullable*/ DefaultTextHeightBehavior::maybeOf(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("DefaultTextHeightBehavior", "maybeOf");
		m.put("context", context, true);
		shptr<class TextHeightBehavior> result;
		m.call(result);
		return result;
	}

	shptr<class TextHeightBehavior> /*non-null*/ DefaultTextHeightBehavior::of(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("DefaultTextHeightBehavior", "of");
		m.put("context", context, true);
		shptr<class TextHeightBehavior> result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ DefaultTextHeightBehavior::updateShouldNotify(/*non-null*/ shptr<class DefaultTextHeightBehavior> oldWidget) {
		auto m = ManagedCall("DefaultTextHeightBehavior", "updateShouldNotify");
		m.put("this", this);
		m.put("oldWidget", oldWidget, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Widget> /*non-null*/ DefaultTextHeightBehavior::wrap(/*non-null*/ shptr<class BuildContext> context, /*non-null*/ shptr<class Widget> child) {
		auto m = ManagedCall("DefaultTextHeightBehavior", "wrap");
		m.put("this", this);
		m.put("context", context, true);
		m.put("child", child, true);
		shptr<class Widget> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class DefaultTextHeightBehavior> /*non-null*/ DefaultTextHeightBehavior::ctorMain(_ctorMain p) {
		auto m = ManagedCall("DefaultTextHeightBehavior", "DefaultTextHeightBehavior");
		m.put("key", p.key);
		m.put("textHeightBehavior", p.textHeightBehavior, true);
		m.put("child", p.child, true);
		shptr<class DefaultTextHeightBehavior> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class TextStyle> /*var-non-null*/ DefaultTextStyle::style() {
		auto m = ManagedCall("DefaultTextStyle", "style");
		m.put("this", this);
		shptr<class TextStyle> result;
		m.check(m.call(result));
		return result;
	}

	stdop<TextAlign> /*var-nullable*/ DefaultTextStyle::textAlign() {
		auto m = ManagedCall("DefaultTextStyle", "textAlign");
		m.put("this", this);
		stdop<TextAlign> result;
		m.call(result);
		return result;
	}

	bool /*var-non-null*/ DefaultTextStyle::softWrap() {
		auto m = ManagedCall("DefaultTextStyle", "softWrap");
		m.put("this", this);
		bool result;
		m.check(m.call(result));
		return result;
	}

	TextOverflow /*var-non-null*/ DefaultTextStyle::overflow() {
		auto m = ManagedCall("DefaultTextStyle", "overflow");
		m.put("this", this);
		TextOverflow result;
		m.check(m.call(result));
		return result;
	}

	stdop<int64> /*var-nullable*/ DefaultTextStyle::maxLines() {
		auto m = ManagedCall("DefaultTextStyle", "maxLines");
		m.put("this", this);
		stdop<int64> result;
		m.call(result);
		return result;
	}

	TextWidthBasis /*var-non-null*/ DefaultTextStyle::textWidthBasis() {
		auto m = ManagedCall("DefaultTextStyle", "textWidthBasis");
		m.put("this", this);
		TextWidthBasis result;
		m.check(m.call(result));
		return result;
	}

	shptr<class TextHeightBehavior> /*var-nullable*/ DefaultTextStyle::textHeightBehavior() {
		auto m = ManagedCall("DefaultTextStyle", "textHeightBehavior");
		m.put("this", this);
		shptr<class TextHeightBehavior> result;
		m.call(result);
		return result;
	}

	shptr<class Widget> /*non-null*/ DefaultTextStyle::merge(_merge p) {
		auto m = ManagedCall("DefaultTextStyle", "merge");
		m.put("key", p.key);
		m.put("style", p.style);
		m.put("textAlign", p.textAlign);
		m.put("softWrap", p.softWrap);
		m.put("overflow", p.overflow);
		m.put("maxLines", p.maxLines);
		m.put("textWidthBasis", p.textWidthBasis);
		m.put("child", p.child, true);
		shptr<class Widget> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class DefaultTextStyle> /*non-null*/ DefaultTextStyle::of(/*non-null*/ shptr<class BuildContext> context) {
		auto m = ManagedCall("DefaultTextStyle", "of");
		m.put("context", context, true);
		shptr<class DefaultTextStyle> result;
		m.check(m.call(result));
		return result;
	}

	bool /*non-null*/ DefaultTextStyle::updateShouldNotify(/*non-null*/ shptr<class DefaultTextStyle> oldWidget) {
		auto m = ManagedCall("DefaultTextStyle", "updateShouldNotify");
		m.put("this", this);
		m.put("oldWidget", oldWidget, true);
		bool result;
		m.check(m.call(result));
		return result;
	}

	shptr<class Widget> /*non-null*/ DefaultTextStyle::wrap(/*non-null*/ shptr<class BuildContext> context, /*non-null*/ shptr<class Widget> child) {
		auto m = ManagedCall("DefaultTextStyle", "wrap");
		m.put("this", this);
		m.put("context", context, true);
		m.put("child", child, true);
		shptr<class Widget> result;
		m.check(m.call(result));
		return result;
	}

	shptr<class DefaultTextStyle> /*non-null*/ DefaultTextStyle::ctorMain(_ctorMain p) {
		auto m = ManagedCall("DefaultTextStyle", "DefaultTextStyle");
		m.put("key", p.key);
		m.put("style", p.style, true);
		m.put("textAlign", p.textAlign);
		m.put("softWrap", p.softWrap);
		m.put("overflow", p.overflow);
		m.put("maxLines", p.maxLines);
		m.put("textWidthBasis", p.textWidthBasis);
		m.put("textHeightBehavior", p.textHeightBehavior);
		m.put("child", p.child, true);
		shptr<class DefaultTextStyle> result;
		m.check(m.call(result, true));
		return result;
	}

	shptr<class DefaultTextStyle> /*non-null*/ DefaultTextStyle::fallback(_fallback p) {
		auto m = ManagedCall("DefaultTextStyle", "fallback");
		m.put("key", p.key);
		shptr<class DefaultTextStyle> result;
		m.check(m.call(result, true));
		return result;
	}

